.owl-theme .owl-nav .owl-prev:before/* FILE: app.js */
/*!
 * jQuery JavaScript Library v2.2.4
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-05-20T17:23Z
 */

(function(global, factory) {

    if (typeof module === "object" && typeof module.exports === "object") {
        // For CommonJS and CommonJS-like environments where a proper `window`
        // is present, execute the factory and get jQuery.
        // For environments that do not have a `window` with a `document`
        // (such as Node.js), expose a factory as module.exports.
        // This accentuates the need for the creation of a real `window`.
        // e.g. var jQuery = require("jquery")(window);
        // See ticket #14549 for more info.
        module.exports = global.document ? factory(global, true) : function(w) {
            if (!w.document) {
                throw new Error("jQuery requires a window with a document");
            }
            return factory(w);
        }
        ;
    } else {
        factory(global);
    }

    // Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function(window, noGlobal) {

    // Support: Firefox 18+
    // Can't be in strict mode, several libs including ASP.NET trace
    // the stack via arguments.caller.callee and Firefox dies if
    // you try to trace through "use strict" call chains. (#13335)
    //"use strict";
    var arr = [];

    var document = window.document;

    var slice = arr.slice;

    var concat = arr.concat;

    var push = arr.push;

    var indexOf = arr.indexOf;

    var class2type = {};

    var toString = class2type.toString;

    var hasOwn = class2type.hasOwnProperty;

    var support = {};

    var version = "2.2.4"
      ,
    // Define a local copy of jQuery
    jQuery = function(selector, context) {

        // The jQuery object is actually just the init constructor 'enhanced'
        // Need init if jQuery is called (just allow error to be thrown if not included)
        return new jQuery.fn.init(selector,context);
    }
      ,
    // Support: Android<4.1
    // Make sure we trim BOM and NBSP
    rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g
      ,
    // Matches dashed string for camelizing
    rmsPrefix = /^-ms-/
      , rdashAlpha = /-([\da-z])/gi
      ,
    // Used by jQuery.camelCase as callback to replace()
    fcamelCase = function(all, letter) {
        return letter.toUpperCase();
    };

    jQuery.fn = jQuery.prototype = {

        // The current version of jQuery being used
        jquery: version,

        constructor: jQuery,

        // Start with an empty selector
        selector: "",

        // The default length of a jQuery object is 0
        length: 0,

        toArray: function() {
            return slice.call(this);
        },

        // Get the Nth element in the matched element set OR
        // Get the whole matched element set as a clean array
        get: function(num) {
            return num != null ?
            // Return just the one element from the set
            (num < 0 ? this[num + this.length] : this[num]) :
            // Return all the elements in a clean array
            slice.call(this);
        },

        // Take an array of elements and push it onto the stack
        // (returning the new matched element set)
        pushStack: function(elems) {

            // Build a new jQuery matched element set
            var ret = jQuery.merge(this.constructor(), elems);

            // Add the old object onto the stack (as a reference)
            ret.prevObject = this;
            ret.context = this.context;

            // Return the newly-formed element set
            return ret;
        },

        // Execute a callback for every element in the matched set.
        each: function(callback) {
            return jQuery.each(this, callback);
        },

        map: function(callback) {
            return this.pushStack(jQuery.map(this, function(elem, i) {
                return callback.call(elem, i, elem);
            }));
        },

        slice: function() {
            return this.pushStack(slice.apply(this, arguments));
        },

        first: function() {
            return this.eq(0);
        },

        last: function() {
            return this.eq(-1);
        },

        eq: function(i) {
            var len = this.length
              , j = +i + (i < 0 ? len : 0);
            return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
        },

        end: function() {
            return this.prevObject || this.constructor();
        },

        // For internal use only.
        // Behaves like an Array's method, not like a jQuery method.
        push: push,
        sort: arr.sort,
        splice: arr.splice
    };

    jQuery.extend = jQuery.fn.extend = function() {
        var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;

        // Handle a deep copy situation
        if (typeof target === "boolean") {
            deep = target;

            // Skip the boolean and the target
            target = arguments[i] || {};
            i++;
        }

        // Handle case when target is a string or something (possible in deep copy)
        if (typeof target !== "object" && !jQuery.isFunction(target)) {
            target = {};
        }

        // Extend jQuery itself if only one argument is passed
        if (i === length) {
            target = this;
            i--;
        }

        for (; i < length; i++) {

            // Only deal with non-null/undefined values
            if ((options = arguments[i]) != null) {

                // Extend the base object
                for (name in options) {
                    src = target[name];
                    copy = options[name];

                    // Prevent never-ending loop
                    if (target === copy) {
                        continue;
                    }

                    // Recurse if we're merging plain objects or arrays
                    if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {

                        if (copyIsArray) {
                            copyIsArray = false;
                            clone = src && jQuery.isArray(src) ? src : [];

                        } else {
                            clone = src && jQuery.isPlainObject(src) ? src : {};
                        }

                        // Never move original objects, clone them
                        target[name] = jQuery.extend(deep, clone, copy);

                        // Don't bring in undefined values
                    } else if (copy !== undefined) {
                        target[name] = copy;
                    }
                }
            }
        }

        // Return the modified object
        return target;
    }
    ;

    jQuery.extend({

        // Unique for each copy of jQuery on the page
        expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),

        // Assume jQuery is ready without the ready module
        isReady: true,

        error: function(msg) {
            throw new Error(msg);
        },

        noop: function() {},

        isFunction: function(obj) {
            return jQuery.type(obj) === "function";
        },

        isArray: Array.isArray,

        isWindow: function(obj) {
            return obj != null && obj === obj.window;
        },

        isNumeric: function(obj) {

            // parseFloat NaNs numeric-cast false positives (null|true|false|"")
            // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
            // subtraction forces infinities to NaN
            // adding 1 corrects loss of precision from parseFloat (#15100)
            var realStringObj = obj && obj.toString();
            return !jQuery.isArray(obj) && (realStringObj - parseFloat(realStringObj) + 1) >= 0;
        },

        isPlainObject: function(obj) {
            var key;

            // Not plain objects:
            // - Any object or value whose internal [[Class]] property is not "[object Object]"
            // - DOM nodes
            // - window
            if (jQuery.type(obj) !== "object" || obj.nodeType || jQuery.isWindow(obj)) {
                return false;
            }

            // Not own constructor property must be Object
            if (obj.constructor && !hasOwn.call(obj, "constructor") && !hasOwn.call(obj.constructor.prototype || {}, "isPrototypeOf")) {
                return false;
            }

            // Own properties are enumerated firstly, so to speed up,
            // if last one is own, then all properties are own
            for (key in obj) {}

            return key === undefined || hasOwn.call(obj, key);
        },

        isEmptyObject: function(obj) {
            var name;
            for (name in obj) {
                return false;
            }
            return true;
        },

        type: function(obj) {
            if (obj == null) {
                return obj + "";
            }

            // Support: Android<4.0, iOS<6 (functionish RegExp)
            return typeof obj === "object" || typeof obj === "function" ? class2type[toString.call(obj)] || "object" : typeof obj;
        },

        // Evaluates a script in a global context
        globalEval: function(code) {
            var script, indirect = eval;

            code = jQuery.trim(code);

            if (code) {

                // If the code includes a valid, prologue position
                // strict mode pragma, execute code by injecting a
                // script tag into the document.
                if (code.indexOf("use strict") === 1) {
                    script = document.createElement("script");
                    script.text = code;
                    document.head.appendChild(script).parentNode.removeChild(script);
                } else {

                    // Otherwise, avoid the DOM node creation, insertion
                    // and removal by using an indirect global eval

                    indirect(code);
                }
            }
        },

        // Convert dashed to camelCase; used by the css and data modules
        // Support: IE9-11+
        // Microsoft forgot to hump their vendor prefix (#9572)
        camelCase: function(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase);
        },

        nodeName: function(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
        },

        each: function(obj, callback) {
            var length, i = 0;

            if (isArrayLike(obj)) {
                length = obj.length;
                for (; i < length; i++) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            } else {
                for (i in obj) {
                    if (callback.call(obj[i], i, obj[i]) === false) {
                        break;
                    }
                }
            }

            return obj;
        },

        // Support: Android<4.1
        trim: function(text) {
            return text == null ? "" : (text + "").replace(rtrim, "");
        },

        // results is for internal usage only
        makeArray: function(arr, results) {
            var ret = results || [];

            if (arr != null) {
                if (isArrayLike(Object(arr))) {
                    jQuery.merge(ret, typeof arr === "string" ? [arr] : arr);
                } else {
                    push.call(ret, arr);
                }
            }

            return ret;
        },

        inArray: function(elem, arr, i) {
            return arr == null ? -1 : indexOf.call(arr, elem, i);
        },

        merge: function(first, second) {
            var len = +second.length
              , j = 0
              , i = first.length;

            for (; j < len; j++) {
                first[i++] = second[j];
            }

            first.length = i;

            return first;
        },

        grep: function(elems, callback, invert) {
            var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;

            // Go through the array, only saving the items
            // that pass the validator function
            for (; i < length; i++) {
                callbackInverse = !callback(elems[i], i);
                if (callbackInverse !== callbackExpect) {
                    matches.push(elems[i]);
                }
            }

            return matches;
        },

        // arg is for internal usage only
        map: function(elems, callback, arg) {
            var length, value, i = 0, ret = [];

            // Go through the array, translating each of the items to their new values
            if (isArrayLike(elems)) {
                length = elems.length;
                for (; i < length; i++) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }

                // Go through every key on the object,
            } else {
                for (i in elems) {
                    value = callback(elems[i], i, arg);

                    if (value != null) {
                        ret.push(value);
                    }
                }
            }

            // Flatten any nested arrays
            return concat.apply([], ret);
        },

        // A global GUID counter for objects
        guid: 1,

        // Bind a function to a context, optionally partially applying any
        // arguments.
        proxy: function(fn, context) {
            var tmp, args, proxy;

            if (typeof context === "string") {
                tmp = fn[context];
                context = fn;
                fn = tmp;
            }

            // Quick check to determine if target is callable, in the spec
            // this throws a TypeError, but we will just return undefined.
            if (!jQuery.isFunction(fn)) {
                return undefined;
            }

            // Simulated bind
            args = slice.call(arguments, 2);
            proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)));
            }
            ;

            // Set the guid of unique handler to the same of original handler, so it can be removed
            proxy.guid = fn.guid = fn.guid || jQuery.guid++;

            return proxy;
        },

        now: Date.now,

        // jQuery.support is not used in Core but other projects attach their
        // properties to it so it needs to exist.
        support: support
    });

    // JSHint would error on this code due to the Symbol not being defined in ES5.
    // Defining this global in .jshintrc would create a danger of using the global
    // unguarded in another place, it seems safer to just disable JSHint for these
    // three lines.
    /* jshint ignore: start */
    if (typeof Symbol === "function") {
        jQuery.fn[Symbol.iterator] = arr[Symbol.iterator];
    }
    /* jshint ignore: end */

    // Populate the class2type map
    jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function(i, name) {
        class2type["[object " + name + "]"] = name.toLowerCase();
    });

    function isArrayLike(obj) {

        // Support: iOS 8.2 (not reproducible in simulator)
        // `in` check used to prevent JIT error (gh-2145)
        // hasOwn isn't used here due to false negatives
        // regarding Nodelist length in IE
        var length = !!obj && "length"in obj && obj.length
          , type = jQuery.type(obj);

        if (type === "function" || jQuery.isWindow(obj)) {
            return false;
        }

        return type === "array" || length === 0 || typeof length === "number" && length > 0 && (length - 1)in obj;
    }
    var Sizzle = /*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
    (function(window) {

        var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate,
        // Local document vars
        setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains,
        // Instance-specific data
        expando = "sizzle" + 1 * new Date(), preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
            if (a === b) {
                hasDuplicate = true;
            }
            return 0;
        },
        // General-purpose constants
        MAX_NEGATIVE = 1 << 31,
        // Instance methods
        hasOwn = ({}).hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, // Use a stripped-down indexOf as it's faster than native
        // http://jsperf.com/thor-indexof-vs-for/5
        indexOf = function(list, elem) {
            var i = 0
              , len = list.length;
            for (; i < len; i++) {
                if (list[i] === elem) {
                    return i;
                }
            }
            return -1;
        },
        booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
        // Regular expressions

        // http://www.w3.org/TR/css3-selectors/#whitespace
        whitespace = "[\\x20\\t\\r\\n\\f]",
        // http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
        identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",
        // Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
        attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + // Operator (capture 2)
        "*([*^$|!~]?=)" + whitespace + // "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
        "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
        pseudos = ":(" + identifier + ")(?:\\((" + // To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
        // 1. quoted (capture 3; capture 4 or capture 5)
        "('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" + // 2. simple (capture 6)
        "((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" + // 3. anything else (capture 2)
        ".*" + ")\\)|)",
        // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
        rwhitespace = new RegExp(whitespace + "+","g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$","g"),
        rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"),
        rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]","g"),
        rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"),
        matchExpr = {
            "ID": new RegExp("^#(" + identifier + ")"),
            "CLASS": new RegExp("^\\.(" + identifier + ")"),
            "TAG": new RegExp("^(" + identifier + "|[*])"),
            "ATTR": new RegExp("^" + attributes),
            "PSEUDO": new RegExp("^" + pseudos),
            "CHILD": new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)","i"),
            "bool": new RegExp("^(?:" + booleans + ")$","i"),
            // For use in libraries implementing .is()
            // We use this for POS matching in `select`
            "needsContext": new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)","i")
        },
        rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i,
        rnative = /^[^{]+\{\s*\[native \w/,
        // Easily-parseable/retrievable ID or TAG or CLASS selectors
        rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
        rsibling = /[+~]/, rescape = /'|\\/g,
        // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
        runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)","ig"), funescape = function(_, escaped, escapedWhitespace) {
            var high = "0x" + escaped - 0x10000;
            // NaN means non-codepoint
            // Support: Firefox<24
            // Workaround erroneous numeric interpretation of +"0x"
            return high !== high || escapedWhitespace ? escaped : high < 0 ? // BMP codepoint
            String.fromCharCode(high + 0x10000) : // Supplemental Plane codepoint (surrogate pair)
            String.fromCharCode(high >> 10 | 0xD800, high & 0x3FF | 0xDC00);
        },
        // Used for iframes
        // See setDocument()
        // Removing the function wrapper causes a "Permission Denied"
        // error in IE
        unloadHandler = function() {
            setDocument();
        };

        // Optimize for push.apply( _, NodeList )
        try {
            push.apply((arr = slice.call(preferredDoc.childNodes)), preferredDoc.childNodes);
            // Support: Android<4.0
            // Detect silently failing push.apply
            arr[preferredDoc.childNodes.length].nodeType;
        } catch (e) {
            push = {
                apply: arr.length ?
                // Leverage slice if possible
                function(target, els) {
                    push_native.apply(target, slice.call(els));
                }
                :
                // Support: IE<9
                // Otherwise append directly
                function(target, els) {
                    var j = target.length
                      , i = 0;
                    // Can't trust NodeList.length
                    while ((target[j++] = els[i++])) {}
                    target.length = j - 1;
                }
            };
        }

        function Sizzle(selector, context, results, seed) {
            var m, i, elem, nid, nidselect, match, groups, newSelector, newContext = context && context.ownerDocument,
            // nodeType defaults to 9, since context defaults to document
            nodeType = context ? context.nodeType : 9;

            results = results || [];

            // Return early from calls with invalid selector or context
            if (typeof selector !== "string" || !selector || nodeType !== 1 && nodeType !== 9 && nodeType !== 11) {

                return results;
            }

            // Try to shortcut find operations (as opposed to filters) in HTML documents
            if (!seed) {

                if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
                    setDocument(context);
                }
                context = context || document;

                if (documentIsHTML) {

                    // If the selector is sufficiently simple, try using a "get*By*" DOM method
                    // (excepting DocumentFragment context, where the methods don't exist)
                    if (nodeType !== 11 && (match = rquickExpr.exec(selector))) {

                        // ID selector
                        if ((m = match[1])) {

                            // Document context
                            if (nodeType === 9) {
                                if ((elem = context.getElementById(m))) {

                                    // Support: IE, Opera, Webkit
                                    // TODO: identify versions
                                    // getElementById can match elements by name instead of ID
                                    if (elem.id === m) {
                                        results.push(elem);
                                        return results;
                                    }
                                } else {
                                    return results;
                                }

                                // Element context
                            } else {

                                // Support: IE, Opera, Webkit
                                // TODO: identify versions
                                // getElementById can match elements by name instead of ID
                                if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) {

                                    results.push(elem);
                                    return results;
                                }
                            }

                            // Type selector
                        } else if (match[2]) {
                            push.apply(results, context.getElementsByTagName(selector));
                            return results;

                            // Class selector
                        } else if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {

                            push.apply(results, context.getElementsByClassName(m));
                            return results;
                        }
                    }

                    // Take advantage of querySelectorAll
                    if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {

                        if (nodeType !== 1) {
                            newContext = context;
                            newSelector = selector;

                            // qSA looks outside Element context, which is not what we want
                            // Thanks to Andrew Dupont for this workaround technique
                            // Support: IE <=8
                            // Exclude object elements
                        } else if (context.nodeName.toLowerCase() !== "object") {

                            // Capture the context ID, setting it first if necessary
                            if ((nid = context.getAttribute("id"))) {
                                nid = nid.replace(rescape, "\\$&");
                            } else {
                                context.setAttribute("id", (nid = expando));
                            }

                            // Prefix every selector in the list
                            groups = tokenize(selector);
                            i = groups.length;
                            nidselect = ridentifier.test(nid) ? "#" + nid : "[id='" + nid + "']";
                            while (i--) {
                                groups[i] = nidselect + " " + toSelector(groups[i]);
                            }
                            newSelector = groups.join(",");

                            // Expand context for sibling selectors
                            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
                        }

                        if (newSelector) {
                            try {
                                push.apply(results, newContext.querySelectorAll(newSelector));
                                return results;
                            } catch (qsaError) {} finally {
                                if (nid === expando) {
                                    context.removeAttribute("id");
                                }
                            }
                        }
                    }
                }
            }

            // All others
            return select(selector.replace(rtrim, "$1"), context, results, seed);
        }

        /**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
        function createCache() {
            var keys = [];

            function cache(key, value) {
                // Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
                if (keys.push(key + " ") > Expr.cacheLength) {
                    // Only keep the most recent entries
                    delete cache[keys.shift()];
                }
                return (cache[key + " "] = value);
            }
            return cache;
        }

        /**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
        function markFunction(fn) {
            fn[expando] = true;
            return fn;
        }

        /**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
        function assert(fn) {
            var div = document.createElement("div");

            try {
                return !!fn(div);
            } catch (e) {
                return false;
            } finally {
                // Remove from its parent by default
                if (div.parentNode) {
                    div.parentNode.removeChild(div);
                }
                // release memory in IE
                div = null;
            }
        }

        /**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
        function addHandle(attrs, handler) {
            var arr = attrs.split("|")
              , i = arr.length;

            while (i--) {
                Expr.attrHandle[arr[i]] = handler;
            }
        }

        /**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
        function siblingCheck(a, b) {
            var cur = b && a
              , diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);

            // Use IE sourceIndex if available on both nodes
            if (diff) {
                return diff;
            }

            // Check if b follows a
            if (cur) {
                while ((cur = cur.nextSibling)) {
                    if (cur === b) {
                        return -1;
                    }
                }
            }

            return a ? 1 : -1;
        }

        /**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
        function createInputPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return name === "input" && elem.type === type;
            }
            ;
        }

        /**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
        function createButtonPseudo(type) {
            return function(elem) {
                var name = elem.nodeName.toLowerCase();
                return (name === "input" || name === "button") && elem.type === type;
            }
            ;
        }

        /**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
        function createPositionalPseudo(fn) {
            return markFunction(function(argument) {
                argument = +argument;
                return markFunction(function(seed, matches) {
                    var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;

                    // Match elements found at the specified indexes
                    while (i--) {
                        if (seed[(j = matchIndexes[i])]) {
                            seed[j] = !(matches[j] = seed[j]);
                        }
                    }
                });
            });
        }

        /**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
        function testContext(context) {
            return context && typeof context.getElementsByTagName !== "undefined" && context;
        }

        // Expose support vars for convenience
        support = Sizzle.support = {};

        /**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
        isXML = Sizzle.isXML = function(elem) {
            // documentElement is verified for cases where it doesn't yet exist
            // (such as loading iframes in IE - #4833)
            var documentElement = elem && (elem.ownerDocument || elem).documentElement;
            return documentElement ? documentElement.nodeName !== "HTML" : false;
        }
        ;

        /**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
        setDocument = Sizzle.setDocument = function(node) {
            var hasCompare, parent, doc = node ? node.ownerDocument || node : preferredDoc;

            // Return early if doc is invalid or already selected
            if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
                return document;
            }

            // Update global variables
            document = doc;
            docElem = document.documentElement;
            documentIsHTML = !isXML(document);

            // Support: IE 9-11, Edge
            // Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
            if ((parent = document.defaultView) && parent.top !== parent) {
                // Support: IE 11
                if (parent.addEventListener) {
                    parent.addEventListener("unload", unloadHandler, false);

                    // Support: IE 9 - 10 only
                } else if (parent.attachEvent) {
                    parent.attachEvent("onunload", unloadHandler);
                }
            }

            /* Attributes
	---------------------------------------------------------------------- */

            // Support: IE<8
            // Verify that getAttribute really returns attributes and not properties
            // (excepting IE8 booleans)
            support.attributes = assert(function(div) {
                div.className = "i";
                return !div.getAttribute("className");
            });

            /* getElement(s)By*
	---------------------------------------------------------------------- */

            // Check if getElementsByTagName("*") returns only elements
            support.getElementsByTagName = assert(function(div) {
                div.appendChild(document.createComment(""));
                return !div.getElementsByTagName("*").length;
            });

            // Support: IE<9
            support.getElementsByClassName = rnative.test(document.getElementsByClassName);

            // Support: IE<10
            // Check if getElementById returns elements by name
            // The broken getElementById methods don't pick up programatically-set names,
            // so use a roundabout getElementsByName test
            support.getById = assert(function(div) {
                docElem.appendChild(div).id = expando;
                return !document.getElementsByName || !document.getElementsByName(expando).length;
            });

            // ID find and filter
            if (support.getById) {
                Expr.find["ID"] = function(id, context) {
                    if (typeof context.getElementById !== "undefined" && documentIsHTML) {
                        var m = context.getElementById(id);
                        return m ? [m] : [];
                    }
                }
                ;
                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        return elem.getAttribute("id") === attrId;
                    }
                    ;
                }
                ;
            } else {
                // Support: IE6/7
                // getElementById is not reliable as a find shortcut
                delete Expr.find["ID"];

                Expr.filter["ID"] = function(id) {
                    var attrId = id.replace(runescape, funescape);
                    return function(elem) {
                        var node = typeof elem.getAttributeNode !== "undefined" && elem.getAttributeNode("id");
                        return node && node.value === attrId;
                    }
                    ;
                }
                ;
            }

            // Tag
            Expr.find["TAG"] = support.getElementsByTagName ? function(tag, context) {
                if (typeof context.getElementsByTagName !== "undefined") {
                    return context.getElementsByTagName(tag);

                    // DocumentFragment nodes don't have gEBTN
                } else if (support.qsa) {
                    return context.querySelectorAll(tag);
                }
            }
            :
            function(tag, context) {
                var elem, tmp = [], i = 0, // By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
                results = context.getElementsByTagName(tag);

                // Filter out possible comments
                if (tag === "*") {
                    while ((elem = results[i++])) {
                        if (elem.nodeType === 1) {
                            tmp.push(elem);
                        }
                    }

                    return tmp;
                }
                return results;
            }
            ;

            // Class
            Expr.find["CLASS"] = support.getElementsByClassName && function(className, context) {
                if (typeof context.getElementsByClassName !== "undefined" && documentIsHTML) {
                    return context.getElementsByClassName(className);
                }
            }
            ;

            /* QSA/matchesSelector
	---------------------------------------------------------------------- */

            // QSA and matchesSelector support

            // matchesSelector(:active) reports false when true (IE9/Opera 11.5)
            rbuggyMatches = [];

            // qSa(:focus) reports false when true (Chrome 21)
            // We allow this because of a bug in IE8/9 that throws an error
            // whenever `document.activeElement` is accessed on an iframe
            // So, we allow :focus to pass through QSA all the time to avoid the IE error
            // See http://bugs.jquery.com/ticket/13378
            rbuggyQSA = [];

            if ((support.qsa = rnative.test(document.querySelectorAll))) {
                // Build QSA regex
                // Regex strategy adopted from Diego Perini
                assert(function(div) {
                    // Select is set to empty string on purpose
                    // This is to test IE's treatment of not explicitly
                    // setting a boolean content attribute,
                    // since its presence should be enough
                    // http://bugs.jquery.com/ticket/12359
                    docElem.appendChild(div).innerHTML = "<a id='" + expando + "'></a>" + "<select id='" + expando + "-\r\\' msallowcapture=''>" + "<option selected=''></option></select>";

                    // Support: IE8, Opera 11-12.16
                    // Nothing should be selected when empty strings follow ^= or $= or *=
                    // The test attribute must be unknown in Opera but "safe" for WinRT
                    // http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
                    if (div.querySelectorAll("[msallowcapture^='']").length) {
                        rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")");
                    }

                    // Support: IE8
                    // Boolean attributes and "value" are not treated correctly
                    if (!div.querySelectorAll("[selected]").length) {
                        rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")");
                    }

                    // Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
                    if (!div.querySelectorAll("[id~=" + expando + "-]").length) {
                        rbuggyQSA.push("~=");
                    }

                    // Webkit/Opera - :checked should return selected option elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    // IE8 throws error here and will not see later tests
                    if (!div.querySelectorAll(":checked").length) {
                        rbuggyQSA.push(":checked");
                    }

                    // Support: Safari 8+, iOS 8+
                    // https://bugs.webkit.org/show_bug.cgi?id=136851
                    // In-page `selector#id sibing-combinator selector` fails
                    if (!div.querySelectorAll("a#" + expando + "+*").length) {
                        rbuggyQSA.push(".#.+[+~]");
                    }
                });

                assert(function(div) {
                    // Support: Windows 8 Native Apps
                    // The type and name attributes are restricted during .innerHTML assignment
                    var input = document.createElement("input");
                    input.setAttribute("type", "hidden");
                    div.appendChild(input).setAttribute("name", "D");

                    // Support: IE8
                    // Enforce case-sensitivity of name attribute
                    if (div.querySelectorAll("[name=d]").length) {
                        rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?=");
                    }

                    // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
                    // IE8 throws error here and will not see later tests
                    if (!div.querySelectorAll(":enabled").length) {
                        rbuggyQSA.push(":enabled", ":disabled");
                    }

                    // Opera 10-11 does not throw on post-comma invalid pseudos
                    div.querySelectorAll("*,:x");
                    rbuggyQSA.push(",.*:");
                });
            }

            if ((support.matchesSelector = rnative.test((matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)))) {

                assert(function(div) {
                    // Check to see if it's possible to do matchesSelector
                    // on a disconnected node (IE 9)
                    support.disconnectedMatch = matches.call(div, "div");

                    // This should fail with an exception
                    // Gecko does not error, returns false instead
                    matches.call(div, "[s!='']:x");
                    rbuggyMatches.push("!=", pseudos);
                });
            }

            rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|"));
            rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|"));

            /* Contains
	---------------------------------------------------------------------- */
            hasCompare = rnative.test(docElem.compareDocumentPosition);

            // Element contains another
            // Purposefully self-exclusive
            // As in, an element does not contain itself
            contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                var adown = a.nodeType === 9 ? a.documentElement : a
                  , bup = b && b.parentNode;
                return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
            }
            : function(a, b) {
                if (b) {
                    while ((b = b.parentNode)) {
                        if (b === a) {
                            return true;
                        }
                    }
                }
                return false;
            }
            ;

            /* Sorting
	---------------------------------------------------------------------- */

            // Document order sorting
            sortOrder = hasCompare ? function(a, b) {

                // Flag for duplicate removal
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                // Sort on method existence if only one input has compareDocumentPosition
                var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                if (compare) {
                    return compare;
                }

                // Calculate position if both inputs belong to the same document
                compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) :
                // Otherwise we know they are disconnected
                1;

                // Disconnected nodes
                if (compare & 1 || (!support.sortDetached && b.compareDocumentPosition(a) === compare)) {

                    // Choose the first element that is related to our preferred document
                    if (a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
                        return -1;
                    }
                    if (b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
                        return 1;
                    }

                    // Maintain original order
                    return sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;
                }

                return compare & 4 ? -1 : 1;
            }
            : function(a, b) {
                // Exit early if the nodes are identical
                if (a === b) {
                    hasDuplicate = true;
                    return 0;
                }

                var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];

                // Parentless nodes are either documents or disconnected
                if (!aup || !bup) {
                    return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? (indexOf(sortInput, a) - indexOf(sortInput, b)) : 0;

                    // If the nodes are siblings, we can do a quick check
                } else if (aup === bup) {
                    return siblingCheck(a, b);
                }

                // Otherwise we need full lists of their ancestors for comparison
                cur = a;
                while ((cur = cur.parentNode)) {
                    ap.unshift(cur);
                }
                cur = b;
                while ((cur = cur.parentNode)) {
                    bp.unshift(cur);
                }

                // Walk down the tree looking for a discrepancy
                while (ap[i] === bp[i]) {
                    i++;
                }

                return i ? // Do a sibling check if the nodes have a common ancestor
                siblingCheck(ap[i], bp[i]) :
                // Otherwise nodes in our document sort first
                ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
            }
            ;

            return document;
        }
        ;

        Sizzle.matches = function(expr, elements) {
            return Sizzle(expr, null, null, elements);
        }
        ;

        Sizzle.matchesSelector = function(elem, expr) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }

            // Make sure that attribute selectors are quoted
            expr = expr.replace(rattributeQuotes, "='$1']");

            if (support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {

                try {
                    var ret = matches.call(elem, expr);

                    // IE 9's matchesSelector returns false on disconnected nodes
                    if (ret || support.disconnectedMatch || // As well, disconnected nodes are said to be in a document
                    // fragment in IE 9
                    elem.document && elem.document.nodeType !== 11) {
                        return ret;
                    }
                } catch (e) {}
            }

            return Sizzle(expr, document, null, [elem]).length > 0;
        }
        ;

        Sizzle.contains = function(context, elem) {
            // Set document vars if needed
            if ((context.ownerDocument || context) !== document) {
                setDocument(context);
            }
            return contains(context, elem);
        }
        ;

        Sizzle.attr = function(elem, name) {
            // Set document vars if needed
            if ((elem.ownerDocument || elem) !== document) {
                setDocument(elem);
            }

            var fn = Expr.attrHandle[name.toLowerCase()]
              , // Don't get fooled by Object.prototype properties (jQuery #13807)
            val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;

            return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
        ;

        Sizzle.error = function(msg) {
            throw new Error("Syntax error, unrecognized expression: " + msg);
        }
        ;

        /**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
        Sizzle.uniqueSort = function(results) {
            var elem, duplicates = [], j = 0, i = 0;

            // Unless we *know* we can detect duplicates, assume their presence
            hasDuplicate = !support.detectDuplicates;
            sortInput = !support.sortStable && results.slice(0);
            results.sort(sortOrder);

            if (hasDuplicate) {
                while ((elem = results[i++])) {
                    if (elem === results[i]) {
                        j = duplicates.push(i);
                    }
                }
                while (j--) {
                    results.splice(duplicates[j], 1);
                }
            }

            // Clear input after sorting to release objects
            // See https://github.com/jquery/sizzle/pull/225
            sortInput = null;

            return results;
        }
        ;

        /**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
        getText = Sizzle.getText = function(elem) {
            var node, ret = "", i = 0, nodeType = elem.nodeType;

            if (!nodeType) {
                // If no nodeType, this is expected to be an array
                while ((node = elem[i++])) {
                    // Do not traverse comment nodes
                    ret += getText(node);
                }
            } else if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
                // Use textContent for elements
                // innerText usage removed for consistency of new lines (jQuery #11153)
                if (typeof elem.textContent === "string") {
                    return elem.textContent;
                } else {
                    // Traverse its children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        ret += getText(elem);
                    }
                }
            } else if (nodeType === 3 || nodeType === 4) {
                return elem.nodeValue;
            }
            // Do not include comment or processing instruction nodes

            return ret;
        }
        ;

        Expr = Sizzle.selectors = {

            // Can be adjusted by the user
            cacheLength: 50,

            createPseudo: markFunction,

            match: matchExpr,

            attrHandle: {},

            find: {},

            relative: {
                ">": {
                    dir: "parentNode",
                    first: true
                },
                " ": {
                    dir: "parentNode"
                },
                "+": {
                    dir: "previousSibling",
                    first: true
                },
                "~": {
                    dir: "previousSibling"
                }
            },

            preFilter: {
                "ATTR": function(match) {
                    match[1] = match[1].replace(runescape, funescape);

                    // Move the given value to match[3] whether quoted or unquoted
                    match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape);

                    if (match[2] === "~=") {
                        match[3] = " " + match[3] + " ";
                    }

                    return match.slice(0, 4);
                },

                "CHILD": function(match) {
                    /* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
                    match[1] = match[1].toLowerCase();

                    if (match[1].slice(0, 3) === "nth") {
                        // nth-* requires argument
                        if (!match[3]) {
                            Sizzle.error(match[0]);
                        }

                        // numeric x and y parameters for Expr.filter.CHILD
                        // remember that false/true cast respectively to 0/1
                        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === "even" || match[3] === "odd"));
                        match[5] = +((match[7] + match[8]) || match[3] === "odd");

                        // other types prohibit arguments
                    } else if (match[3]) {
                        Sizzle.error(match[0]);
                    }

                    return match;
                },

                "PSEUDO": function(match) {
                    var excess, unquoted = !match[6] && match[2];

                    if (matchExpr["CHILD"].test(match[0])) {
                        return null;
                    }

                    // Accept quoted arguments as-is
                    if (match[3]) {
                        match[2] = match[4] || match[5] || "";

                        // Strip excess characters from unquoted arguments
                    } else if (unquoted && rpseudo.test(unquoted) && // Get excess from tokenize (recursively)
                    (excess = tokenize(unquoted, true)) && // advance to the next closing parenthesis
                    (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length)) {

                        // excess is a negative index
                        match[0] = match[0].slice(0, excess);
                        match[2] = unquoted.slice(0, excess);
                    }

                    // Return only captures needed by the pseudo filter method (type and argument)
                    return match.slice(0, 3);
                }
            },

            filter: {

                "TAG": function(nodeNameSelector) {
                    var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                    return nodeNameSelector === "*" ? function() {
                        return true;
                    }
                    : function(elem) {
                        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
                    }
                    ;
                },

                "CLASS": function(className) {
                    var pattern = classCache[className + " "];

                    return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function(elem) {
                        return pattern.test(typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "");
                    });
                },

                "ATTR": function(name, operator, check) {
                    return function(elem) {
                        var result = Sizzle.attr(elem, name);

                        if (result == null) {
                            return operator === "!=";
                        }
                        if (!operator) {
                            return true;
                        }

                        result += "";

                        return operator === "=" ? result === check : operator === "!=" ? result !== check : operator === "^=" ? check && result.indexOf(check) === 0 : operator === "*=" ? check && result.indexOf(check) > -1 : operator === "$=" ? check && result.slice(-check.length) === check : operator === "~=" ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : operator === "|=" ? result === check || result.slice(0, check.length + 1) === check + "-" : false;
                    }
                    ;
                },

                "CHILD": function(type, what, argument, first, last) {
                    var simple = type.slice(0, 3) !== "nth"
                      , forward = type.slice(-4) !== "last"
                      , ofType = what === "of-type";

                    return first === 1 && last === 0 ?
                    // Shortcut for :nth-*(n)
                    function(elem) {
                        return !!elem.parentNode;
                    }
                    :
                    function(elem, context, xml) {
                        var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = false;

                        if (parent) {

                            // :(first|last|only)-(child|of-type)
                            if (simple) {
                                while (dir) {
                                    node = elem;
                                    while ((node = node[dir])) {
                                        if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {

                                            return false;
                                        }
                                    }
                                    // Reverse direction for :only-* (if we haven't yet done so)
                                    start = dir = type === "only" && !start && "nextSibling";
                                }
                                return true;
                            }

                            start = [forward ? parent.firstChild : parent.lastChild];

                            // non-xml :nth-child(...) stores cache data on `parent`
                            if (forward && useCache) {

                                // Seek `elem` from a previously-cached index

                                // ...in a gzip-friendly way
                                node = parent;
                                outerCache = node[expando] || (node[expando] = {});

                                // Support: IE <9 only
                                // Defend against cloned attroperties (jQuery gh-1709)
                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

                                cache = uniqueCache[type] || [];
                                nodeIndex = cache[0] === dirruns && cache[1];
                                diff = nodeIndex && cache[2];
                                node = nodeIndex && parent.childNodes[nodeIndex];

                                while ((node = ++nodeIndex && node && node[dir] ||
                                // Fallback to seeking `elem` from the start
                                (diff = nodeIndex = 0) || start.pop())) {

                                    // When found, cache indexes on `parent` and break
                                    if (node.nodeType === 1 && ++diff && node === elem) {
                                        uniqueCache[type] = [dirruns, nodeIndex, diff];
                                        break;
                                    }
                                }

                            } else {
                                // Use previously-cached element index if available
                                if (useCache) {
                                    // ...in a gzip-friendly way
                                    node = elem;
                                    outerCache = node[expando] || (node[expando] = {});

                                    // Support: IE <9 only
                                    // Defend against cloned attroperties (jQuery gh-1709)
                                    uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

                                    cache = uniqueCache[type] || [];
                                    nodeIndex = cache[0] === dirruns && cache[1];
                                    diff = nodeIndex;
                                }

                                // xml :nth-child(...)
                                // or :nth-last-child(...) or :nth(-last)?-of-type(...)
                                if (diff === false) {
                                    // Use the same loop as above to seek `elem` from the start
                                    while ((node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop())) {

                                        if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {

                                            // Cache the index of each encountered element
                                            if (useCache) {
                                                outerCache = node[expando] || (node[expando] = {});

                                                // Support: IE <9 only
                                                // Defend against cloned attroperties (jQuery gh-1709)
                                                uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {});

                                                uniqueCache[type] = [dirruns, diff];
                                            }

                                            if (node === elem) {
                                                break;
                                            }
                                        }
                                    }
                                }
                            }

                            // Incorporate the offset, then check against cycle size
                            diff -= last;
                            return diff === first || (diff % first === 0 && diff / first >= 0);
                        }
                    }
                    ;
                },

                "PSEUDO": function(pseudo, argument) {
                    // pseudo-class names are case-insensitive
                    // http://www.w3.org/TR/selectors/#pseudo-classes
                    // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
                    // Remember that setFilters inherits from pseudos
                    var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);

                    // The user may use createPseudo to indicate that
                    // arguments are needed to create the filter function
                    // just as Sizzle does
                    if (fn[expando]) {
                        return fn(argument);
                    }

                    // But maintain support for old signatures
                    if (fn.length > 1) {
                        args = [pseudo, pseudo, "", argument];
                        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
                            var idx, matched = fn(seed, argument), i = matched.length;
                            while (i--) {
                                idx = indexOf(seed, matched[i]);
                                seed[idx] = !(matches[idx] = matched[i]);
                            }
                        }) : function(elem) {
                            return fn(elem, 0, args);
                        }
                        ;
                    }

                    return fn;
                }
            },

            pseudos: {
                // Potentially complex pseudos
                "not": markFunction(function(selector) {
                    // Trim the selector passed to compile
                    // to avoid treating leading and trailing
                    // spaces as combinators
                    var input = []
                      , results = []
                      , matcher = compile(selector.replace(rtrim, "$1"));

                    return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
                        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;

                        // Match elements unmatched by `matcher`
                        while (i--) {
                            if ((elem = unmatched[i])) {
                                seed[i] = !(matches[i] = elem);
                            }
                        }
                    }) : function(elem, context, xml) {
                        input[0] = elem;
                        matcher(input, null, xml, results);
                        // Don't keep the element (issue #299)
                        input[0] = null;
                        return !results.pop();
                    }
                    ;
                }),

                "has": markFunction(function(selector) {
                    return function(elem) {
                        return Sizzle(selector, elem).length > 0;
                    }
                    ;
                }),

                "contains": markFunction(function(text) {
                    text = text.replace(runescape, funescape);
                    return function(elem) {
                        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
                    }
                    ;
                }),

                // "Whether an element is represented by a :lang() selector
                // is based solely on the element's language value
                // being equal to the identifier C,
                // or beginning with the identifier C immediately followed by "-".
                // The matching of C against the element's language value is performed case-insensitively.
                // The identifier C does not have to be a valid language name."
                // http://www.w3.org/TR/selectors/#lang-pseudo
                "lang": markFunction(function(lang) {
                    // lang value must be a valid identifier
                    if (!ridentifier.test(lang || "")) {
                        Sizzle.error("unsupported lang: " + lang);
                    }
                    lang = lang.replace(runescape, funescape).toLowerCase();
                    return function(elem) {
                        var elemLang;
                        do {
                            if ((elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))) {

                                elemLang = elemLang.toLowerCase();
                                return elemLang === lang || elemLang.indexOf(lang + "-") === 0;
                            }
                        } while ((elem = elem.parentNode) && elem.nodeType === 1);return false;
                    }
                    ;
                }),

                // Miscellaneous
                "target": function(elem) {
                    var hash = window.location && window.location.hash;
                    return hash && hash.slice(1) === elem.id;
                },

                "root": function(elem) {
                    return elem === docElem;
                },

                "focus": function(elem) {
                    return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
                },

                // Boolean properties
                "enabled": function(elem) {
                    return elem.disabled === false;
                },

                "disabled": function(elem) {
                    return elem.disabled === true;
                },

                "checked": function(elem) {
                    // In CSS3, :checked should return both checked and selected elements
                    // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
                    var nodeName = elem.nodeName.toLowerCase();
                    return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
                },

                "selected": function(elem) {
                    // Accessing this property makes selected-by-default
                    // options in Safari work properly
                    if (elem.parentNode) {
                        elem.parentNode.selectedIndex;
                    }

                    return elem.selected === true;
                },

                // Contents
                "empty": function(elem) {
                    // http://www.w3.org/TR/selectors/#empty-pseudo
                    // :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
                    //   but not by others (comment: 8; processing instruction: 7; etc.)
                    // nodeType < 6 works because attributes (2) do not appear as children
                    for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
                        if (elem.nodeType < 6) {
                            return false;
                        }
                    }
                    return true;
                },

                "parent": function(elem) {
                    return !Expr.pseudos["empty"](elem);
                },

                // Element/input types
                "header": function(elem) {
                    return rheader.test(elem.nodeName);
                },

                "input": function(elem) {
                    return rinputs.test(elem.nodeName);
                },

                "button": function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return name === "input" && elem.type === "button" || name === "button";
                },

                "text": function(elem) {
                    var attr;
                    return elem.nodeName.toLowerCase() === "input" && elem.type === "text" &&
                    // Support: IE<8
                    // New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
                    ((attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text");
                },

                // Position-in-collection
                "first": createPositionalPseudo(function() {
                    return [0];
                }),

                "last": createPositionalPseudo(function(matchIndexes, length) {
                    return [length - 1];
                }),

                "eq": createPositionalPseudo(function(matchIndexes, length, argument) {
                    return [argument < 0 ? argument + length : argument];
                }),

                "even": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 0;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "odd": createPositionalPseudo(function(matchIndexes, length) {
                    var i = 1;
                    for (; i < length; i += 2) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "lt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; --i >= 0; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                }),

                "gt": createPositionalPseudo(function(matchIndexes, length, argument) {
                    var i = argument < 0 ? argument + length : argument;
                    for (; ++i < length; ) {
                        matchIndexes.push(i);
                    }
                    return matchIndexes;
                })
            }
        };

        Expr.pseudos["nth"] = Expr.pseudos["eq"];

        // Add button/input type pseudos
        for (i in {
            radio: true,
            checkbox: true,
            file: true,
            password: true,
            image: true
        }) {
            Expr.pseudos[i] = createInputPseudo(i);
        }
        for (i in {
            submit: true,
            reset: true
        }) {
            Expr.pseudos[i] = createButtonPseudo(i);
        }

        // Easy API for creating new setFilters
        function setFilters() {}
        setFilters.prototype = Expr.filters = Expr.pseudos;
        Expr.setFilters = new setFilters();

        tokenize = Sizzle.tokenize = function(selector, parseOnly) {
            var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];

            if (cached) {
                return parseOnly ? 0 : cached.slice(0);
            }

            soFar = selector;
            groups = [];
            preFilters = Expr.preFilter;

            while (soFar) {

                // Comma and first run
                if (!matched || (match = rcomma.exec(soFar))) {
                    if (match) {
                        // Don't consume trailing commas as valid
                        soFar = soFar.slice(match[0].length) || soFar;
                    }
                    groups.push((tokens = []));
                }

                matched = false;

                // Combinators
                if ((match = rcombinators.exec(soFar))) {
                    matched = match.shift();
                    tokens.push({
                        value: matched,
                        // Cast descendant combinators to space
                        type: match[0].replace(rtrim, " ")
                    });
                    soFar = soFar.slice(matched.length);
                }

                // Filters
                for (type in Expr.filter) {
                    if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
                        matched = match.shift();
                        tokens.push({
                            value: matched,
                            type: type,
                            matches: match
                        });
                        soFar = soFar.slice(matched.length);
                    }
                }

                if (!matched) {
                    break;
                }
            }

            // Return the length of the invalid excess
            // if we're just parsing
            // Otherwise, throw an error or return tokens
            return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : // Cache the tokens
            tokenCache(selector, groups).slice(0);
        }
        ;

        function toSelector(tokens) {
            var i = 0
              , len = tokens.length
              , selector = "";
            for (; i < len; i++) {
                selector += tokens[i].value;
            }
            return selector;
        }

        function addCombinator(matcher, combinator, base) {
            var dir = combinator.dir
              , checkNonElements = base && dir === "parentNode"
              , doneName = done++;

            return combinator.first ? // Check against closest ancestor/preceding element
            function(elem, context, xml) {
                while ((elem = elem[dir])) {
                    if (elem.nodeType === 1 || checkNonElements) {
                        return matcher(elem, context, xml);
                    }
                }
            }
            :
            // Check against all ancestor/preceding elements
            function(elem, context, xml) {
                var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];

                // We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
                if (xml) {
                    while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            if (matcher(elem, context, xml)) {
                                return true;
                            }
                        }
                    }
                } else {
                    while ((elem = elem[dir])) {
                        if (elem.nodeType === 1 || checkNonElements) {
                            outerCache = elem[expando] || (elem[expando] = {});

                            // Support: IE <9 only
                            // Defend against cloned attroperties (jQuery gh-1709)
                            uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {});

                            if ((oldCache = uniqueCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {

                                // Assign to newCache so results back-propagate to previous elements
                                return (newCache[2] = oldCache[2]);
                            } else {
                                // Reuse newcache so results back-propagate to previous elements
                                uniqueCache[dir] = newCache;

                                // A match means we're done; a fail means we have to keep checking
                                if ((newCache[2] = matcher(elem, context, xml))) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }
            ;
        }

        function elementMatcher(matchers) {
            return matchers.length > 1 ? function(elem, context, xml) {
                var i = matchers.length;
                while (i--) {
                    if (!matchers[i](elem, context, xml)) {
                        return false;
                    }
                }
                return true;
            }
            : matchers[0];
        }

        function multipleContexts(selector, contexts, results) {
            var i = 0
              , len = contexts.length;
            for (; i < len; i++) {
                Sizzle(selector, contexts[i], results);
            }
            return results;
        }

        function condense(unmatched, map, filter, context, xml) {
            var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;

            for (; i < len; i++) {
                if ((elem = unmatched[i])) {
                    if (!filter || filter(elem, context, xml)) {
                        newUnmatched.push(elem);
                        if (mapped) {
                            map.push(i);
                        }
                    }
                }
            }

            return newUnmatched;
        }

        function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
            if (postFilter && !postFilter[expando]) {
                postFilter = setMatcher(postFilter);
            }
            if (postFinder && !postFinder[expando]) {
                postFinder = setMatcher(postFinder, postSelector);
            }
            return markFunction(function(seed, results, context, xml) {
                var temp, i, elem, preMap = [], postMap = [], preexisting = results.length,
                // Get initial elements from seed or context
                elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []),
                // Prefilter to get matcher input, preserving a map for seed-results synchronization
                matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems,
                matcherOut = matcher ? // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
                postFinder || (seed ? preFilter : preexisting || postFilter) ?
                // ...intermediate processing is necessary
                [] :
                // ...otherwise use results directly
                results : matcherIn;

                // Find primary matches
                if (matcher) {
                    matcher(matcherIn, matcherOut, context, xml);
                }

                // Apply postFilter
                if (postFilter) {
                    temp = condense(matcherOut, postMap);
                    postFilter(temp, [], context, xml);

                    // Un-match failing elements by moving them back to matcherIn
                    i = temp.length;
                    while (i--) {
                        if ((elem = temp[i])) {
                            matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
                        }
                    }
                }

                if (seed) {
                    if (postFinder || preFilter) {
                        if (postFinder) {
                            // Get the final matcherOut by condensing this intermediate into postFinder contexts
                            temp = [];
                            i = matcherOut.length;
                            while (i--) {
                                if ((elem = matcherOut[i])) {
                                    // Restore matcherIn since elem is not yet a final match
                                    temp.push((matcherIn[i] = elem));
                                }
                            }
                            postFinder(null, (matcherOut = []), temp, xml);
                        }

                        // Move matched elements from seed to results to keep them synchronized
                        i = matcherOut.length;
                        while (i--) {
                            if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1) {

                                seed[temp] = !(results[temp] = elem);
                            }
                        }
                    }

                    // Add elements to results, through postFinder if defined
                } else {
                    matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
                    if (postFinder) {
                        postFinder(null, results, matcherOut, xml);
                    } else {
                        push.apply(results, matcherOut);
                    }
                }
            });
        }

        function matcherFromTokens(tokens) {
            var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0,
            // The foundational matcher ensures that elements are reachable from top-level context(s)
            matchContext = addCombinator(function(elem) {
                return elem === checkContext;
            }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
                return indexOf(checkContext, elem) > -1;
            }, implicitRelative, true), matchers = [function(elem, context, xml) {
                var ret = (!leadingRelative && (xml || context !== outermostContext)) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                // Avoid hanging onto element (issue #299)
                checkContext = null;
                return ret;
            }
            ];

            for (; i < len; i++) {
                if ((matcher = Expr.relative[tokens[i].type])) {
                    matchers = [addCombinator(elementMatcher(matchers), matcher)];
                } else {
                    matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);

                    // Return special upon seeing a positional matcher
                    if (matcher[expando]) {
                        // Find the next relative operator (if any) for proper handling
                        j = ++i;
                        for (; j < len; j++) {
                            if (Expr.relative[tokens[j].type]) {
                                break;
                            }
                        }
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(// If the preceding token was a descendant combinator, insert an implicit any-element `*`
                        tokens.slice(0, i - 1).concat({
                            value: tokens[i - 2].type === " " ? "*" : ""
                        })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens((tokens = tokens.slice(j))), j < len && toSelector(tokens));
                    }
                    matchers.push(matcher);
                }
            }

            return elementMatcher(matchers);
        }

        function matcherFromGroupMatchers(elementMatchers, setMatchers) {
            var bySet = setMatchers.length > 0
              , byElement = elementMatchers.length > 0
              , superMatcher = function(seed, context, xml, results, outermost) {
                var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, // We must always have either seed elements or outermost context
                elems = seed || byElement && Expr.find["TAG"]("*", outermost), // Use integer dirruns iff this is the outermost matcher
                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1), len = elems.length;

                if (outermost) {
                    outermostContext = context === document || context || outermost;
                }

                // Add elements passing elementMatchers directly to results
                // Support: IE<9, Safari
                // Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
                for (; i !== len && (elem = elems[i]) != null; i++) {
                    if (byElement && elem) {
                        j = 0;
                        if (!context && elem.ownerDocument !== document) {
                            setDocument(elem);
                            xml = !documentIsHTML;
                        }
                        while ((matcher = elementMatchers[j++])) {
                            if (matcher(elem, context || document, xml)) {
                                results.push(elem);
                                break;
                            }
                        }
                        if (outermost) {
                            dirruns = dirrunsUnique;
                        }
                    }

                    // Track unmatched elements for set filters
                    if (bySet) {
                        // They will have gone through all possible matchers
                        if ((elem = !matcher && elem)) {
                            matchedCount--;
                        }

                        // Lengthen the array for every element, matched or not
                        if (seed) {
                            unmatched.push(elem);
                        }
                    }
                }

                // `i` is now the count of elements visited above, and adding it to `matchedCount`
                // makes the latter nonnegative.
                matchedCount += i;

                // Apply set filters to unmatched elements
                // NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
                // equals `i`), unless we didn't visit _any_ elements in the above loop because we have
                // no element matchers and no seed.
                // Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
                // case, which will result in a "00" `matchedCount` that differs from `i` but is also
                // numerically zero.
                if (bySet && i !== matchedCount) {
                    j = 0;
                    while ((matcher = setMatchers[j++])) {
                        matcher(unmatched, setMatched, context, xml);
                    }

                    if (seed) {
                        // Reintegrate element matches to eliminate the need for sorting
                        if (matchedCount > 0) {
                            while (i--) {
                                if (!(unmatched[i] || setMatched[i])) {
                                    setMatched[i] = pop.call(results);
                                }
                            }
                        }

                        // Discard index placeholder values to get only actual matches
                        setMatched = condense(setMatched);
                    }

                    // Add matches to results
                    push.apply(results, setMatched);

                    // Seedless set matches succeeding multiple successful matchers stipulate sorting
                    if (outermost && !seed && setMatched.length > 0 && (matchedCount + setMatchers.length) > 1) {

                        Sizzle.uniqueSort(results);
                    }
                }

                // Override manipulation of globals by nested matchers
                if (outermost) {
                    dirruns = dirrunsUnique;
                    outermostContext = contextBackup;
                }

                return unmatched;
            };

            return bySet ? markFunction(superMatcher) : superMatcher;
        }

        compile = Sizzle.compile = function(selector, match /* Internal Use Only */
        ) {
            var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];

            if (!cached) {
                // Generate a function of recursive functions that can be used to check each element
                if (!match) {
                    match = tokenize(selector);
                }
                i = match.length;
                while (i--) {
                    cached = matcherFromTokens(match[i]);
                    if (cached[expando]) {
                        setMatchers.push(cached);
                    } else {
                        elementMatchers.push(cached);
                    }
                }

                // Cache the compiled function
                cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));

                // Save selector and tokenization
                cached.selector = selector;
            }
            return cached;
        }
        ;

        /**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
        select = Sizzle.select = function(selector, context, results, seed) {
            var i, tokens, token, type, find, compiled = typeof selector === "function" && selector, match = !seed && tokenize((selector = compiled.selector || selector));

            results = results || [];

            // Try to minimize operations if there is only one selector in the list and no seed
            // (the latter of which guarantees us context)
            if (match.length === 1) {

                // Reduce context if the leading compound selector is an ID
                tokens = match[0] = match[0].slice(0);
                if (tokens.length > 2 && (token = tokens[0]).type === "ID" && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {

                    context = (Expr.find["ID"](token.matches[0].replace(runescape, funescape), context) || [])[0];
                    if (!context) {
                        return results;

                        // Precompiled matchers will still verify ancestry, so step up a level
                    } else if (compiled) {
                        context = context.parentNode;
                    }

                    selector = selector.slice(tokens.shift().value.length);
                }

                // Fetch a seed set for right-to-left matching
                i = matchExpr["needsContext"].test(selector) ? 0 : tokens.length;
                while (i--) {
                    token = tokens[i];

                    // Abort if we hit a combinator
                    if (Expr.relative[(type = token.type)]) {
                        break;
                    }
                    if ((find = Expr.find[type])) {
                        // Search, expanding context for leading sibling combinators
                        if ((seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {

                            // If seed is empty or no tokens remain, we can return early
                            tokens.splice(i, 1);
                            selector = seed.length && toSelector(tokens);
                            if (!selector) {
                                push.apply(results, seed);
                                return results;
                            }

                            break;
                        }
                    }
                }
            }

            // Compile and execute a filtering function if one is not provided
            // Provide `match` to avoid retokenization if we modified the selector above
            (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context);
            return results;
        }
        ;

        // One-time assignments

        // Sort stability
        support.sortStable = expando.split("").sort(sortOrder).join("") === expando;

        // Support: Chrome 14-35+
        // Always assume duplicates if they aren't passed to the comparison function
        support.detectDuplicates = !!hasDuplicate;

        // Initialize against the default document
        setDocument();

        // Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
        // Detached nodes confoundingly follow *each other*
        support.sortDetached = assert(function(div1) {
            // Should return 1, but returns 4 (following)
            return div1.compareDocumentPosition(document.createElement("div")) & 1;
        });

        // Support: IE<8
        // Prevent attribute/property "interpolation"
        // http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
        if (!assert(function(div) {
            div.innerHTML = "<a href='#'></a>";
            return div.firstChild.getAttribute("href") === "#";
        })) {
            addHandle("type|href|height|width", function(elem, name, isXML) {
                if (!isXML) {
                    return elem.getAttribute(name, name.toLowerCase() === "type" ? 1 : 2);
                }
            });
        }

        // Support: IE<9
        // Use defaultValue in place of getAttribute("value")
        if (!support.attributes || !assert(function(div) {
            div.innerHTML = "<input/>";
            div.firstChild.setAttribute("value", "");
            return div.firstChild.getAttribute("value") === "";
        })) {
            addHandle("value", function(elem, name, isXML) {
                if (!isXML && elem.nodeName.toLowerCase() === "input") {
                    return elem.defaultValue;
                }
            });
        }

        // Support: IE<9
        // Use getAttributeNode to fetch booleans when getAttribute lies
        if (!assert(function(div) {
            return div.getAttribute("disabled") == null;
        })) {
            addHandle(booleans, function(elem, name, isXML) {
                var val;
                if (!isXML) {
                    return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
                }
            });
        }

        return Sizzle;

    }
    )(window);

    jQuery.find = Sizzle;
    jQuery.expr = Sizzle.selectors;
    jQuery.expr[":"] = jQuery.expr.pseudos;
    jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
    jQuery.text = Sizzle.getText;
    jQuery.isXMLDoc = Sizzle.isXML;
    jQuery.contains = Sizzle.contains;

    var dir = function(elem, dir, until) {
        var matched = []
          , truncate = until !== undefined;

        while ((elem = elem[dir]) && elem.nodeType !== 9) {
            if (elem.nodeType === 1) {
                if (truncate && jQuery(elem).is(until)) {
                    break;
                }
                matched.push(elem);
            }
        }
        return matched;
    };

    var siblings = function(n, elem) {
        var matched = [];

        for (; n; n = n.nextSibling) {
            if (n.nodeType === 1 && n !== elem) {
                matched.push(n);
            }
        }

        return matched;
    };

    var rneedsContext = jQuery.expr.match.needsContext;

    var rsingleTag = (/^<([\w-]+)\s*\/?>(?:<\/\1>|)$/);

    var risSimple = /^.[^:#\[\.,]*$/;

    // Implement the identical functionality for filter and not
    function winnow(elements, qualifier, not) {
        if (jQuery.isFunction(qualifier)) {
            return jQuery.grep(elements, function(elem, i) {
                /* jshint -W018 */
                return !!qualifier.call(elem, i, elem) !== not;
            });

        }

        if (qualifier.nodeType) {
            return jQuery.grep(elements, function(elem) {
                return (elem === qualifier) !== not;
            });

        }

        if (typeof qualifier === "string") {
            if (risSimple.test(qualifier)) {
                return jQuery.filter(qualifier, elements, not);
            }

            qualifier = jQuery.filter(qualifier, elements);
        }

        return jQuery.grep(elements, function(elem) {
            return (indexOf.call(qualifier, elem) > -1) !== not;
        });
    }

    jQuery.filter = function(expr, elems, not) {
        var elem = elems[0];

        if (not) {
            expr = ":not(" + expr + ")";
        }

        return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
            return elem.nodeType === 1;
        }));
    }
    ;

    jQuery.fn.extend({
        find: function(selector) {
            var i, len = this.length, ret = [], self = this;

            if (typeof selector !== "string") {
                return this.pushStack(jQuery(selector).filter(function() {
                    for (i = 0; i < len; i++) {
                        if (jQuery.contains(self[i], this)) {
                            return true;
                        }
                    }
                }));
            }

            for (i = 0; i < len; i++) {
                jQuery.find(selector, self[i], ret);
            }

            // Needed because $( selector, context ) becomes $( context ).find( selector )
            ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
            ret.selector = this.selector ? this.selector + " " + selector : selector;
            return ret;
        },
        filter: function(selector) {
            return this.pushStack(winnow(this, selector || [], false));
        },
        not: function(selector) {
            return this.pushStack(winnow(this, selector || [], true));
        },
        is: function(selector) {
            return !!winnow(this,
            // If this is a positional/relative selector, check membership in the returned set
            // so $("p:first").is("p:last") won't return true for a doc with two "p".
            typeof selector === "string" && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
        }
    });

    // Initialize a jQuery object

    // A central reference to the root jQuery(document)
    var rootjQuery,
    // A simple way to check for HTML strings
    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
    // Strict HTML recognition (#11290: must start with <)
    rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,
    init = jQuery.fn.init = function(selector, context, root) {
        var match, elem;

        // HANDLE: $(""), $(null), $(undefined), $(false)
        if (!selector) {
            return this;
        }

        // Method init() accepts an alternate rootjQuery
        // so migrate can support jQuery.sub (gh-2101)
        root = root || rootjQuery;

        // Handle HTML strings
        if (typeof selector === "string") {
            if (selector[0] === "<" && selector[selector.length - 1] === ">" && selector.length >= 3) {

                // Assume that strings that start and end with <> are HTML and skip the regex check
                match = [null, selector, null];

            } else {
                match = rquickExpr.exec(selector);
            }

            // Match html or make sure no context is specified for #id
            if (match && (match[1] || !context)) {

                // HANDLE: $(html) -> $(array)
                if (match[1]) {
                    context = context instanceof jQuery ? context[0] : context;

                    // Option to run scripts is true for back-compat
                    // Intentionally let the error be thrown if parseHTML is not present
                    jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));

                    // HANDLE: $(html, props)
                    if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
                        for (match in context) {

                            // Properties of context are called as methods if possible
                            if (jQuery.isFunction(this[match])) {
                                this[match](context[match]);

                                // ...and otherwise set as attributes
                            } else {
                                this.attr(match, context[match]);
                            }
                        }
                    }

                    return this;

                    // HANDLE: $(#id)
                } else {
                    elem = document.getElementById(match[2]);

                    // Support: Blackberry 4.6
                    // gEBID returns nodes no longer in the document (#6963)
                    if (elem && elem.parentNode) {

                        // Inject the element directly into the jQuery object
                        this.length = 1;
                        this[0] = elem;
                    }

                    this.context = document;
                    this.selector = selector;
                    return this;
                }

                // HANDLE: $(expr, $(...))
            } else if (!context || context.jquery) {
                return (context || root).find(selector);

                // HANDLE: $(expr, context)
                // (which is just equivalent to: $(context).find(expr)
            } else {
                return this.constructor(context).find(selector);
            }

            // HANDLE: $(DOMElement)
        } else if (selector.nodeType) {
            this.context = this[0] = selector;
            this.length = 1;
            return this;

            // HANDLE: $(function)
            // Shortcut for document ready
        } else if (jQuery.isFunction(selector)) {
            return root.ready !== undefined ? root.ready(selector) :
            // Execute immediately if ready is not present
            selector(jQuery);
        }

        if (selector.selector !== undefined) {
            this.selector = selector.selector;
            this.context = selector.context;
        }

        return jQuery.makeArray(selector, this);
    }
    ;

    // Give the init function the jQuery prototype for later instantiation
    init.prototype = jQuery.fn;

    // Initialize central reference
    rootjQuery = jQuery(document);

    var rparentsprev = /^(?:parents|prev(?:Until|All))/
      ,
    // Methods guaranteed to produce a unique set when starting from a unique set
    guaranteedUnique = {
        children: true,
        contents: true,
        next: true,
        prev: true
    };

    jQuery.fn.extend({
        has: function(target) {
            var targets = jQuery(target, this)
              , l = targets.length;

            return this.filter(function() {
                var i = 0;
                for (; i < l; i++) {
                    if (jQuery.contains(this, targets[i])) {
                        return true;
                    }
                }
            });
        },

        closest: function(selectors, context) {
            var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== "string" ? jQuery(selectors, context || this.context) : 0;

            for (; i < l; i++) {
                for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {

                    // Always skip document fragments
                    if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 :
                    // Don't pass non-elements to Sizzle
                    cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {

                        matched.push(cur);
                        break;
                    }
                }
            }

            return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched);
        },

        // Determine the position of an element within the set
        index: function(elem) {

            // No argument, return index in parent
            if (!elem) {
                return (this[0] && this[0].parentNode) ? this.first().prevAll().length : -1;
            }

            // Index in selector
            if (typeof elem === "string") {
                return indexOf.call(jQuery(elem), this[0]);
            }

            // Locate the position of the desired element
            return indexOf.call(this,
            // If it receives a jQuery object, the first element is used
            elem.jquery ? elem[0] : elem);
        },

        add: function(selector, context) {
            return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))));
        },

        addBack: function(selector) {
            return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
        }
    });

    function sibling(cur, dir) {
        while ((cur = cur[dir]) && cur.nodeType !== 1) {}
        return cur;
    }

    jQuery.each({
        parent: function(elem) {
            var parent = elem.parentNode;
            return parent && parent.nodeType !== 11 ? parent : null;
        },
        parents: function(elem) {
            return dir(elem, "parentNode");
        },
        parentsUntil: function(elem, i, until) {
            return dir(elem, "parentNode", until);
        },
        next: function(elem) {
            return sibling(elem, "nextSibling");
        },
        prev: function(elem) {
            return sibling(elem, "previousSibling");
        },
        nextAll: function(elem) {
            return dir(elem, "nextSibling");
        },
        prevAll: function(elem) {
            return dir(elem, "previousSibling");
        },
        nextUntil: function(elem, i, until) {
            return dir(elem, "nextSibling", until);
        },
        prevUntil: function(elem, i, until) {
            return dir(elem, "previousSibling", until);
        },
        siblings: function(elem) {
            return siblings((elem.parentNode || {}).firstChild, elem);
        },
        children: function(elem) {
            return siblings(elem.firstChild);
        },
        contents: function(elem) {
            return elem.contentDocument || jQuery.merge([], elem.childNodes);
        }
    }, function(name, fn) {
        jQuery.fn[name] = function(until, selector) {
            var matched = jQuery.map(this, fn, until);

            if (name.slice(-5) !== "Until") {
                selector = until;
            }

            if (selector && typeof selector === "string") {
                matched = jQuery.filter(selector, matched);
            }

            if (this.length > 1) {

                // Remove duplicates
                if (!guaranteedUnique[name]) {
                    jQuery.uniqueSort(matched);
                }

                // Reverse order for parents* and prev-derivatives
                if (rparentsprev.test(name)) {
                    matched.reverse();
                }
            }

            return this.pushStack(matched);
        }
        ;
    });
    var rnotwhite = (/\S+/g);

    // Convert String-formatted options into Object-formatted ones
    function createOptions(options) {
        var object = {};
        jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
            object[flag] = true;
        });
        return object;
    }

    /*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
    jQuery.Callbacks = function(options) {

        // Convert options from String-formatted to Object-formatted if needed
        // (we check in cache first)
        options = typeof options === "string" ? createOptions(options) : jQuery.extend({}, options);

        var // Flag to know if list is currently firing
        firing,
        // Last fire value for non-forgettable lists
        memory,
        // Flag to know if list was already fired
        fired,
        // Flag to prevent firing
        locked,
        // Actual callback list
        list = [],
        // Queue of execution data for repeatable lists
        queue = [],
        // Index of currently firing callback (modified by add/remove as needed)
        firingIndex = -1,
        // Fire callbacks
        fire = function() {

            // Enforce single-firing
            locked = options.once;

            // Execute callbacks for all pending executions,
            // respecting firingIndex overrides and runtime changes
            fired = firing = true;
            for (; queue.length; firingIndex = -1) {
                memory = queue.shift();
                while (++firingIndex < list.length) {

                    // Run callback and check for early termination
                    if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {

                        // Jump to end and forget the data so .add doesn't re-fire
                        firingIndex = list.length;
                        memory = false;
                    }
                }
            }

            // Forget the data if we're done with it
            if (!options.memory) {
                memory = false;
            }

            firing = false;

            // Clean up if we're done firing for good
            if (locked) {

                // Keep an empty list if we have data for future add calls
                if (memory) {
                    list = [];

                    // Otherwise, this object is spent
                } else {
                    list = "";
                }
            }
        },
        // Actual Callbacks object
        self = {

            // Add a callback or a collection of callbacks to the list
            add: function() {
                if (list) {

                    // If we have memory from a past run, we should fire after adding
                    if (memory && !firing) {
                        firingIndex = list.length - 1;
                        queue.push(memory);
                    }

                    (function add(args) {
                        jQuery.each(args, function(_, arg) {
                            if (jQuery.isFunction(arg)) {
                                if (!options.unique || !self.has(arg)) {
                                    list.push(arg);
                                }
                            } else if (arg && arg.length && jQuery.type(arg) !== "string") {

                                // Inspect recursively
                                add(arg);
                            }
                        });
                    }
                    )(arguments);

                    if (memory && !firing) {
                        fire();
                    }
                }
                return this;
            },

            // Remove a callback from the list
            remove: function() {
                jQuery.each(arguments, function(_, arg) {
                    var index;
                    while ((index = jQuery.inArray(arg, list, index)) > -1) {
                        list.splice(index, 1);

                        // Handle firing indexes
                        if (index <= firingIndex) {
                            firingIndex--;
                        }
                    }
                });
                return this;
            },

            // Check if a given callback is in the list.
            // If no argument is given, return whether or not list has callbacks attached.
            has: function(fn) {
                return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;
            },

            // Remove all callbacks from the list
            empty: function() {
                if (list) {
                    list = [];
                }
                return this;
            },

            // Disable .fire and .add
            // Abort any current/pending executions
            // Clear all callbacks and values
            disable: function() {
                locked = queue = [];
                list = memory = "";
                return this;
            },
            disabled: function() {
                return !list;
            },

            // Disable .fire
            // Also disable .add unless we have memory (since it would have no effect)
            // Abort any pending executions
            lock: function() {
                locked = queue = [];
                if (!memory) {
                    list = memory = "";
                }
                return this;
            },
            locked: function() {
                return !!locked;
            },

            // Call all callbacks with the given context and arguments
            fireWith: function(context, args) {
                if (!locked) {
                    args = args || [];
                    args = [context, args.slice ? args.slice() : args];
                    queue.push(args);
                    if (!firing) {
                        fire();
                    }
                }
                return this;
            },

            // Call all the callbacks with the given arguments
            fire: function() {
                self.fireWith(this, arguments);
                return this;
            },

            // To know if the callbacks have already been called at least once
            fired: function() {
                return !!fired;
            }
        };

        return self;
    }
    ;

    jQuery.extend({

        Deferred: function(func) {
            var tuples = [
            // action, add listener, listener list, final state
            ["resolve", "done", jQuery.Callbacks("once memory"), "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), "rejected"], ["notify", "progress", jQuery.Callbacks("memory")]]
              , state = "pending"
              , promise = {
                state: function() {
                    return state;
                },
                always: function() {
                    deferred.done(arguments).fail(arguments);
                    return this;
                },
                then: function(/* fnDone, fnFail, fnProgress */
                ) {
                    var fns = arguments;
                    return jQuery.Deferred(function(newDefer) {
                        jQuery.each(tuples, function(i, tuple) {
                            var fn = jQuery.isFunction(fns[i]) && fns[i];

                            // deferred[ done | fail | progress ] for forwarding actions to newDefer
                            deferred[tuple[1]](function() {
                                var returned = fn && fn.apply(this, arguments);
                                if (returned && jQuery.isFunction(returned.promise)) {
                                    returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);
                                } else {
                                    newDefer[tuple[0] + "With"](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
                                }
                            });
                        });
                        fns = null;
                    }).promise();
                },

                // Get a promise for this deferred
                // If obj is provided, the promise aspect is added to the object
                promise: function(obj) {
                    return obj != null ? jQuery.extend(obj, promise) : promise;
                }
            }
              , deferred = {};

            // Keep pipe for back-compat
            promise.pipe = promise.then;

            // Add list-specific methods
            jQuery.each(tuples, function(i, tuple) {
                var list = tuple[2]
                  , stateString = tuple[3];

                // promise[ done | fail | progress ] = list.add
                promise[tuple[1]] = list.add;

                // Handle state
                if (stateString) {
                    list.add(function() {

                        // state = [ resolved | rejected ]
                        state = stateString;

                        // [ reject_list | resolve_list ].disable; progress_list.lock
                    }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
                }

                // deferred[ resolve | reject | notify ]
                deferred[tuple[0]] = function() {
                    deferred[tuple[0] + "With"](this === deferred ? promise : this, arguments);
                    return this;
                }
                ;
                deferred[tuple[0] + "With"] = list.fireWith;
            });

            // Make the deferred a promise
            promise.promise(deferred);

            // Call given func if any
            if (func) {
                func.call(deferred, deferred);
            }

            // All done!
            return deferred;
        },

        // Deferred helper
        when: function(subordinate /* , ..., subordinateN */
        ) {
            var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length,
            // the count of uncompleted subordinates
            remaining = length !== 1 || (subordinate && jQuery.isFunction(subordinate.promise)) ? length : 0,
            // the master Deferred.
            // If resolveValues consist of only a single Deferred, just use that.
            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),
            // Update function for both resolve and progress values
            updateFunc = function(i, contexts, values) {
                return function(value) {
                    contexts[i] = this;
                    values[i] = arguments.length > 1 ? slice.call(arguments) : value;
                    if (values === progressValues) {
                        deferred.notifyWith(contexts, values);
                    } else if (!(--remaining)) {
                        deferred.resolveWith(contexts, values);
                    }
                }
                ;
            },
            progressValues, progressContexts, resolveContexts;

            // Add listeners to Deferred subordinates; treat others as resolved
            if (length > 1) {
                progressValues = new Array(length);
                progressContexts = new Array(length);
                resolveContexts = new Array(length);
                for (; i < length; i++) {
                    if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
                        resolveValues[i].promise().progress(updateFunc(i, progressContexts, progressValues)).done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject);
                    } else {
                        --remaining;
                    }
                }
            }

            // If we're not waiting on anything, resolve the master
            if (!remaining) {
                deferred.resolveWith(resolveContexts, resolveValues);
            }

            return deferred.promise();
        }
    });

    // The deferred used on DOM ready
    var readyList;

    jQuery.fn.ready = function(fn) {

        // Add the callback
        jQuery.ready.promise().done(fn);

        return this;
    }
    ;

    jQuery.extend({

        // Is the DOM ready to be used? Set to true once it occurs.
        isReady: false,

        // A counter to track how many items to wait for before
        // the ready event fires. See #6781
        readyWait: 1,

        // Hold (or release) the ready event
        holdReady: function(hold) {
            if (hold) {
                jQuery.readyWait++;
            } else {
                jQuery.ready(true);
            }
        },

        // Handle when the DOM is ready
        ready: function(wait) {

            // Abort if there are pending holds or we're already ready
            if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
                return;
            }

            // Remember that the DOM is ready
            jQuery.isReady = true;

            // If a normal DOM Ready event fired, decrement, and wait if need be
            if (wait !== true && --jQuery.readyWait > 0) {
                return;
            }

            // If there are functions bound, to execute
            readyList.resolveWith(document, [jQuery]);

            // Trigger any bound ready events
            if (jQuery.fn.triggerHandler) {
                jQuery(document).triggerHandler("ready");
                jQuery(document).off("ready");
            }
        }
    });

    /**
 * The ready event handler and self cleanup method
 */
    function completed() {
        document.removeEventListener("DOMContentLoaded", completed);
        window.removeEventListener("load", completed);
        jQuery.ready();
    }

    jQuery.ready.promise = function(obj) {
        if (!readyList) {

            readyList = jQuery.Deferred();

            // Catch cases where $(document).ready() is called
            // after the browser event has already occurred.
            // Support: IE9-10 only
            // Older IE sometimes signals "interactive" too soon
            if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll)) {

                // Handle it asynchronously to allow scripts the opportunity to delay ready
                window.setTimeout(jQuery.ready);

            } else {

                // Use the handy event callback
                document.addEventListener("DOMContentLoaded", completed);

                // A fallback to window.onload, that will always work
                window.addEventListener("load", completed);
            }
        }
        return readyList.promise(obj);
    }
    ;

    // Kick off the DOM ready check even if the user does not
    jQuery.ready.promise();

    // Multifunctional method to get and set values of a collection
    // The value/s can optionally be executed if it's a function
    var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
        var i = 0
          , len = elems.length
          , bulk = key == null;

        // Sets many values
        if (jQuery.type(key) === "object") {
            chainable = true;
            for (i in key) {
                access(elems, fn, i, key[i], true, emptyGet, raw);
            }

            // Sets one value
        } else if (value !== undefined) {
            chainable = true;

            if (!jQuery.isFunction(value)) {
                raw = true;
            }

            if (bulk) {

                // Bulk operations run against the entire set
                if (raw) {
                    fn.call(elems, value);
                    fn = null;

                    // ...except when executing function values
                } else {
                    bulk = fn;
                    fn = function(elem, key, value) {
                        return bulk.call(jQuery(elem), value);
                    }
                    ;
                }
            }

            if (fn) {
                for (; i < len; i++) {
                    fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                }
            }
        }

        return chainable ? elems :
        // Gets
        bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet;
    };
    var acceptData = function(owner) {

        // Accepts only:
        //  - Node
        //    - Node.ELEMENT_NODE
        //    - Node.DOCUMENT_NODE
        //  - Object
        //    - Any
        /* jshint -W018 */
        return owner.nodeType === 1 || owner.nodeType === 9 || !(+owner.nodeType);
    };

    function Data() {
        this.expando = jQuery.expando + Data.uid++;
    }

    Data.uid = 1;

    Data.prototype = {

        register: function(owner, initial) {
            var value = initial || {};

            // If it is a node unlikely to be stringify-ed or looped over
            // use plain assignment
            if (owner.nodeType) {
                owner[this.expando] = value;

                // Otherwise secure it in a non-enumerable, non-writable property
                // configurability must be true to allow the property to be
                // deleted with the delete operator
            } else {
                Object.defineProperty(owner, this.expando, {
                    value: value,
                    writable: true,
                    configurable: true
                });
            }
            return owner[this.expando];
        },
        cache: function(owner) {

            // We can accept data for non-element nodes in modern browsers,
            // but we should not, see #8335.
            // Always return an empty object.
            if (!acceptData(owner)) {
                return {};
            }

            // Check if the owner object already has a cache
            var value = owner[this.expando];

            // If not, create one
            if (!value) {
                value = {};

                // We can accept data for non-element nodes in modern browsers,
                // but we should not, see #8335.
                // Always return an empty object.
                if (acceptData(owner)) {

                    // If it is a node unlikely to be stringify-ed or looped over
                    // use plain assignment
                    if (owner.nodeType) {
                        owner[this.expando] = value;

                        // Otherwise secure it in a non-enumerable property
                        // configurable must be true to allow the property to be
                        // deleted when data is removed
                    } else {
                        Object.defineProperty(owner, this.expando, {
                            value: value,
                            configurable: true
                        });
                    }
                }
            }

            return value;
        },
        set: function(owner, data, value) {
            var prop, cache = this.cache(owner);

            // Handle: [ owner, key, value ] args
            if (typeof data === "string") {
                cache[data] = value;

                // Handle: [ owner, { properties } ] args
            } else {

                // Copy the properties one-by-one to the cache object
                for (prop in data) {
                    cache[prop] = data[prop];
                }
            }
            return cache;
        },
        get: function(owner, key) {
            return key === undefined ? this.cache(owner) : owner[this.expando] && owner[this.expando][key];
        },
        access: function(owner, key, value) {
            var stored;

            // In cases where either:
            //
            //   1. No key was specified
            //   2. A string key was specified, but no value provided
            //
            // Take the "read" path and allow the get method to determine
            // which value to return, respectively either:
            //
            //   1. The entire cache object
            //   2. The data stored at the key
            //
            if (key === undefined || ((key && typeof key === "string") && value === undefined)) {

                stored = this.get(owner, key);

                return stored !== undefined ? stored : this.get(owner, jQuery.camelCase(key));
            }

            // When the key is not a string, or both a key and value
            // are specified, set or extend (existing objects) with either:
            //
            //   1. An object of properties
            //   2. A key and value
            //
            this.set(owner, key, value);

            // Since the "set" path can have two possible entry points
            // return the expected data based on which path was taken[*]
            return value !== undefined ? value : key;
        },
        remove: function(owner, key) {
            var i, name, camel, cache = owner[this.expando];

            if (cache === undefined) {
                return;
            }

            if (key === undefined) {
                this.register(owner);

            } else {

                // Support array or space separated string of keys
                if (jQuery.isArray(key)) {

                    // If "name" is an array of keys...
                    // When data is initially created, via ("key", "val") signature,
                    // keys will be converted to camelCase.
                    // Since there is no way to tell _how_ a key was added, remove
                    // both plain key and camelCase key. #12786
                    // This will only penalize the array argument path.
                    name = key.concat(key.map(jQuery.camelCase));
                } else {
                    camel = jQuery.camelCase(key);

                    // Try the string as a key before any manipulation
                    if (key in cache) {
                        name = [key, camel];
                    } else {

                        // If a key with the spaces exists, use it.
                        // Otherwise, create an array by matching non-whitespace
                        name = camel;
                        name = name in cache ? [name] : (name.match(rnotwhite) || []);
                    }
                }

                i = name.length;

                while (i--) {
                    delete cache[name[i]];
                }
            }

            // Remove the expando if there's no more data
            if (key === undefined || jQuery.isEmptyObject(cache)) {

                // Support: Chrome <= 35-45+
                // Webkit & Blink performance suffers when deleting properties
                // from DOM nodes, so set to undefined instead
                // https://code.google.com/p/chromium/issues/detail?id=378607
                if (owner.nodeType) {
                    owner[this.expando] = undefined;
                } else {
                    delete owner[this.expando];
                }
            }
        },
        hasData: function(owner) {
            var cache = owner[this.expando];
            return cache !== undefined && !jQuery.isEmptyObject(cache);
        }
    };
    var dataPriv = new Data();

    var dataUser = new Data();

    //	Implementation Summary
    //
    //	1. Enforce API surface and semantic compatibility with 1.9.x branch
    //	2. Improve the module's maintainability by reducing the storage
    //		paths to a single mechanism.
    //	3. Use the same single mechanism to support "private" and "user" data.
    //	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
    //	5. Avoid exposing implementation details on user objects (eg. expando properties)
    //	6. Provide a clear path for implementation upgrade to WeakMap in 2014

    var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/
      , rmultiDash = /[A-Z]/g;

    function dataAttr(elem, key, data) {
        var name;

        // If nothing was found internally, try to fetch any
        // data from the HTML5 data-* attribute
        if (data === undefined && elem.nodeType === 1) {
            name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase();
            data = elem.getAttribute(name);

            if (typeof data === "string") {
                try {
                    data = data === "true" ? true : data === "false" ? false : data === "null" ? null :
                    // Only convert to a number if it doesn't change the string
                    +data + "" === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
                } catch (e) {}

                // Make sure we set the data so it isn't changed later
                dataUser.set(elem, key, data);
            } else {
                data = undefined;
            }
        }
        return data;
    }

    jQuery.extend({
        hasData: function(elem) {
            return dataUser.hasData(elem) || dataPriv.hasData(elem);
        },

        data: function(elem, name, data) {
            return dataUser.access(elem, name, data);
        },

        removeData: function(elem, name) {
            dataUser.remove(elem, name);
        },

        // TODO: Now that all calls to _data and _removeData have been replaced
        // with direct calls to dataPriv methods, these can be deprecated.
        _data: function(elem, name, data) {
            return dataPriv.access(elem, name, data);
        },

        _removeData: function(elem, name) {
            dataPriv.remove(elem, name);
        }
    });

    jQuery.fn.extend({
        data: function(key, value) {
            var i, name, data, elem = this[0], attrs = elem && elem.attributes;

            // Gets all values
            if (key === undefined) {
                if (this.length) {
                    data = dataUser.get(elem);

                    if (elem.nodeType === 1 && !dataPriv.get(elem, "hasDataAttrs")) {
                        i = attrs.length;
                        while (i--) {

                            // Support: IE11+
                            // The attrs elements can be null (#14894)
                            if (attrs[i]) {
                                name = attrs[i].name;
                                if (name.indexOf("data-") === 0) {
                                    name = jQuery.camelCase(name.slice(5));
                                    dataAttr(elem, name, data[name]);
                                }
                            }
                        }
                        dataPriv.set(elem, "hasDataAttrs", true);
                    }
                }

                return data;
            }

            // Sets multiple values
            if (typeof key === "object") {
                return this.each(function() {
                    dataUser.set(this, key);
                });
            }

            return access(this, function(value) {
                var data, camelKey;

                // The calling jQuery object (element matches) is not empty
                // (and therefore has an element appears at this[ 0 ]) and the
                // `value` parameter was not undefined. An empty jQuery object
                // will result in `undefined` for elem = this[ 0 ] which will
                // throw an exception if an attempt to read a data cache is made.
                if (elem && value === undefined) {

                    // Attempt to get data from the cache
                    // with the key as-is
                    data = dataUser.get(elem, key) ||
                    // Try to find dashed key if it exists (gh-2779)
                    // This is for 2.2.x only
                    dataUser.get(elem, key.replace(rmultiDash, "-$&").toLowerCase());

                    if (data !== undefined) {
                        return data;
                    }

                    camelKey = jQuery.camelCase(key);

                    // Attempt to get data from the cache
                    // with the key camelized
                    data = dataUser.get(elem, camelKey);
                    if (data !== undefined) {
                        return data;
                    }

                    // Attempt to "discover" the data in
                    // HTML5 custom data-* attrs
                    data = dataAttr(elem, camelKey, undefined);
                    if (data !== undefined) {
                        return data;
                    }

                    // We tried really hard, but the data doesn't exist.
                    return;
                }

                // Set the data...
                camelKey = jQuery.camelCase(key);
                this.each(function() {

                    // First, attempt to store a copy or reference of any
                    // data that might've been store with a camelCased key.
                    var data = dataUser.get(this, camelKey);

                    // For HTML5 data-* attribute interop, we have to
                    // store property names with dashes in a camelCase form.
                    // This might not apply to all properties...*
                    dataUser.set(this, camelKey, value);

                    // *... In the case of properties that might _actually_
                    // have dashes, we need to also store a copy of that
                    // unchanged property.
                    if (key.indexOf("-") > -1 && data !== undefined) {
                        dataUser.set(this, key, value);
                    }
                });
            }, null, value, arguments.length > 1, null, true);
        },

        removeData: function(key) {
            return this.each(function() {
                dataUser.remove(this, key);
            });
        }
    });

    jQuery.extend({
        queue: function(elem, type, data) {
            var queue;

            if (elem) {
                type = (type || "fx") + "queue";
                queue = dataPriv.get(elem, type);

                // Speed up dequeue by getting out quickly if this is just a lookup
                if (data) {
                    if (!queue || jQuery.isArray(data)) {
                        queue = dataPriv.access(elem, type, jQuery.makeArray(data));
                    } else {
                        queue.push(data);
                    }
                }
                return queue || [];
            }
        },

        dequeue: function(elem, type) {
            type = type || "fx";

            var queue = jQuery.queue(elem, type)
              , startLength = queue.length
              , fn = queue.shift()
              , hooks = jQuery._queueHooks(elem, type)
              , next = function() {
                jQuery.dequeue(elem, type);
            };

            // If the fx queue is dequeued, always remove the progress sentinel
            if (fn === "inprogress") {
                fn = queue.shift();
                startLength--;
            }

            if (fn) {

                // Add a progress sentinel to prevent the fx queue from being
                // automatically dequeued
                if (type === "fx") {
                    queue.unshift("inprogress");
                }

                // Clear up the last queue stop function
                delete hooks.stop;
                fn.call(elem, next, hooks);
            }

            if (!startLength && hooks) {
                hooks.empty.fire();
            }
        },

        // Not public - generate a queueHooks object, or return the current one
        _queueHooks: function(elem, type) {
            var key = type + "queueHooks";
            return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                empty: jQuery.Callbacks("once memory").add(function() {
                    dataPriv.remove(elem, [type + "queue", key]);
                })
            });
        }
    });

    jQuery.fn.extend({
        queue: function(type, data) {
            var setter = 2;

            if (typeof type !== "string") {
                data = type;
                type = "fx";
                setter--;
            }

            if (arguments.length < setter) {
                return jQuery.queue(this[0], type);
            }

            return data === undefined ? this : this.each(function() {
                var queue = jQuery.queue(this, type, data);

                // Ensure a hooks for this queue
                jQuery._queueHooks(this, type);

                if (type === "fx" && queue[0] !== "inprogress") {
                    jQuery.dequeue(this, type);
                }
            });
        },
        dequeue: function(type) {
            return this.each(function() {
                jQuery.dequeue(this, type);
            });
        },
        clearQueue: function(type) {
            return this.queue(type || "fx", []);
        },

        // Get a promise resolved when queues of a certain type
        // are emptied (fx is the type by default)
        promise: function(type, obj) {
            var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
                if (!(--count)) {
                    defer.resolveWith(elements, [elements]);
                }
            };

            if (typeof type !== "string") {
                obj = type;
                type = undefined;
            }
            type = type || "fx";

            while (i--) {
                tmp = dataPriv.get(elements[i], type + "queueHooks");
                if (tmp && tmp.empty) {
                    count++;
                    tmp.empty.add(resolve);
                }
            }
            resolve();
            return defer.promise(obj);
        }
    });
    var pnum = (/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/).source;

    var rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$","i");

    var cssExpand = ["Top", "Right", "Bottom", "Left"];

    var isHidden = function(elem, el) {

        // isHidden might be called from jQuery#filter function;
        // in that case, element will be second argument
        elem = el || elem;
        return jQuery.css(elem, "display") === "none" || !jQuery.contains(elem.ownerDocument, elem);
    };

    function adjustCSS(elem, prop, valueParts, tween) {
        var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function() {
            return tween.cur();
        }
        : function() {
            return jQuery.css(elem, prop, "");
        }
        , initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
        // Starting value computation is required for potential unit mismatches
        initialInUnit = (jQuery.cssNumber[prop] || unit !== "px" && +initial) && rcssNum.exec(jQuery.css(elem, prop));

        if (initialInUnit && initialInUnit[3] !== unit) {

            // Trust units reported by jQuery.css
            unit = unit || initialInUnit[3];

            // Make sure we update the tween properties later on
            valueParts = valueParts || [];

            // Iteratively approximate from a nonzero starting point
            initialInUnit = +initial || 1;

            do {

                // If previous iteration zeroed out, double until we get *something*.
                // Use string for doubling so we don't accidentally see scale as unchanged below
                scale = scale || ".5";

                // Adjust and apply
                initialInUnit = initialInUnit / scale;
                jQuery.style(elem, prop, initialInUnit + unit);

                // Update scale, tolerating zero or NaN from tween.cur()
                // Break the loop if scale is unchanged or perfect, or if we've just had enough.
            } while (scale !== (scale = currentValue() / initial) && scale !== 1 && --maxIterations);
        }

        if (valueParts) {
            initialInUnit = +initialInUnit || +initial || 0;

            // Apply relative offset (+=/-=) if specified
            adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2];
            if (tween) {
                tween.unit = unit;
                tween.start = initialInUnit;
                tween.end = adjusted;
            }
        }
        return adjusted;
    }
    var rcheckableType = (/^(?:checkbox|radio)$/i);

    var rtagName = (/<([\w:-]+)/);

    var rscriptType = (/^$|\/(?:java|ecma)script/i);

    // We have to close these tags to support XHTML (#13200)
    var wrapMap = {

        // Support: IE9
        option: [1, "<select multiple='multiple'>", "</select>"],

        // XHTML parsers do not magically insert elements in the
        // same way that tag soup parsers do. So we cannot shorten
        // this by omitting <tbody> or other required elements.
        thead: [1, "<table>", "</table>"],
        col: [2, "<table><colgroup>", "</colgroup></table>"],
        tr: [2, "<table><tbody>", "</tbody></table>"],
        td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],

        _default: [0, "", ""]
    };

    // Support: IE9
    wrapMap.optgroup = wrapMap.option;

    wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
    wrapMap.th = wrapMap.td;

    function getAll(context, tag) {

        // Support: IE9-11+
        // Use typeof to avoid zero-argument method invocation on host objects (#15151)
        var ret = typeof context.getElementsByTagName !== "undefined" ? context.getElementsByTagName(tag || "*") : typeof context.querySelectorAll !== "undefined" ? context.querySelectorAll(tag || "*") : [];

        return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret;
    }

    // Mark scripts as having already been evaluated
    function setGlobalEval(elems, refElements) {
        var i = 0
          , l = elems.length;

        for (; i < l; i++) {
            dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"));
        }
    }

    var rhtml = /<|&#?\w+;/;

    function buildFragment(elems, context, scripts, selection, ignored) {
        var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length;

        for (; i < l; i++) {
            elem = elems[i];

            if (elem || elem === 0) {

                // Add nodes directly
                if (jQuery.type(elem) === "object") {

                    // Support: Android<4.1, PhantomJS<2
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, elem.nodeType ? [elem] : elem);

                    // Convert non-html into a text node
                } else if (!rhtml.test(elem)) {
                    nodes.push(context.createTextNode(elem));

                    // Convert html into DOM nodes
                } else {
                    tmp = tmp || fragment.appendChild(context.createElement("div"));

                    // Deserialize a standard representation
                    tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase();
                    wrap = wrapMap[tag] || wrapMap._default;
                    tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2];

                    // Descend through wrappers to the right content
                    j = wrap[0];
                    while (j--) {
                        tmp = tmp.lastChild;
                    }

                    // Support: Android<4.1, PhantomJS<2
                    // push.apply(_, arraylike) throws on ancient WebKit
                    jQuery.merge(nodes, tmp.childNodes);

                    // Remember the top-level container
                    tmp = fragment.firstChild;

                    // Ensure the created nodes are orphaned (#12392)
                    tmp.textContent = "";
                }
            }
        }

        // Remove wrapper from fragment
        fragment.textContent = "";

        i = 0;
        while ((elem = nodes[i++])) {

            // Skip elements already in the context collection (trac-4087)
            if (selection && jQuery.inArray(elem, selection) > -1) {
                if (ignored) {
                    ignored.push(elem);
                }
                continue;
            }

            contains = jQuery.contains(elem.ownerDocument, elem);

            // Append to fragment
            tmp = getAll(fragment.appendChild(elem), "script");

            // Preserve script evaluation history
            if (contains) {
                setGlobalEval(tmp);
            }

            // Capture executables
            if (scripts) {
                j = 0;
                while ((elem = tmp[j++])) {
                    if (rscriptType.test(elem.type || "")) {
                        scripts.push(elem);
                    }
                }
            }
        }

        return fragment;
    }

    (function() {
        var fragment = document.createDocumentFragment()
          , div = fragment.appendChild(document.createElement("div"))
          , input = document.createElement("input");

        // Support: Android 4.0-4.3, Safari<=5.1
        // Check state lost if the name is set (#11217)
        // Support: Windows Web Apps (WWA)
        // `name` and `type` must use .setAttribute for WWA (#14901)
        input.setAttribute("type", "radio");
        input.setAttribute("checked", "checked");
        input.setAttribute("name", "t");

        div.appendChild(input);

        // Support: Safari<=5.1, Android<4.2
        // Older WebKit doesn't clone checked state correctly in fragments
        support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;

        // Support: IE<=11+
        // Make sure textarea (and checkbox) defaultValue is properly cloned
        div.innerHTML = "<textarea>x</textarea>";
        support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    }
    )();

    var rkeyEvent = /^key/
      , rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/
      , rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

    function returnTrue() {
        return true;
    }

    function returnFalse() {
        return false;
    }

    // Support: IE9
    // See #13393 for more info
    function safeActiveElement() {
        try {
            return document.activeElement;
        } catch (err) {}
    }

    function on(elem, types, selector, data, fn, one) {
        var origFn, type;

        // Types can be a map of types/handlers
        if (typeof types === "object") {

            // ( types-Object, selector, data )
            if (typeof selector !== "string") {

                // ( types-Object, data )
                data = data || selector;
                selector = undefined;
            }
            for (type in types) {
                on(elem, type, selector, data, types[type], one);
            }
            return elem;
        }

        if (data == null && fn == null) {

            // ( types, fn )
            fn = selector;
            data = selector = undefined;
        } else if (fn == null) {
            if (typeof selector === "string") {

                // ( types, selector, fn )
                fn = data;
                data = undefined;
            } else {

                // ( types, data, fn )
                fn = data;
                data = selector;
                selector = undefined;
            }
        }
        if (fn === false) {
            fn = returnFalse;
        } else if (!fn) {
            return elem;
        }

        if (one === 1) {
            origFn = fn;
            fn = function(event) {

                // Can use an empty set, since event contains the info
                jQuery().off(event);
                return origFn.apply(this, arguments);
            }
            ;

            // Use same guid so caller can remove using origFn
            fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
        }
        return elem.each(function() {
            jQuery.event.add(this, types, fn, data, selector);
        });
    }

    /*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
    jQuery.event = {

        global: {},

        add: function(elem, types, handler, data, selector) {

            var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);

            // Don't attach events to noData or text/comment nodes (but allow plain objects)
            if (!elemData) {
                return;
            }

            // Caller can pass in an object of custom data in lieu of the handler
            if (handler.handler) {
                handleObjIn = handler;
                handler = handleObjIn.handler;
                selector = handleObjIn.selector;
            }

            // Make sure that the handler has a unique ID, used to find/remove it later
            if (!handler.guid) {
                handler.guid = jQuery.guid++;
            }

            // Init the element's event structure and main handler, if this is the first
            if (!(events = elemData.events)) {
                events = elemData.events = {};
            }
            if (!(eventHandle = elemData.handle)) {
                eventHandle = elemData.handle = function(e) {

                    // Discard the second event of a jQuery.event.trigger() and
                    // when an event is called after a page has unloaded
                    return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : undefined;
                }
                ;
            }

            // Handle multiple events separated by a space
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // There *must* be a type, no attaching namespace-only handlers
                if (!type) {
                    continue;
                }

                // If event changes its type, use the special event handlers for the changed type
                special = jQuery.event.special[type] || {};

                // If selector defined, determine special event api type, otherwise given type
                type = (selector ? special.delegateType : special.bindType) || type;

                // Update special based on newly reset type
                special = jQuery.event.special[type] || {};

                // handleObj is passed to all event handlers
                handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn);

                // Init the event handler queue if we're the first
                if (!(handlers = events[type])) {
                    handlers = events[type] = [];
                    handlers.delegateCount = 0;

                    // Only use addEventListener if the special events handler returns false
                    if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {

                        if (elem.addEventListener) {
                            elem.addEventListener(type, eventHandle);
                        }
                    }
                }

                if (special.add) {
                    special.add.call(elem, handleObj);

                    if (!handleObj.handler.guid) {
                        handleObj.handler.guid = handler.guid;
                    }
                }

                // Add to the element's handler list, delegates in front
                if (selector) {
                    handlers.splice(handlers.delegateCount++, 0, handleObj);
                } else {
                    handlers.push(handleObj);
                }

                // Keep track of which events have ever been used, for event optimization
                jQuery.event.global[type] = true;
            }

        },

        // Detach an event or set of events from an element
        remove: function(elem, types, handler, selector, mappedTypes) {

            var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);

            if (!elemData || !(events = elemData.events)) {
                return;
            }

            // Once for each type.namespace in types; type may be omitted
            types = (types || "").match(rnotwhite) || [""];
            t = types.length;
            while (t--) {
                tmp = rtypenamespace.exec(types[t]) || [];
                type = origType = tmp[1];
                namespaces = (tmp[2] || "").split(".").sort();

                // Unbind all events (on this namespace, if provided) for the element
                if (!type) {
                    for (type in events) {
                        jQuery.event.remove(elem, type + types[t], handler, selector, true);
                    }
                    continue;
                }

                special = jQuery.event.special[type] || {};
                type = (selector ? special.delegateType : special.bindType) || type;
                handlers = events[type] || [];
                tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)");

                // Remove matching events
                origCount = j = handlers.length;
                while (j--) {
                    handleObj = handlers[j];

                    if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === "**" && handleObj.selector)) {
                        handlers.splice(j, 1);

                        if (handleObj.selector) {
                            handlers.delegateCount--;
                        }
                        if (special.remove) {
                            special.remove.call(elem, handleObj);
                        }
                    }
                }

                // Remove generic event handler if we removed something and no more handlers exist
                // (avoids potential for endless recursion during removal of special event handlers)
                if (origCount && !handlers.length) {
                    if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {

                        jQuery.removeEvent(elem, type, elemData.handle);
                    }

                    delete events[type];
                }
            }

            // Remove data and the expando if it's no longer used
            if (jQuery.isEmptyObject(events)) {
                dataPriv.remove(elem, "handle events");
            }
        },

        dispatch: function(event) {

            // Make a writable jQuery.Event from the native event object
            event = jQuery.event.fix(event);

            var i, j, ret, matched, handleObj, handlerQueue = [], args = slice.call(arguments), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};

            // Use the fix-ed jQuery.Event rather than the (read-only) native event
            args[0] = event;
            event.delegateTarget = this;

            // Call the preDispatch hook for the mapped type, and let it bail if desired
            if (special.preDispatch && special.preDispatch.call(this, event) === false) {
                return;
            }

            // Determine handlers
            handlerQueue = jQuery.event.handlers.call(this, event, handlers);

            // Run delegates first; they may want to stop propagation beneath us
            i = 0;
            while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
                event.currentTarget = matched.elem;

                j = 0;
                while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {

                    // Triggered event must either 1) have no namespace, or 2) have namespace(s)
                    // a subset or equal to those in the bound event (both can have no namespace).
                    if (!event.rnamespace || event.rnamespace.test(handleObj.namespace)) {

                        event.handleObj = handleObj;
                        event.data = handleObj.data;

                        ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);

                        if (ret !== undefined) {
                            if ((event.result = ret) === false) {
                                event.preventDefault();
                                event.stopPropagation();
                            }
                        }
                    }
                }
            }

            // Call the postDispatch hook for the mapped type
            if (special.postDispatch) {
                special.postDispatch.call(this, event);
            }

            return event.result;
        },

        handlers: function(event, handlers) {
            var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;

            // Support (at least): Chrome, IE9
            // Find delegate handlers
            // Black-hole SVG <use> instance trees (#13180)
            //
            // Support: Firefox<=42+
            // Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
            if (delegateCount && cur.nodeType && (event.type !== "click" || isNaN(event.button) || event.button < 1)) {

                for (; cur !== this; cur = cur.parentNode || this) {

                    // Don't check non-elements (#13208)
                    // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
                    if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== "click")) {
                        matches = [];
                        for (i = 0; i < delegateCount; i++) {
                            handleObj = handlers[i];

                            // Don't conflict with Object.prototype properties (#13203)
                            sel = handleObj.selector + " ";

                            if (matches[sel] === undefined) {
                                matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length;
                            }
                            if (matches[sel]) {
                                matches.push(handleObj);
                            }
                        }
                        if (matches.length) {
                            handlerQueue.push({
                                elem: cur,
                                handlers: matches
                            });
                        }
                    }
                }
            }

            // Add the remaining (directly-bound) handlers
            if (delegateCount < handlers.length) {
                handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                });
            }

            return handlerQueue;
        },

        // Includes some event props shared by KeyEvent and MouseEvent
        props: ("altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " + "metaKey relatedTarget shiftKey target timeStamp view which").split(" "),

        fixHooks: {},

        keyHooks: {
            props: "char charCode key keyCode".split(" "),
            filter: function(event, original) {

                // Add which for key events
                if (event.which == null) {
                    event.which = original.charCode != null ? original.charCode : original.keyCode;
                }

                return event;
            }
        },

        mouseHooks: {
            props: ("button buttons clientX clientY offsetX offsetY pageX pageY " + "screenX screenY toElement").split(" "),
            filter: function(event, original) {
                var eventDoc, doc, body, button = original.button;

                // Calculate pageX/Y if missing and clientX/Y available
                if (event.pageX == null && original.clientX != null) {
                    eventDoc = event.target.ownerDocument || document;
                    doc = eventDoc.documentElement;
                    body = eventDoc.body;

                    event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
                    event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
                }

                // Add which for click: 1 === left; 2 === middle; 3 === right
                // Note: button is not normalized, so don't use it
                if (!event.which && button !== undefined) {
                    event.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)));
                }

                return event;
            }
        },

        fix: function(event) {
            if (event[jQuery.expando]) {
                return event;
            }

            // Create a writable copy of the event object and normalize some properties
            var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];

            if (!fixHook) {
                this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
            }
            copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;

            event = new jQuery.Event(originalEvent);

            i = copy.length;
            while (i--) {
                prop = copy[i];
                event[prop] = originalEvent[prop];
            }

            // Support: Cordova 2.5 (WebKit) (#13255)
            // All events should have a target; Cordova deviceready doesn't
            if (!event.target) {
                event.target = document;
            }

            // Support: Safari 6.0+, Chrome<28
            // Target should not be a text node (#504, #13143)
            if (event.target.nodeType === 3) {
                event.target = event.target.parentNode;
            }

            return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
        },

        special: {
            load: {

                // Prevent triggered image.load events from bubbling to window.load
                noBubble: true
            },
            focus: {

                // Fire native event if possible so blur/focus sequence is correct
                trigger: function() {
                    if (this !== safeActiveElement() && this.focus) {
                        this.focus();
                        return false;
                    }
                },
                delegateType: "focusin"
            },
            blur: {
                trigger: function() {
                    if (this === safeActiveElement() && this.blur) {
                        this.blur();
                        return false;
                    }
                },
                delegateType: "focusout"
            },
            click: {

                // For checkbox, fire native event so checked state will be right
                trigger: function() {
                    if (this.type === "checkbox" && this.click && jQuery.nodeName(this, "input")) {
                        this.click();
                        return false;
                    }
                },

                // For cross-browser consistency, don't fire native .click() on links
                _default: function(event) {
                    return jQuery.nodeName(event.target, "a");
                }
            },

            beforeunload: {
                postDispatch: function(event) {

                    // Support: Firefox 20+
                    // Firefox doesn't alert if the returnValue field is not set.
                    if (event.result !== undefined && event.originalEvent) {
                        event.originalEvent.returnValue = event.result;
                    }
                }
            }
        }
    };

    jQuery.removeEvent = function(elem, type, handle) {

        // This "if" is needed for plain objects
        if (elem.removeEventListener) {
            elem.removeEventListener(type, handle);
        }
    }
    ;

    jQuery.Event = function(src, props) {

        // Allow instantiation without the 'new' keyword
        if (!(this instanceof jQuery.Event)) {
            return new jQuery.Event(src,props);
        }

        // Event object
        if (src && src.type) {
            this.originalEvent = src;
            this.type = src.type;

            // Events bubbling up the document may have been marked as prevented
            // by a handler lower down the tree; reflect the correct value.
            this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined &&
            // Support: Android<4.0
            src.returnValue === false ? returnTrue : returnFalse;

            // Event type
        } else {
            this.type = src;
        }

        // Put explicitly provided properties onto the event object
        if (props) {
            jQuery.extend(this, props);
        }

        // Create a timestamp if incoming event doesn't have one
        this.timeStamp = src && src.timeStamp || jQuery.now();

        // Mark it as fixed
        this[jQuery.expando] = true;
    }
    ;

    // jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
    // http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
    jQuery.Event.prototype = {
        constructor: jQuery.Event,
        isDefaultPrevented: returnFalse,
        isPropagationStopped: returnFalse,
        isImmediatePropagationStopped: returnFalse,
        isSimulated: false,

        preventDefault: function() {
            var e = this.originalEvent;

            this.isDefaultPrevented = returnTrue;

            if (e && !this.isSimulated) {
                e.preventDefault();
            }
        },
        stopPropagation: function() {
            var e = this.originalEvent;

            this.isPropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopPropagation();
            }
        },
        stopImmediatePropagation: function() {
            var e = this.originalEvent;

            this.isImmediatePropagationStopped = returnTrue;

            if (e && !this.isSimulated) {
                e.stopImmediatePropagation();
            }

            this.stopPropagation();
        }
    };

    // Create mouseenter/leave events using mouseover/out and event-time checks
    // so that event delegation works in jQuery.
    // Do the same for pointerenter/pointerleave and pointerover/pointerout
    //
    // Support: Safari 7 only
    // Safari sends mouseenter too often; see:
    // https://code.google.com/p/chromium/issues/detail?id=470258
    // for the description of the bug (it existed in older Chrome versions as well).
    jQuery.each({
        mouseenter: "mouseover",
        mouseleave: "mouseout",
        pointerenter: "pointerover",
        pointerleave: "pointerout"
    }, function(orig, fix) {
        jQuery.event.special[orig] = {
            delegateType: fix,
            bindType: fix,

            handle: function(event) {
                var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;

                // For mouseenter/leave call the handler if related is outside the target.
                // NB: No relatedTarget if the mouse left/entered the browser window
                if (!related || (related !== target && !jQuery.contains(target, related))) {
                    event.type = handleObj.origType;
                    ret = handleObj.handler.apply(this, arguments);
                    event.type = fix;
                }
                return ret;
            }
        };
    });

    jQuery.fn.extend({
        on: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn);
        },
        one: function(types, selector, data, fn) {
            return on(this, types, selector, data, fn, 1);
        },
        off: function(types, selector, fn) {
            var handleObj, type;
            if (types && types.preventDefault && types.handleObj) {

                // ( event )  dispatched jQuery.Event
                handleObj = types.handleObj;
                jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
                return this;
            }
            if (typeof types === "object") {

                // ( types-object [, selector] )
                for (type in types) {
                    this.off(type, selector, types[type]);
                }
                return this;
            }
            if (selector === false || typeof selector === "function") {

                // ( types [, fn] )
                fn = selector;
                selector = undefined;
            }
            if (fn === false) {
                fn = returnFalse;
            }
            return this.each(function() {
                jQuery.event.remove(this, types, fn, selector);
            });
        }
    });

    var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi
      ,
    // Support: IE 10-11, Edge 10240+
    // In IE/Edge using regex groups here causes severe slowdowns.
    // See https://connect.microsoft.com/IE/feedback/details/1736512/
    rnoInnerhtml = /<script|<style|<link/i
      ,
    // checked="checked" or checked
    rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i
      , rscriptTypeMasked = /^true\/(.*)/
      , rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

    // Manipulating tables requires a tbody
    function manipulationTarget(elem, content) {
        return jQuery.nodeName(elem, "table") && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, "tr") ?
        elem.getElementsByTagName("tbody")[0] || elem.appendChild(elem.ownerDocument.createElement("tbody")) : elem;
    }

    // Replace/restore the type attribute of script elements for safe DOM manipulation
    function disableScript(elem) {
        elem.type = (elem.getAttribute("type") !== null) + "/" + elem.type;
        return elem;
    }
    function restoreScript(elem) {
        var match = rscriptTypeMasked.exec(elem.type);

        if (match) {
            elem.type = match[1];
        } else {
            elem.removeAttribute("type");
        }

        return elem;
    }

    function cloneCopyEvent(src, dest) {
        var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

        if (dest.nodeType !== 1) {
            return;
        }

        // 1. Copy private data: events, handlers, etc.
        if (dataPriv.hasData(src)) {
            pdataOld = dataPriv.access(src);
            pdataCur = dataPriv.set(dest, pdataOld);
            events = pdataOld.events;

            if (events) {
                delete pdataCur.handle;
                pdataCur.events = {};

                for (type in events) {
                    for (i = 0,
                    l = events[type].length; i < l; i++) {
                        jQuery.event.add(dest, type, events[type][i]);
                    }
                }
            }
        }

        // 2. Copy user data
        if (dataUser.hasData(src)) {
            udataOld = dataUser.access(src);
            udataCur = jQuery.extend({}, udataOld);

            dataUser.set(dest, udataCur);
        }
    }

    // Fix IE bugs, see support tests
    function fixInput(src, dest) {
        var nodeName = dest.nodeName.toLowerCase();

        // Fails to persist the checked state of a cloned checkbox or radio button.
        if (nodeName === "input" && rcheckableType.test(src.type)) {
            dest.checked = src.checked;

            // Fails to return the selected option to the default selected state when cloning options
        } else if (nodeName === "input" || nodeName === "textarea") {
            dest.defaultValue = src.defaultValue;
        }
    }

    function domManip(collection, args, callback, ignored) {

        // Flatten any nested arrays
        args = concat.apply([], args);

        var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);

        // We can't cloneNode fragments that contain checked, in WebKit
        if (isFunction || (l > 1 && typeof value === "string" && !support.checkClone && rchecked.test(value))) {
            return collection.each(function(index) {
                var self = collection.eq(index);
                if (isFunction) {
                    args[0] = value.call(this, index, self.html());
                }
                domManip(self, args, callback, ignored);
            });
        }

        if (l) {
            fragment = buildFragment(args, collection[0].ownerDocument, false, collection, ignored);
            first = fragment.firstChild;

            if (fragment.childNodes.length === 1) {
                fragment = first;
            }

            // Require either new content or an interest in ignored elements to invoke the callback
            if (first || ignored) {
                scripts = jQuery.map(getAll(fragment, "script"), disableScript);
                hasScripts = scripts.length;

                // Use the original fragment for the last item
                // instead of the first because it can end up
                // being emptied incorrectly in certain situations (#8070).
                for (; i < l; i++) {
                    node = fragment;

                    if (i !== iNoClone) {
                        node = jQuery.clone(node, true, true);

                        // Keep references to cloned scripts for later restoration
                        if (hasScripts) {

                            // Support: Android<4.1, PhantomJS<2
                            // push.apply(_, arraylike) throws on ancient WebKit
                            jQuery.merge(scripts, getAll(node, "script"));
                        }
                    }

                    callback.call(collection[i], node, i);
                }

                if (hasScripts) {
                    doc = scripts[scripts.length - 1].ownerDocument;

                    // Reenable scripts
                    jQuery.map(scripts, restoreScript);

                    // Evaluate executable scripts on first document insertion
                    for (i = 0; i < hasScripts; i++) {
                        node = scripts[i];
                        if (rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node)) {

                            if (node.src) {

                                // Optional AJAX dependency, but won't run scripts if not present
                                if (jQuery._evalUrl) {
                                    jQuery._evalUrl(node.src);
                                }
                            } else {
                                jQuery.globalEval(node.textContent.replace(rcleanScript, ""));
                            }
                        }
                    }
                }
            }
        }

        return collection;
    }

    function remove(elem, selector, keepData) {
        var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0;

        for (; (node = nodes[i]) != null; i++) {
            if (!keepData && node.nodeType === 1) {
                jQuery.cleanData(getAll(node));
            }

            if (node.parentNode) {
                if (keepData && jQuery.contains(node.ownerDocument, node)) {
                    setGlobalEval(getAll(node, "script"));
                }
                node.parentNode.removeChild(node);
            }
        }

        return elem;
    }

    jQuery.extend({
        htmlPrefilter: function(html) {
            return html.replace(rxhtmlTag, "<$1></$2>");
        },

        clone: function(elem, dataAndEvents, deepDataAndEvents) {
            var i, l, srcElements, destElements, clone = elem.cloneNode(true), inPage = jQuery.contains(elem.ownerDocument, elem);

            // Fix IE cloning issues
            if (!support.noCloneChecked && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {

                // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
                destElements = getAll(clone);
                srcElements = getAll(elem);

                for (i = 0,
                l = srcElements.length; i < l; i++) {
                    fixInput(srcElements[i], destElements[i]);
                }
            }

            // Copy the events from the original to the clone
            if (dataAndEvents) {
                if (deepDataAndEvents) {
                    srcElements = srcElements || getAll(elem);
                    destElements = destElements || getAll(clone);

                    for (i = 0,
                    l = srcElements.length; i < l; i++) {
                        cloneCopyEvent(srcElements[i], destElements[i]);
                    }
                } else {
                    cloneCopyEvent(elem, clone);
                }
            }

            // Preserve script evaluation history
            destElements = getAll(clone, "script");
            if (destElements.length > 0) {
                setGlobalEval(destElements, !inPage && getAll(elem, "script"));
            }

            // Return the cloned set
            return clone;
        },

        cleanData: function(elems) {
            var data, elem, type, special = jQuery.event.special, i = 0;

            for (; (elem = elems[i]) !== undefined; i++) {
                if (acceptData(elem)) {
                    if ((data = elem[dataPriv.expando])) {
                        if (data.events) {
                            for (type in data.events) {
                                if (special[type]) {
                                    jQuery.event.remove(elem, type);

                                    // This is a shortcut to avoid jQuery.event.remove's overhead
                                } else {
                                    jQuery.removeEvent(elem, type, data.handle);
                                }
                            }
                        }

                        // Support: Chrome <= 35-45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataPriv.expando] = undefined;
                    }
                    if (elem[dataUser.expando]) {

                        // Support: Chrome <= 35-45+
                        // Assign undefined instead of using delete, see Data#remove
                        elem[dataUser.expando] = undefined;
                    }
                }
            }
        }
    });

    jQuery.fn.extend({

        // Keep domManip exposed until 3.0 (gh-2225)
        domManip: domManip,

        detach: function(selector) {
            return remove(this, selector, true);
        },

        remove: function(selector) {
            return remove(this, selector);
        },

        text: function(value) {
            return access(this, function(value) {
                return value === undefined ? jQuery.text(this) : this.empty().each(function() {
                    if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                        this.textContent = value;
                    }
                });
            }, null, value, arguments.length);
        },

        append: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.appendChild(elem);
                }
            });
        },

        prepend: function() {
            return domManip(this, arguments, function(elem) {
                if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
                    var target = manipulationTarget(this, elem);
                    target.insertBefore(elem, target.firstChild);
                }
            });
        },

        before: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this);
                }
            });
        },

        after: function() {
            return domManip(this, arguments, function(elem) {
                if (this.parentNode) {
                    this.parentNode.insertBefore(elem, this.nextSibling);
                }
            });
        },

        empty: function() {
            var elem, i = 0;

            for (; (elem = this[i]) != null; i++) {
                if (elem.nodeType === 1) {

                    // Prevent memory leaks
                    jQuery.cleanData(getAll(elem, false));

                    // Remove any remaining nodes
                    elem.textContent = "";
                }
            }

            return this;
        },

        clone: function(dataAndEvents, deepDataAndEvents) {
            dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
            deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

            return this.map(function() {
                return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
            });
        },

        html: function(value) {
            return access(this, function(value) {
                var elem = this[0] || {}
                  , i = 0
                  , l = this.length;

                if (value === undefined && elem.nodeType === 1) {
                    return elem.innerHTML;
                }

                // See if we can take a shortcut and just use innerHTML
                if (typeof value === "string" && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {

                    value = jQuery.htmlPrefilter(value);

                    try {
                        for (; i < l; i++) {
                            elem = this[i] || {};

                            // Remove element nodes and prevent memory leaks
                            if (elem.nodeType === 1) {
                                jQuery.cleanData(getAll(elem, false));
                                elem.innerHTML = value;
                            }
                        }

                        elem = 0;

                        // If using innerHTML throws an exception, use the fallback method
                    } catch (e) {}
                }

                if (elem) {
                    this.empty().append(value);
                }
            }, null, value, arguments.length);
        },

        replaceWith: function() {
            var ignored = [];

            // Make the changes, replacing each non-ignored context element with the new content
            return domManip(this, arguments, function(elem) {
                var parent = this.parentNode;

                if (jQuery.inArray(this, ignored) < 0) {
                    jQuery.cleanData(getAll(this));
                    if (parent) {
                        parent.replaceChild(elem, this);
                    }
                }

                // Force callback invocation
            }, ignored);
        }
    });

    jQuery.each({
        appendTo: "append",
        prependTo: "prepend",
        insertBefore: "before",
        insertAfter: "after",
        replaceAll: "replaceWith"
    }, function(name, original) {
        jQuery.fn[name] = function(selector) {
            var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0;

            for (; i <= last; i++) {
                elems = i === last ? this : this.clone(true);
                jQuery(insert[i])[original](elems);

                // Support: QtWebKit
                // .get() because push.apply(_, arraylike) throws
                push.apply(ret, elems.get());
            }

            return this.pushStack(ret);
        }
        ;
    });

    var iframe, elemdisplay = {

        // Support: Firefox
        // We have to pre-define these values for FF (#10227)
        HTML: "block",
        BODY: "block"
    };

    /**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

    // Called only from within defaultDisplay
    function actualDisplay(name, doc) {
        var elem = jQuery(doc.createElement(name)).appendTo(doc.body)
          ,
        display = jQuery.css(elem[0], "display");

        // We don't have any data stored on the element,
        // so use "detach" method as fast way to get rid of the element
        elem.detach();

        return display;
    }

    /**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
    function defaultDisplay(nodeName) {
        var doc = document
          , display = elemdisplay[nodeName];

        if (!display) {
            display = actualDisplay(nodeName, doc);

            // If the simple way fails, read from inside an iframe
            if (display === "none" || !display) {

                // Use the already-created iframe if possible
                iframe = (iframe || jQuery("<iframe frameborder='0' width='0' height='0'/>")).appendTo(doc.documentElement);

                // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
                doc = iframe[0].contentDocument;

                // Support: IE
                doc.write();
                doc.close();

                display = actualDisplay(nodeName, doc);
                iframe.detach();
            }

            // Store the correct default display
            elemdisplay[nodeName] = display;
        }

        return display;
    }
    var rmargin = (/^margin/);

    var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$","i");

    var getStyles = function(elem) {

        // Support: IE<=11+, Firefox<=30+ (#15098, #14150)
        // IE throws on elements created in popups
        // FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
        var view = elem.ownerDocument.defaultView;

        if (!view || !view.opener) {
            view = window;
        }

        return view.getComputedStyle(elem);
    };

    var swap = function(elem, options, callback, args) {
        var ret, name, old = {};

        // Remember the old values, and insert the new ones
        for (name in options) {
            old[name] = elem.style[name];
            elem.style[name] = options[name];
        }

        ret = callback.apply(elem, args || []);

        // Revert the old values
        for (name in options) {
            elem.style[name] = old[name];
        }

        return ret;
    };

    var documentElement = document.documentElement;

    (function() {
        var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");

        // Finish early in limited (non-browser) environments
        if (!div.style) {
            return;
        }

        // Support: IE9-11+
        // Style of cloned element affects source element cloned (#8908)
        div.style.backgroundClip = "content-box";
        div.cloneNode(true).style.backgroundClip = "";
        support.clearCloneStyle = div.style.backgroundClip === "content-box";

        container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" + "padding:0;margin-top:1px;position:absolute";
        container.appendChild(div);

        // Executing both pixelPosition & boxSizingReliable tests require only one layout
        // so they're executed at the same time to save the second computation.
        function computeStyleTests() {
            div.style.cssText =
            // Support: Firefox<29, Android 2.3
            // Vendor-prefix box-sizing
            "-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" + "position:relative;display:block;" + "margin:auto;border:1px;padding:1px;" + "top:1%;width:50%";
            div.innerHTML = "";
            documentElement.appendChild(container);

            var divStyle = window.getComputedStyle(div);
            pixelPositionVal = divStyle.top !== "1%";
            reliableMarginLeftVal = divStyle.marginLeft === "2px";
            boxSizingReliableVal = divStyle.width === "4px";

            // Support: Android 4.0 - 4.3 only
            // Some styles come back with percentage values, even though they shouldn't
            div.style.marginRight = "50%";
            pixelMarginRightVal = divStyle.marginRight === "4px";

            documentElement.removeChild(container);
        }

        jQuery.extend(support, {
            pixelPosition: function() {

                // This test is executed only once but we still do memoizing
                // since we can use the boxSizingReliable pre-computing.
                // No need to check if the test was already performed, though.
                computeStyleTests();
                return pixelPositionVal;
            },
            boxSizingReliable: function() {
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return boxSizingReliableVal;
            },
            pixelMarginRight: function() {

                // Support: Android 4.0-4.3
                // We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
                // since that compresses better and they're computed together anyway.
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return pixelMarginRightVal;
            },
            reliableMarginLeft: function() {

                // Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
                if (boxSizingReliableVal == null) {
                    computeStyleTests();
                }
                return reliableMarginLeftVal;
            },
            reliableMarginRight: function() {

                // Support: Android 2.3
                // Check if div with explicit width and no margin-right incorrectly
                // gets computed margin-right based on width of container. (#3333)
                // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
                // This support function is only executed once so no memoizing is needed.
                var ret, marginDiv = div.appendChild(document.createElement("div"));

                // Reset CSS: box-sizing; display; margin; border; padding
                marginDiv.style.cssText = div.style.cssText =
                // Support: Android 2.3
                // Vendor-prefix box-sizing
                "-webkit-box-sizing:content-box;box-sizing:content-box;" + "display:block;margin:0;border:0;padding:0";
                marginDiv.style.marginRight = marginDiv.style.width = "0";
                div.style.width = "1px";
                documentElement.appendChild(container);

                ret = !parseFloat(window.getComputedStyle(marginDiv).marginRight);

                documentElement.removeChild(container);
                div.removeChild(marginDiv);

                return ret;
            }
        });
    }
    )();

    function curCSS(elem, name, computed) {
        var width, minWidth, maxWidth, ret, style = elem.style;

        computed = computed || getStyles(elem);
        ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;

        // Support: Opera 12.1x only
        // Fall back to style even without computed
        // computed is undefined for elems on document fragments
        if ((ret === "" || ret === undefined) && !jQuery.contains(elem.ownerDocument, elem)) {
            ret = jQuery.style(elem, name);
        }

        // Support: IE9
        // getPropertyValue is only needed for .css('filter') (#12537)
        if (computed) {

            // A tribute to the "awesome hack by Dean Edwards"
            // Android Browser returns percentage for some values,
            // but width seems to be reliably pixels.
            // This is against the CSSOM draft spec:
            // http://dev.w3.org/csswg/cssom/#resolved-values
            if (!support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name)) {

                // Remember the original values
                width = style.width;
                minWidth = style.minWidth;
                maxWidth = style.maxWidth;

                // Put in the new values to get a computed value out
                style.minWidth = style.maxWidth = style.width = ret;
                ret = computed.width;

                // Revert the changed values
                style.width = width;
                style.minWidth = minWidth;
                style.maxWidth = maxWidth;
            }
        }

        return ret !== undefined ?
        // Support: IE9-11+
        // IE returns zIndex value as an integer.
        ret + "" : ret;
    }

    function addGetHookIf(conditionFn, hookFn) {

        // Define the hook, we'll check on the first run if it's really needed.
        return {
            get: function() {
                if (conditionFn()) {

                    // Hook not needed (or it's not possible to use it due
                    // to missing dependency), remove it.
                    delete this.get;
                    return;
                }

                // Hook needed; redefine it so that the support test is not executed again.
                return (this.get = hookFn).apply(this, arguments);
            }
        };
    }

    var
    // Swappable if display is none or starts with table
    // except "table", "table-cell", or "table-caption"
    // See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
    rdisplayswap = /^(none|table(?!-c[ea]).+)/
      ,
    cssShow = {
        position: "absolute",
        visibility: "hidden",
        display: "block"
    }
      , cssNormalTransform = {
        letterSpacing: "0",
        fontWeight: "400"
    }
      ,
    cssPrefixes = ["Webkit", "O", "Moz", "ms"]
      , emptyStyle = document.createElement("div").style;

    // Return a css property mapped to a potentially vendor prefixed property
    function vendorPropName(name) {

        // Shortcut for names that are not vendor prefixed
        if (name in emptyStyle) {
            return name;
        }

        // Check for vendor prefixed names
        var capName = name[0].toUpperCase() + name.slice(1)
          , i = cssPrefixes.length;

        while (i--) {
            name = cssPrefixes[i] + capName;
            if (name in emptyStyle) {
                return name;
            }
        }
    }

    function setPositiveNumber(elem, value, subtract) {

        // Any relative (+/-) values have already been
        // normalized at this point
        var matches = rcssNum.exec(value);
        return matches ?
        // Guard against undefined "subtract", e.g., when used as in cssHooks
        Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value;
    }

    function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
        var i = extra === (isBorderBox ? "border" : "content") ?
        // If we already have the right measurement, avoid augmentation
        4 :
        // Otherwise initialize for horizontal or vertical properties
        name === "width" ? 1 : 0
          ,
        val = 0;

        for (; i < 4; i += 2) {

            // Both box models exclude margin, so add it if we want it
            if (extra === "margin") {
                val += jQuery.css(elem, extra + cssExpand[i], true, styles);
            }

            if (isBorderBox) {

                // border-box includes padding, so remove it if we want content
                if (extra === "content") {
                    val -= jQuery.css(elem, "padding" + cssExpand[i], true, styles);
                }

                // At this point, extra isn't border nor margin, so remove border
                if (extra !== "margin") {
                    val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            } else {

                // At this point, extra isn't content, so add padding
                val += jQuery.css(elem, "padding" + cssExpand[i], true, styles);

                // At this point, extra isn't content nor padding, so add border
                if (extra !== "padding") {
                    val += jQuery.css(elem, "border" + cssExpand[i] + "Width", true, styles);
                }
            }
        }

        return val;
    }

    function getWidthOrHeight(elem, name, extra) {

        // Start with offset property, which is equivalent to the border-box value
        var valueIsBorderBox = true
          , val = name === "width" ? elem.offsetWidth : elem.offsetHeight
          , styles = getStyles(elem)
          , isBorderBox = jQuery.css(elem, "boxSizing", false, styles) === "border-box";

        // Some non-html elements return undefined for offsetWidth, so check for null/undefined
        // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
        // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
        if (val <= 0 || val == null) {

            // Fall back to computed then uncomputed css if necessary
            val = curCSS(elem, name, styles);
            if (val < 0 || val == null) {
                val = elem.style[name];
            }

            // Computed unit is not pixels. Stop here and return.
            if (rnumnonpx.test(val)) {
                return val;
            }

            // Check for style in case a browser which returns unreliable values
            // for getComputedStyle silently falls back to the reliable elem.style
            valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);

            // Normalize "", auto, and prepare for extra
            val = parseFloat(val) || 0;
        }

        // Use the active box-sizing model to add/subtract irrelevant styles
        return (val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles)) + "px";
    }

    function showHide(elements, show) {
        var display, elem, hidden, values = [], index = 0, length = elements.length;

        for (; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }

            values[index] = dataPriv.get(elem, "olddisplay");
            display = elem.style.display;
            if (show) {

                // Reset the inline display of this element to learn if it is
                // being hidden by cascaded rules or not
                if (!values[index] && display === "none") {
                    elem.style.display = "";
                }

                // Set elements which have been overridden with display: none
                // in a stylesheet to whatever the default browser style is
                // for such an element
                if (elem.style.display === "" && isHidden(elem)) {
                    values[index] = dataPriv.access(elem, "olddisplay", defaultDisplay(elem.nodeName));
                }
            } else {
                hidden = isHidden(elem);

                if (display !== "none" || !hidden) {
                    dataPriv.set(elem, "olddisplay", hidden ? display : jQuery.css(elem, "display"));
                }
            }
        }

        // Set the display of most of the elements in a second loop
        // to avoid the constant reflow
        for (index = 0; index < length; index++) {
            elem = elements[index];
            if (!elem.style) {
                continue;
            }
            if (!show || elem.style.display === "none" || elem.style.display === "") {
                elem.style.display = show ? values[index] || "" : "none";
            }
        }

        return elements;
    }

    jQuery.extend({

        // Add in style property hooks for overriding the default
        // behavior of getting and setting a style property
        cssHooks: {
            opacity: {
                get: function(elem, computed) {
                    if (computed) {

                        // We should always get a number back from opacity
                        var ret = curCSS(elem, "opacity");
                        return ret === "" ? "1" : ret;
                    }
                }
            }
        },

        // Don't automatically add "px" to these possibly-unitless properties
        cssNumber: {
            "animationIterationCount": true,
            "columnCount": true,
            "fillOpacity": true,
            "flexGrow": true,
            "flexShrink": true,
            "fontWeight": true,
            "lineHeight": true,
            "opacity": true,
            "order": true,
            "orphans": true,
            "widows": true,
            "zIndex": true,
            "zoom": true
        },

        // Add in properties whose names you wish to fix before
        // setting or getting the value
        cssProps: {
            "float": "cssFloat"
        },

        // Get and set the style property on a DOM Node
        style: function(elem, name, value, extra) {

            // Don't set styles on text and comment nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
                return;
            }

            // Make sure that we're working with the right name
            var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;

            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

            // Gets hook for the prefixed version, then unprefixed version
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // Check if we're setting a value
            if (value !== undefined) {
                type = typeof value;

                // Convert "+=" or "-=" to relative numbers (#7345)
                if (type === "string" && (ret = rcssNum.exec(value)) && ret[1]) {
                    value = adjustCSS(elem, name, ret);

                    // Fixes bug #9237
                    type = "number";
                }

                // Make sure that null and NaN values aren't set (#7116)
                if (value == null || value !== value) {
                    return;
                }

                // If a number was passed in, add the unit (except for certain CSS properties)
                if (type === "number") {
                    value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px");
                }

                // Support: IE9-11+
                // background-* props affect original clone's values
                if (!support.clearCloneStyle && value === "" && name.indexOf("background") === 0) {
                    style[name] = "inherit";
                }

                // If a hook was provided, use that value, otherwise just set the specified value
                if (!hooks || !("set"in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {

                    style[name] = value;
                }

            } else {

                // If a hook was provided get the non-computed value from there
                if (hooks && "get"in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {

                    return ret;
                }

                // Otherwise just get the value from the style object
                return style[name];
            }
        },

        css: function(elem, name, extra, styles) {
            var val, num, hooks, origName = jQuery.camelCase(name);

            // Make sure that we're working with the right name
            name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName);

            // Try prefixed name followed by the unprefixed name
            hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];

            // If a hook was provided get the computed value from there
            if (hooks && "get"in hooks) {
                val = hooks.get(elem, true, extra);
            }

            // Otherwise, if a way to get the computed value exists, use that
            if (val === undefined) {
                val = curCSS(elem, name, styles);
            }

            // Convert "normal" to computed value
            if (val === "normal" && name in cssNormalTransform) {
                val = cssNormalTransform[name];
            }

            // Make numeric if forced or a qualifier was provided and val looks numeric
            if (extra === "" || extra) {
                num = parseFloat(val);
                return extra === true || isFinite(num) ? num || 0 : val;
            }
            return val;
        }
    });

    jQuery.each(["height", "width"], function(i, name) {
        jQuery.cssHooks[name] = {
            get: function(elem, computed, extra) {
                if (computed) {

                    // Certain elements can have dimension info if we invisibly show them
                    // but it must have a current display style that would benefit
                    return rdisplayswap.test(jQuery.css(elem, "display")) && elem.offsetWidth === 0 ? swap(elem, cssShow, function() {
                        return getWidthOrHeight(elem, name, extra);
                    }) : getWidthOrHeight(elem, name, extra);
                }
            },

            set: function(elem, value, extra) {
                var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, jQuery.css(elem, "boxSizing", false, styles) === "border-box", styles);

                // Convert to pixels if value adjustment is needed
                if (subtract && (matches = rcssNum.exec(value)) && (matches[3] || "px") !== "px") {

                    elem.style[name] = value;
                    value = jQuery.css(elem, name);
                }

                return setPositiveNumber(elem, value, subtract);
            }
        };
    });

    jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function(elem, computed) {
        if (computed) {
            return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
                marginLeft: 0
            }, function() {
                return elem.getBoundingClientRect().left;
            })) + "px";
        }
    });

    // Support: Android 2.3
    jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
        if (computed) {
            return swap(elem, {
                "display": "inline-block"
            }, curCSS, [elem, "marginRight"]);
        }
    });

    // These hooks are used by animate to expand properties
    jQuery.each({
        margin: "",
        padding: "",
        border: "Width"
    }, function(prefix, suffix) {
        jQuery.cssHooks[prefix + suffix] = {
            expand: function(value) {
                var i = 0
                  , expanded = {}
                  ,
                // Assumes a single number if not a string
                parts = typeof value === "string" ? value.split(" ") : [value];

                for (; i < 4; i++) {
                    expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                }

                return expanded;
            }
        };

        if (!rmargin.test(prefix)) {
            jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
        }
    });

    jQuery.fn.extend({
        css: function(name, value) {
            return access(this, function(elem, name, value) {
                var styles, len, map = {}, i = 0;

                if (jQuery.isArray(name)) {
                    styles = getStyles(elem);
                    len = name.length;

                    for (; i < len; i++) {
                        map[name[i]] = jQuery.css(elem, name[i], false, styles);
                    }

                    return map;
                }

                return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
            }, name, value, arguments.length > 1);
        },
        show: function() {
            return showHide(this, true);
        },
        hide: function() {
            return showHide(this);
        },
        toggle: function(state) {
            if (typeof state === "boolean") {
                return state ? this.show() : this.hide();
            }

            return this.each(function() {
                if (isHidden(this)) {
                    jQuery(this).show();
                } else {
                    jQuery(this).hide();
                }
            });
        }
    });

    function Tween(elem, options, prop, end, easing) {
        return new Tween.prototype.init(elem,options,prop,end,easing);
    }
    jQuery.Tween = Tween;

    Tween.prototype = {
        constructor: Tween,
        init: function(elem, options, prop, end, easing, unit) {
            this.elem = elem;
            this.prop = prop;
            this.easing = easing || jQuery.easing._default;
            this.options = options;
            this.start = this.now = this.cur();
            this.end = end;
            this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px");
        },
        cur: function() {
            var hooks = Tween.propHooks[this.prop];

            return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
        },
        run: function(percent) {
            var eased, hooks = Tween.propHooks[this.prop];

            if (this.options.duration) {
                this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
            } else {
                this.pos = eased = percent;
            }
            this.now = (this.end - this.start) * eased + this.start;

            if (this.options.step) {
                this.options.step.call(this.elem, this.now, this);
            }

            if (hooks && hooks.set) {
                hooks.set(this);
            } else {
                Tween.propHooks._default.set(this);
            }
            return this;
        }
    };

    Tween.prototype.init.prototype = Tween.prototype;

    Tween.propHooks = {
        _default: {
            get: function(tween) {
                var result;

                // Use a property on the element directly when it is not a DOM element,
                // or when there is no matching style property that exists.
                if (tween.elem.nodeType !== 1 || tween.elem[tween.prop] != null && tween.elem.style[tween.prop] == null) {
                    return tween.elem[tween.prop];
                }

                // Passing an empty string as a 3rd parameter to .css will automatically
                // attempt a parseFloat and fallback to a string if the parse fails.
                // Simple values such as "10px" are parsed to Float;
                // complex values such as "rotate(1rad)" are returned as-is.
                result = jQuery.css(tween.elem, tween.prop, "");

                // Empty strings, null, undefined and "auto" are converted to 0.
                return !result || result === "auto" ? 0 : result;
            },
            set: function(tween) {

                // Use step hook for back compat.
                // Use cssHook if its there.
                // Use .style if available and use plain properties where available.
                if (jQuery.fx.step[tween.prop]) {
                    jQuery.fx.step[tween.prop](tween);
                } else if (tween.elem.nodeType === 1 && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
                    jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
                } else {
                    tween.elem[tween.prop] = tween.now;
                }
            }
        }
    };

    // Support: IE9
    // Panic based approach to setting things on disconnected nodes
    Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
        set: function(tween) {
            if (tween.elem.nodeType && tween.elem.parentNode) {
                tween.elem[tween.prop] = tween.now;
            }
        }
    };

    jQuery.easing = {
        linear: function(p) {
            return p;
        },
        swing: function(p) {
            return 0.5 - Math.cos(p * Math.PI) / 2;
        },
        _default: "swing"
    };

    jQuery.fx = Tween.prototype.init;

    // Back Compat <1.8 extension point
    jQuery.fx.step = {};

    var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;

    // Animations created synchronously will run synchronously
    function createFxNow() {
        window.setTimeout(function() {
            fxNow = undefined;
        });
        return (fxNow = jQuery.now());
    }

    // Generate parameters to create a standard animation
    function genFx(type, includeWidth) {
        var which, i = 0, attrs = {
            height: type
        };

        // If we include width, step value is 1 to do all cssExpand values,
        // otherwise step value is 2 to skip over Left and Right
        includeWidth = includeWidth ? 1 : 0;
        for (; i < 4; i += 2 - includeWidth) {
            which = cssExpand[i];
            attrs["margin" + which] = attrs["padding" + which] = type;
        }

        if (includeWidth) {
            attrs.opacity = attrs.width = type;
        }

        return attrs;
    }

    function createTween(value, prop, animation) {
        var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length;
        for (; index < length; index++) {
            if ((tween = collection[index].call(animation, prop, value))) {

                // We're done with this property
                return tween;
            }
        }
    }

    function defaultPrefilter(elem, props, opts) {
        /* jshint validthis: true */
        var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = dataPriv.get(elem, "fxshow");

        // Handle queue: false promises
        if (!opts.queue) {
            hooks = jQuery._queueHooks(elem, "fx");
            if (hooks.unqueued == null) {
                hooks.unqueued = 0;
                oldfire = hooks.empty.fire;
                hooks.empty.fire = function() {
                    if (!hooks.unqueued) {
                        oldfire();
                    }
                }
                ;
            }
            hooks.unqueued++;

            anim.always(function() {

                // Ensure the complete handler is called before this completes
                anim.always(function() {
                    hooks.unqueued--;
                    if (!jQuery.queue(elem, "fx").length) {
                        hooks.empty.fire();
                    }
                });
            });
        }

        // Height/width overflow pass
        if (elem.nodeType === 1 && ("height"in props || "width"in props)) {

            // Make sure that nothing sneaks out
            // Record all 3 overflow attributes because IE9-10 do not
            // change the overflow attribute when overflowX and
            // overflowY are set to the same value
            opts.overflow = [style.overflow, style.overflowX, style.overflowY];

            // Set display property to inline-block for height/width
            // animations on inline elements that are having width/height animated
            display = jQuery.css(elem, "display");

            // Test default display if display is currently "none"
            checkDisplay = display === "none" ? dataPriv.get(elem, "olddisplay") || defaultDisplay(elem.nodeName) : display;

            if (checkDisplay === "inline" && jQuery.css(elem, "float") === "none") {
                style.display = "inline-block";
            }
        }

        if (opts.overflow) {
            style.overflow = "hidden";
            anim.always(function() {
                style.overflow = opts.overflow[0];
                style.overflowX = opts.overflow[1];
                style.overflowY = opts.overflow[2];
            });
        }

        // show/hide pass
        for (prop in props) {
            value = props[prop];
            if (rfxtypes.exec(value)) {
                delete props[prop];
                toggle = toggle || value === "toggle";
                if (value === (hidden ? "hide" : "show")) {

                    // If there is dataShow left over from a stopped hide or show
                    // and we are going to proceed with show, we should pretend to be hidden
                    if (value === "show" && dataShow && dataShow[prop] !== undefined) {
                        hidden = true;
                    } else {
                        continue;
                    }
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);

                // Any non-fx value stops us from restoring the original display value
            } else {
                display = undefined;
            }
        }

        if (!jQuery.isEmptyObject(orig)) {
            if (dataShow) {
                if ("hidden"in dataShow) {
                    hidden = dataShow.hidden;
                }
            } else {
                dataShow = dataPriv.access(elem, "fxshow", {});
            }

            // Store state if its toggle - enables .stop().toggle() to "reverse"
            if (toggle) {
                dataShow.hidden = !hidden;
            }
            if (hidden) {
                jQuery(elem).show();
            } else {
                anim.done(function() {
                    jQuery(elem).hide();
                });
            }
            anim.done(function() {
                var prop;

                dataPriv.remove(elem, "fxshow");
                for (prop in orig) {
                    jQuery.style(elem, prop, orig[prop]);
                }
            });
            for (prop in orig) {
                tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);

                if (!(prop in dataShow)) {
                    dataShow[prop] = tween.start;
                    if (hidden) {
                        tween.end = tween.start;
                        tween.start = prop === "width" || prop === "height" ? 1 : 0;
                    }
                }
            }

            // If this is a noop like .hide().hide(), restore an overwritten display value
        } else if ((display === "none" ? defaultDisplay(elem.nodeName) : display) === "inline") {
            style.display = display;
        }
    }

    function propFilter(props, specialEasing) {
        var index, name, easing, value, hooks;

        // camelCase, specialEasing and expand cssHook pass
        for (index in props) {
            name = jQuery.camelCase(index);
            easing = specialEasing[name];
            value = props[index];
            if (jQuery.isArray(value)) {
                easing = value[1];
                value = props[index] = value[0];
            }

            if (index !== name) {
                props[name] = value;
                delete props[index];
            }

            hooks = jQuery.cssHooks[name];
            if (hooks && "expand"in hooks) {
                value = hooks.expand(value);
                delete props[name];

                // Not quite $.extend, this won't overwrite existing keys.
                // Reusing 'index' because we have the correct "name"
                for (index in value) {
                    if (!(index in props)) {
                        props[index] = value[index];
                        specialEasing[index] = easing;
                    }
                }
            } else {
                specialEasing[name] = easing;
            }
        }
    }

    function Animation(elem, properties, options) {
        var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function() {

            // Don't match elem in the :animated selector
            delete tick.elem;
        }), tick = function() {
            if (stopped) {
                return false;
            }
            var currentTime = fxNow || createFxNow()
              , remaining = Math.max(0, animation.startTime + animation.duration - currentTime)
              ,
            // Support: Android 2.3
            // Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
            temp = remaining / animation.duration || 0
              , percent = 1 - temp
              , index = 0
              , length = animation.tweens.length;

            for (; index < length; index++) {
                animation.tweens[index].run(percent);
            }

            deferred.notifyWith(elem, [animation, percent, remaining]);

            if (percent < 1 && length) {
                return remaining;
            } else {
                deferred.resolveWith(elem, [animation]);
                return false;
            }
        }, animation = deferred.promise({
            elem: elem,
            props: jQuery.extend({}, properties),
            opts: jQuery.extend(true, {
                specialEasing: {},
                easing: jQuery.easing._default
            }, options),
            originalProperties: properties,
            originalOptions: options,
            startTime: fxNow || createFxNow(),
            duration: options.duration,
            tweens: [],
            createTween: function(prop, end) {
                var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                animation.tweens.push(tween);
                return tween;
            },
            stop: function(gotoEnd) {
                var index = 0
                  ,
                // If we are going to the end, we want to run all the tweens
                // otherwise we skip this part
                length = gotoEnd ? animation.tweens.length : 0;
                if (stopped) {
                    return this;
                }
                stopped = true;
                for (; index < length; index++) {
                    animation.tweens[index].run(1);
                }

                // Resolve when we played the last frame; otherwise, reject
                if (gotoEnd) {
                    deferred.notifyWith(elem, [animation, 1, 0]);
                    deferred.resolveWith(elem, [animation, gotoEnd]);
                } else {
                    deferred.rejectWith(elem, [animation, gotoEnd]);
                }
                return this;
            }
        }), props = animation.props;

        propFilter(props, animation.opts.specialEasing);

        for (; index < length; index++) {
            result = Animation.prefilters[index].call(animation, elem, props, animation.opts);
            if (result) {
                if (jQuery.isFunction(result.stop)) {
                    jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result);
                }
                return result;
            }
        }

        jQuery.map(props, createTween, animation);

        if (jQuery.isFunction(animation.opts.start)) {
            animation.opts.start.call(elem, animation);
        }

        jQuery.fx.timer(jQuery.extend(tick, {
            elem: elem,
            anim: animation,
            queue: animation.opts.queue
        }));

        // attach callbacks from options
        return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
    }

    jQuery.Animation = jQuery.extend(Animation, {
        tweeners: {
            "*": [function(prop, value) {
                var tween = this.createTween(prop, value);
                adjustCSS(tween.elem, prop, rcssNum.exec(value), tween);
                return tween;
            }
            ]
        },

        tweener: function(props, callback) {
            if (jQuery.isFunction(props)) {
                callback = props;
                props = ["*"];
            } else {
                props = props.match(rnotwhite);
            }

            var prop, index = 0, length = props.length;

            for (; index < length; index++) {
                prop = props[index];
                Animation.tweeners[prop] = Animation.tweeners[prop] || [];
                Animation.tweeners[prop].unshift(callback);
            }
        },

        prefilters: [defaultPrefilter],

        prefilter: function(callback, prepend) {
            if (prepend) {
                Animation.prefilters.unshift(callback);
            } else {
                Animation.prefilters.push(callback);
            }
        }
    });

    jQuery.speed = function(speed, easing, fn) {
        var opt = speed && typeof speed === "object" ? jQuery.extend({}, speed) : {
            complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
            duration: speed,
            easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
        };

        opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;

        // Normalize opt.queue - true/undefined/null -> "fx"
        if (opt.queue == null || opt.queue === true) {
            opt.queue = "fx";
        }

        // Queueing
        opt.old = opt.complete;

        opt.complete = function() {
            if (jQuery.isFunction(opt.old)) {
                opt.old.call(this);
            }

            if (opt.queue) {
                jQuery.dequeue(this, opt.queue);
            }
        }
        ;

        return opt;
    }
    ;

    jQuery.fn.extend({
        fadeTo: function(speed, to, easing, callback) {

            // Show any hidden elements after setting opacity to 0
            return this.filter(isHidden).css("opacity", 0).show()
            // Animate to the value specified
            .end().animate({
                opacity: to
            }, speed, easing, callback);
        },
        animate: function(prop, speed, easing, callback) {
            var empty = jQuery.isEmptyObject(prop)
              , optall = jQuery.speed(speed, easing, callback)
              , doAnimation = function() {

                // Operate on a copy of prop so per-property easing won't be lost
                var anim = Animation(this, jQuery.extend({}, prop), optall);

                // Empty animations, or finishing resolves immediately
                if (empty || dataPriv.get(this, "finish")) {
                    anim.stop(true);
                }
            };
            doAnimation.finish = doAnimation;

            return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
        },
        stop: function(type, clearQueue, gotoEnd) {
            var stopQueue = function(hooks) {
                var stop = hooks.stop;
                delete hooks.stop;
                stop(gotoEnd);
            };

            if (typeof type !== "string") {
                gotoEnd = clearQueue;
                clearQueue = type;
                type = undefined;
            }
            if (clearQueue && type !== false) {
                this.queue(type || "fx", []);
            }

            return this.each(function() {
                var dequeue = true
                  , index = type != null && type + "queueHooks"
                  , timers = jQuery.timers
                  , data = dataPriv.get(this);

                if (index) {
                    if (data[index] && data[index].stop) {
                        stopQueue(data[index]);
                    }
                } else {
                    for (index in data) {
                        if (data[index] && data[index].stop && rrun.test(index)) {
                            stopQueue(data[index]);
                        }
                    }
                }

                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && (type == null || timers[index].queue === type)) {

                        timers[index].anim.stop(gotoEnd);
                        dequeue = false;
                        timers.splice(index, 1);
                    }
                }

                // Start the next in the queue if the last step wasn't forced.
                // Timers currently will call their complete callbacks, which
                // will dequeue but only if they were gotoEnd.
                if (dequeue || !gotoEnd) {
                    jQuery.dequeue(this, type);
                }
            });
        },
        finish: function(type) {
            if (type !== false) {
                type = type || "fx";
            }
            return this.each(function() {
                var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;

                // Enable finishing flag on private data
                data.finish = true;

                // Empty the queue first
                jQuery.queue(this, type, []);

                if (hooks && hooks.stop) {
                    hooks.stop.call(this, true);
                }

                // Look for any active animations, and finish them
                for (index = timers.length; index--; ) {
                    if (timers[index].elem === this && timers[index].queue === type) {
                        timers[index].anim.stop(true);
                        timers.splice(index, 1);
                    }
                }

                // Look for any animations in the old queue and finish them
                for (index = 0; index < length; index++) {
                    if (queue[index] && queue[index].finish) {
                        queue[index].finish.call(this);
                    }
                }

                // Turn off finishing flag
                delete data.finish;
            });
        }
    });

    jQuery.each(["toggle", "show", "hide"], function(i, name) {
        var cssFn = jQuery.fn[name];
        jQuery.fn[name] = function(speed, easing, callback) {
            return speed == null || typeof speed === "boolean" ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
        }
        ;
    });

    // Generate shortcuts for custom animations
    jQuery.each({
        slideDown: genFx("show"),
        slideUp: genFx("hide"),
        slideToggle: genFx("toggle"),
        fadeIn: {
            opacity: "show"
        },
        fadeOut: {
            opacity: "hide"
        },
        fadeToggle: {
            opacity: "toggle"
        }
    }, function(name, props) {
        jQuery.fn[name] = function(speed, easing, callback) {
            return this.animate(props, speed, easing, callback);
        }
        ;
    });

    jQuery.timers = [];
    jQuery.fx.tick = function() {
        var timer, i = 0, timers = jQuery.timers;

        fxNow = jQuery.now();

        for (; i < timers.length; i++) {
            timer = timers[i];

            // Checks the timer has not already been removed
            if (!timer() && timers[i] === timer) {
                timers.splice(i--, 1);
            }
        }

        if (!timers.length) {
            jQuery.fx.stop();
        }
        fxNow = undefined;
    }
    ;

    jQuery.fx.timer = function(timer) {
        jQuery.timers.push(timer);
        if (timer()) {
            jQuery.fx.start();
        } else {
            jQuery.timers.pop();
        }
    }
    ;

    jQuery.fx.interval = 13;
    jQuery.fx.start = function() {
        if (!timerId) {
            timerId = window.setInterval(jQuery.fx.tick, jQuery.fx.interval);
        }
    }
    ;

    jQuery.fx.stop = function() {
        window.clearInterval(timerId);

        timerId = null;
    }
    ;

    jQuery.fx.speeds = {
        slow: 600,
        fast: 200,

        // Default speed
        _default: 400
    };

    // Based off of the plugin by Clint Helfers, with permission.
    // http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
    jQuery.fn.delay = function(time, type) {
        time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
        type = type || "fx";

        return this.queue(type, function(next, hooks) {
            var timeout = window.setTimeout(next, time);
            hooks.stop = function() {
                window.clearTimeout(timeout);
            }
            ;
        });
    }
    ;

    (function() {
        var input = document.createElement("input")
          , select = document.createElement("select")
          , opt = select.appendChild(document.createElement("option"));

        input.type = "checkbox";

        // Support: iOS<=5.1, Android<=4.2+
        // Default value for a checkbox should be "on"
        support.checkOn = input.value !== "";

        // Support: IE<=11+
        // Must access selectedIndex to make default options select
        support.optSelected = opt.selected;

        // Support: Android<=2.3
        // Options inside disabled selects are incorrectly marked as disabled
        select.disabled = true;
        support.optDisabled = !opt.disabled;

        // Support: IE<=11+
        // An input loses its value after becoming a radio
        input = document.createElement("input");
        input.value = "t";
        input.type = "radio";
        support.radioValue = input.value === "t";
    }
    )();

    var boolHook, attrHandle = jQuery.expr.attrHandle;

    jQuery.fn.extend({
        attr: function(name, value) {
            return access(this, jQuery.attr, name, value, arguments.length > 1);
        },

        removeAttr: function(name) {
            return this.each(function() {
                jQuery.removeAttr(this, name);
            });
        }
    });

    jQuery.extend({
        attr: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;

            // Don't get/set attributes on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }

            // All attributes are lowercase
            // Grab necessary hook if one is defined
            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                name = name.toLowerCase();
                hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : undefined);
            }

            if (value !== undefined) {
                if (value === null) {
                    jQuery.removeAttr(elem, name);
                    return;
                }

                if (hooks && "set"in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                elem.setAttribute(name, value + "");
                return value;
            }

            if (hooks && "get"in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            ret = jQuery.find.attr(elem, name);

            // Non-existent attributes return null, we normalize to undefined
            return ret == null ? undefined : ret;
        },

        attrHooks: {
            type: {
                set: function(elem, value) {
                    if (!support.radioValue && value === "radio" && jQuery.nodeName(elem, "input")) {
                        var val = elem.value;
                        elem.setAttribute("type", value);
                        if (val) {
                            elem.value = val;
                        }
                        return value;
                    }
                }
            }
        },

        removeAttr: function(elem, value) {
            var name, propName, i = 0, attrNames = value && value.match(rnotwhite);

            if (attrNames && elem.nodeType === 1) {
                while ((name = attrNames[i++])) {
                    propName = jQuery.propFix[name] || name;

                    // Boolean attributes get special treatment (#10870)
                    if (jQuery.expr.match.bool.test(name)) {

                        // Set corresponding property to false
                        elem[propName] = false;
                    }

                    elem.removeAttribute(name);
                }
            }
        }
    });

    // Hooks for boolean attributes
    boolHook = {
        set: function(elem, value, name) {
            if (value === false) {

                // Remove boolean attributes when set to false
                jQuery.removeAttr(elem, name);
            } else {
                elem.setAttribute(name, name);
            }
            return name;
        }
    };
    jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
        var getter = attrHandle[name] || jQuery.find.attr;

        attrHandle[name] = function(elem, name, isXML) {
            var ret, handle;
            if (!isXML) {

                // Avoid an infinite loop by temporarily removing this function from the getter
                handle = attrHandle[name];
                attrHandle[name] = ret;
                ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
                attrHandle[name] = handle;
            }
            return ret;
        }
        ;
    });

    var rfocusable = /^(?:input|select|textarea|button)$/i
      , rclickable = /^(?:a|area)$/i;

    jQuery.fn.extend({
        prop: function(name, value) {
            return access(this, jQuery.prop, name, value, arguments.length > 1);
        },

        removeProp: function(name) {
            return this.each(function() {
                delete this[jQuery.propFix[name] || name];
            });
        }
    });

    jQuery.extend({
        prop: function(elem, name, value) {
            var ret, hooks, nType = elem.nodeType;

            // Don't get/set properties on text, comment and attribute nodes
            if (nType === 3 || nType === 8 || nType === 2) {
                return;
            }

            if (nType !== 1 || !jQuery.isXMLDoc(elem)) {

                // Fix name and attach hooks
                name = jQuery.propFix[name] || name;
                hooks = jQuery.propHooks[name];
            }

            if (value !== undefined) {
                if (hooks && "set"in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
                    return ret;
                }

                return (elem[name] = value);
            }

            if (hooks && "get"in hooks && (ret = hooks.get(elem, name)) !== null) {
                return ret;
            }

            return elem[name];
        },

        propHooks: {
            tabIndex: {
                get: function(elem) {

                    // elem.tabIndex doesn't always return the
                    // correct value when it hasn't been explicitly set
                    // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
                    // Use proper attribute retrieval(#12072)
                    var tabindex = jQuery.find.attr(elem, "tabindex");

                    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
                }
            }
        },

        propFix: {
            "for": "htmlFor",
            "class": "className"
        }
    });

    // Support: IE <=11 only
    // Accessing the selectedIndex property
    // forces the browser to respect setting selected
    // on the option
    // The getter ensures a default option is selected
    // when in an optgroup
    if (!support.optSelected) {
        jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                if (parent && parent.parentNode) {
                    parent.parentNode.selectedIndex;
                }
                return null;
            },
            set: function(elem) {
                var parent = elem.parentNode;
                if (parent) {
                    parent.selectedIndex;

                    if (parent.parentNode) {
                        parent.parentNode.selectedIndex;
                    }
                }
            }
        };
    }

    jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function() {
        jQuery.propFix[this.toLowerCase()] = this;
    });

    var rclass = /[\t\r\n\f]/g;

    function getClass(elem) {
        return elem.getAttribute && elem.getAttribute("class") || "";
    }

    jQuery.fn.extend({
        addClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;

            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)));
                });
            }

            if (typeof value === "string" && value) {
                classes = value.match(rnotwhite) || [];

                while ((elem = this[i++])) {
                    curValue = getClass(elem);
                    cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {
                            if (cur.indexOf(" " + clazz + " ") < 0) {
                                cur += clazz + " ";
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        removeClass: function(value) {
            var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;

            if (jQuery.isFunction(value)) {
                return this.each(function(j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)));
                });
            }

            if (!arguments.length) {
                return this.attr("class", "");
            }

            if (typeof value === "string" && value) {
                classes = value.match(rnotwhite) || [];

                while ((elem = this[i++])) {
                    curValue = getClass(elem);

                    // This expression is here for better compressibility (see addClass)
                    cur = elem.nodeType === 1 && (" " + curValue + " ").replace(rclass, " ");

                    if (cur) {
                        j = 0;
                        while ((clazz = classes[j++])) {

                            // Remove *all* instances
                            while (cur.indexOf(" " + clazz + " ") > -1) {
                                cur = cur.replace(" " + clazz + " ", " ");
                            }
                        }

                        // Only assign if different to avoid unneeded rendering.
                        finalValue = jQuery.trim(cur);
                        if (curValue !== finalValue) {
                            elem.setAttribute("class", finalValue);
                        }
                    }
                }
            }

            return this;
        },

        toggleClass: function(value, stateVal) {
            var type = typeof value;

            if (typeof stateVal === "boolean" && type === "string") {
                return stateVal ? this.addClass(value) : this.removeClass(value);
            }

            if (jQuery.isFunction(value)) {
                return this.each(function(i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal);
                });
            }

            return this.each(function() {
                var className, i, self, classNames;

                if (type === "string") {

                    // Toggle individual class names
                    i = 0;
                    self = jQuery(this);
                    classNames = value.match(rnotwhite) || [];

                    while ((className = classNames[i++])) {

                        // Check each className given, space separated list
                        if (self.hasClass(className)) {
                            self.removeClass(className);
                        } else {
                            self.addClass(className);
                        }
                    }

                    // Toggle whole class name
                } else if (value === undefined || type === "boolean") {
                    className = getClass(this);
                    if (className) {

                        // Store className if set
                        dataPriv.set(this, "__className__", className);
                    }

                    // If the element has a class name or if we're passed `false`,
                    // then remove the whole classname (if there was one, the above saved it).
                    // Otherwise bring back whatever was previously saved (if anything),
                    // falling back to the empty string if nothing was stored.
                    if (this.setAttribute) {
                        this.setAttribute("class", className || value === false ? "" : dataPriv.get(this, "__className__") || "");
                    }
                }
            });
        },

        hasClass: function(selector) {
            var className, elem, i = 0;

            className = " " + selector + " ";
            while ((elem = this[i++])) {
                if (elem.nodeType === 1 && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1) {
                    return true;
                }
            }

            return false;
        }
    });

    var rreturn = /\r/g
      , rspaces = /[\x20\t\r\n\f]+/g;

    jQuery.fn.extend({
        val: function(value) {
            var hooks, ret, isFunction, elem = this[0];

            if (!arguments.length) {
                if (elem) {
                    hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];

                    if (hooks && "get"in hooks && (ret = hooks.get(elem, "value")) !== undefined) {
                        return ret;
                    }

                    ret = elem.value;

                    return typeof ret === "string" ?
                    // Handle most common string cases
                    ret.replace(rreturn, "") :
                    // Handle cases where value is null/undef or number
                    ret == null ? "" : ret;
                }

                return;
            }

            isFunction = jQuery.isFunction(value);

            return this.each(function(i) {
                var val;

                if (this.nodeType !== 1) {
                    return;
                }

                if (isFunction) {
                    val = value.call(this, i, jQuery(this).val());
                } else {
                    val = value;
                }

                // Treat null/undefined as ""; convert numbers to string
                if (val == null) {
                    val = "";

                } else if (typeof val === "number") {
                    val += "";

                } else if (jQuery.isArray(val)) {
                    val = jQuery.map(val, function(value) {
                        return value == null ? "" : value + "";
                    });
                }

                hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];

                // If set returns undefined, fall back to normal setting
                if (!hooks || !("set"in hooks) || hooks.set(this, val, "value") === undefined) {
                    this.value = val;
                }
            });
        }
    });

    jQuery.extend({
        valHooks: {
            option: {
                get: function(elem) {

                    var val = jQuery.find.attr(elem, "value");
                    return val != null ? val :
                    // Support: IE10-11+
                    // option.text throws exceptions (#14686, #14858)
                    // Strip and collapse whitespace
                    // https://html.spec.whatwg.org/#strip-and-collapse-whitespace
                    jQuery.trim(jQuery.text(elem)).replace(rspaces, " ");
                }
            },
            select: {
                get: function(elem) {
                    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === "select-one" || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;

                    // Loop through all the selected options
                    for (; i < max; i++) {
                        option = options[i];

                        // IE8-9 doesn't update selected after form reset (#2551)
                        if ((option.selected || i === index) &&
                        // Don't return options that are disabled or in a disabled optgroup
                        (support.optDisabled ? !option.disabled : option.getAttribute("disabled") === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {

                            // Get the specific value for the option
                            value = jQuery(option).val();

                            // We don't need an array for one selects
                            if (one) {
                                return value;
                            }

                            // Multi-Selects return an array
                            values.push(value);
                        }
                    }

                    return values;
                },

                set: function(elem, value) {
                    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;

                    while (i--) {
                        option = options[i];
                        if (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) {
                            optionSet = true;
                        }
                    }

                    // Force browsers to behave consistently when non-matching value is set
                    if (!optionSet) {
                        elem.selectedIndex = -1;
                    }
                    return values;
                }
            }
        }
    });

    // Radios and checkboxes getter/setter
    jQuery.each(["radio", "checkbox"], function() {
        jQuery.valHooks[this] = {
            set: function(elem, value) {
                if (jQuery.isArray(value)) {
                    return (elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1);
                }
            }
        };
        if (!support.checkOn) {
            jQuery.valHooks[this].get = function(elem) {
                return elem.getAttribute("value") === null ? "on" : elem.value;
            }
            ;
        }
    });

    // Return jQuery for attributes-only inclusion

    var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

    jQuery.extend(jQuery.event, {

        trigger: function(event, data, elem, onlyHandlers) {

            var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];

            cur = tmp = elem = elem || document;

            // Don't do events on text and comment nodes
            if (elem.nodeType === 3 || elem.nodeType === 8) {
                return;
            }

            // focus/blur morphs to focusin/out; ensure we're not firing them right now
            if (rfocusMorph.test(type + jQuery.event.triggered)) {
                return;
            }

            if (type.indexOf(".") > -1) {

                // Namespaced trigger; create a regexp to match event type in handle()
                namespaces = type.split(".");
                type = namespaces.shift();
                namespaces.sort();
            }
            ontype = type.indexOf(":") < 0 && "on" + type;

            // Caller can pass in a jQuery.Event object, Object, or just an event type string
            event = event[jQuery.expando] ? event : new jQuery.Event(type,typeof event === "object" && event);

            // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
            event.isTrigger = onlyHandlers ? 2 : 3;
            event.namespace = namespaces.join(".");
            event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null;

            // Clean up the event in case it is being reused
            event.result = undefined;
            if (!event.target) {
                event.target = elem;
            }

            // Clone any incoming data and prepend the event, creating the handler arg list
            data = data == null ? [event] : jQuery.makeArray(data, [event]);

            // Allow special events to draw outside the lines
            special = jQuery.event.special[type] || {};
            if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
                return;
            }

            // Determine event propagation path in advance, per W3C events spec (#9951)
            // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
            if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {

                bubbleType = special.delegateType || type;
                if (!rfocusMorph.test(bubbleType + type)) {
                    cur = cur.parentNode;
                }
                for (; cur; cur = cur.parentNode) {
                    eventPath.push(cur);
                    tmp = cur;
                }

                // Only add window if we got to document (e.g., not plain obj or detached DOM)
                if (tmp === (elem.ownerDocument || document)) {
                    eventPath.push(tmp.defaultView || tmp.parentWindow || window);
                }
            }

            // Fire handlers on the event path
            i = 0;
            while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {

                event.type = i > 1 ? bubbleType : special.bindType || type;

                // jQuery handler
                handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle");
                if (handle) {
                    handle.apply(cur, data);
                }

                // Native handler
                handle = ontype && cur[ontype];
                if (handle && handle.apply && acceptData(cur)) {
                    event.result = handle.apply(cur, data);
                    if (event.result === false) {
                        event.preventDefault();
                    }
                }
            }
            event.type = type;

            // If nobody prevented the default action, do it now
            if (!onlyHandlers && !event.isDefaultPrevented()) {

                if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && acceptData(elem)) {

                    // Call a native DOM method on the target with the same name name as the event.
                    // Don't do default actions on window, that's where global variables be (#6170)
                    if (ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem)) {

                        // Don't re-trigger an onFOO event when we call its FOO() method
                        tmp = elem[ontype];

                        if (tmp) {
                            elem[ontype] = null;
                        }

                        // Prevent re-triggering of the same event, since we already bubbled it above
                        jQuery.event.triggered = type;
                        elem[type]();
                        jQuery.event.triggered = undefined;

                        if (tmp) {
                            elem[ontype] = tmp;
                        }
                    }
                }
            }

            return event.result;
        },

        // Piggyback on a donor event to simulate a different one
        // Used only for `focus(in | out)` events
        simulate: function(type, elem, event) {
            var e = jQuery.extend(new jQuery.Event(), event, {
                type: type,
                isSimulated: true
            });

            jQuery.event.trigger(e, null, elem);
        }

    });

    jQuery.fn.extend({

        trigger: function(type, data) {
            return this.each(function() {
                jQuery.event.trigger(type, data, this);
            });
        },
        triggerHandler: function(type, data) {
            var elem = this[0];
            if (elem) {
                return jQuery.event.trigger(type, data, elem, true);
            }
        }
    });

    jQuery.each(("blur focus focusin focusout load resize scroll unload click dblclick " + "mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " + "change select submit keydown keypress keyup error contextmenu").split(" "), function(i, name) {

        // Handle event binding
        jQuery.fn[name] = function(data, fn) {
            return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
        }
        ;
    });

    jQuery.fn.extend({
        hover: function(fnOver, fnOut) {
            return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
        }
    });

    support.focusin = "onfocusin"in window;

    // Support: Firefox
    // Firefox doesn't have focus(in | out) events
    // Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
    //
    // Support: Chrome, Safari
    // focus(in | out) events fire after focus & blur events,
    // which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
    // Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
    if (!support.focusin) {
        jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function(orig, fix) {

            // Attach a single capturing handler on the document while someone wants focusin/focusout
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event));
            };

            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this
                      , attaches = dataPriv.access(doc, fix);

                    if (!attaches) {
                        doc.addEventListener(orig, handler, true);
                    }
                    dataPriv.access(doc, fix, (attaches || 0) + 1);
                },
                teardown: function() {
                    var doc = this.ownerDocument || this
                      , attaches = dataPriv.access(doc, fix) - 1;

                    if (!attaches) {
                        doc.removeEventListener(orig, handler, true);
                        dataPriv.remove(doc, fix);

                    } else {
                        dataPriv.access(doc, fix, attaches);
                    }
                }
            };
        });
    }
    var location = window.location;

    var nonce = jQuery.now();

    var rquery = (/\?/);

    // Support: Android 2.3
    // Workaround failure to string-cast null input
    jQuery.parseJSON = function(data) {
        return JSON.parse(data + "");
    }
    ;

    // Cross-browser xml parsing
    jQuery.parseXML = function(data) {
        var xml;
        if (!data || typeof data !== "string") {
            return null;
        }

        // Support: IE9
        try {
            xml = (new window.DOMParser()).parseFromString(data, "text/xml");
        } catch (e) {
            xml = undefined;
        }

        if (!xml || xml.getElementsByTagName("parsererror").length) {
            jQuery.error("Invalid XML: " + data);
        }
        return xml;
    }
    ;

    var rhash = /#.*$/
      , rts = /([?&])_=[^&]*/
      , rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg
      ,
    // #7653, #8125, #8152: local protocol detection
    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/
      , rnoContent = /^(?:GET|HEAD)$/
      , rprotocol = /^\/\//
      ,
    /* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
    prefilters = {}
      ,
    /* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
    transports = {}
      ,
    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
    allTypes = "*/".concat("*")
      ,
    // Anchor tag for parsing the document origin
    originAnchor = document.createElement("a");
    originAnchor.href = location.href;

    // Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
    function addToPrefiltersOrTransports(structure) {

        // dataTypeExpression is optional and defaults to "*"
        return function(dataTypeExpression, func) {

            if (typeof dataTypeExpression !== "string") {
                func = dataTypeExpression;
                dataTypeExpression = "*";
            }

            var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];

            if (jQuery.isFunction(func)) {

                // For each dataType in the dataTypeExpression
                while ((dataType = dataTypes[i++])) {

                    // Prepend if requested
                    if (dataType[0] === "+") {
                        dataType = dataType.slice(1) || "*";
                        (structure[dataType] = structure[dataType] || []).unshift(func);

                        // Otherwise append
                    } else {
                        (structure[dataType] = structure[dataType] || []).push(func);
                    }
                }
            }
        }
        ;
    }

    // Base inspection function for prefilters and transports
    function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {

        var inspected = {}
          , seekingTransport = (structure === transports);

        function inspect(dataType) {
            var selected;
            inspected[dataType] = true;
            jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
                var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                if (typeof dataTypeOrTransport === "string" && !seekingTransport && !inspected[dataTypeOrTransport]) {

                    options.dataTypes.unshift(dataTypeOrTransport);
                    inspect(dataTypeOrTransport);
                    return false;
                } else if (seekingTransport) {
                    return !(selected = dataTypeOrTransport);
                }
            });
            return selected;
        }

        return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*");
    }

    // A special extend for ajax options
    // that takes "flat" options (not to be deep extended)
    // Fixes #9887
    function ajaxExtend(target, src) {
        var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};

        for (key in src) {
            if (src[key] !== undefined) {
                (flatOptions[key] ? target : (deep || (deep = {})))[key] = src[key];
            }
        }
        if (deep) {
            jQuery.extend(true, target, deep);
        }

        return target;
    }

    /* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
    function ajaxHandleResponses(s, jqXHR, responses) {

        var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;

        // Remove auto dataType and get content-type in the process
        while (dataTypes[0] === "*") {
            dataTypes.shift();
            if (ct === undefined) {
                ct = s.mimeType || jqXHR.getResponseHeader("Content-Type");
            }
        }

        // Check if we're dealing with a known content-type
        if (ct) {
            for (type in contents) {
                if (contents[type] && contents[type].test(ct)) {
                    dataTypes.unshift(type);
                    break;
                }
            }
        }

        // Check to see if we have a response for the expected dataType
        if (dataTypes[0]in responses) {
            finalDataType = dataTypes[0];
        } else {

            // Try convertible dataTypes
            for (type in responses) {
                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                    finalDataType = type;
                    break;
                }
                if (!firstDataType) {
                    firstDataType = type;
                }
            }

            // Or just use first one
            finalDataType = finalDataType || firstDataType;
        }

        // If we found a dataType
        // We add the dataType to the list if needed
        // and return the corresponding response
        if (finalDataType) {
            if (finalDataType !== dataTypes[0]) {
                dataTypes.unshift(finalDataType);
            }
            return responses[finalDataType];
        }
    }

    /* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
    function ajaxConvert(s, response, jqXHR, isSuccess) {
        var conv2, current, conv, tmp, prev, converters = {},
        // Work with a copy of dataTypes in case we need to modify it for conversion
        dataTypes = s.dataTypes.slice();

        // Create converters map with lowercased keys
        if (dataTypes[1]) {
            for (conv in s.converters) {
                converters[conv.toLowerCase()] = s.converters[conv];
            }
        }

        current = dataTypes.shift();

        // Convert to each sequential dataType
        while (current) {

            if (s.responseFields[current]) {
                jqXHR[s.responseFields[current]] = response;
            }

            // Apply the dataFilter if provided
            if (!prev && isSuccess && s.dataFilter) {
                response = s.dataFilter(response, s.dataType);
            }

            prev = current;
            current = dataTypes.shift();

            if (current) {

                // There's only work to do if current dataType is non-auto
                if (current === "*") {

                    current = prev;

                    // Convert response if prev dataType is non-auto and differs from current
                } else if (prev !== "*" && prev !== current) {

                    // Seek a direct converter
                    conv = converters[prev + " " + current] || converters["* " + current];

                    // If none found, seek a pair
                    if (!conv) {
                        for (conv2 in converters) {

                            // If conv2 outputs current
                            tmp = conv2.split(" ");
                            if (tmp[1] === current) {

                                // If prev can be converted to accepted input
                                conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]];
                                if (conv) {

                                    // Condense equivalence converters
                                    if (conv === true) {
                                        conv = converters[conv2];

                                        // Otherwise, insert the intermediate dataType
                                    } else if (converters[conv2] !== true) {
                                        current = tmp[0];
                                        dataTypes.unshift(tmp[1]);
                                    }
                                    break;
                                }
                            }
                        }
                    }

                    // Apply converter (if not an equivalence)
                    if (conv !== true) {

                        // Unless errors are allowed to bubble, catch and return them
                        if (conv && s.throws) {
                            response = conv(response);
                        } else {
                            try {
                                response = conv(response);
                            } catch (e) {
                                return {
                                    state: "parsererror",
                                    error: conv ? e : "No conversion from " + prev + " to " + current
                                };
                            }
                        }
                    }
                }
            }
        }

        return {
            state: "success",
            data: response
        };
    }

    jQuery.extend({

        // Counter for holding the number of active queries
        active: 0,

        // Last-Modified header cache for next request
        lastModified: {},
        etag: {},

        ajaxSettings: {
            url: location.href,
            type: "GET",
            isLocal: rlocalProtocol.test(location.protocol),
            global: true,
            processData: true,
            async: true,
            contentType: "application/x-www-form-urlencoded; charset=UTF-8",
            /*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

            accepts: {
                "*": allTypes,
                text: "text/plain",
                html: "text/html",
                xml: "application/xml, text/xml",
                json: "application/json, text/javascript"
            },

            contents: {
                xml: /\bxml\b/,
                html: /\bhtml/,
                json: /\bjson\b/
            },

            responseFields: {
                xml: "responseXML",
                text: "responseText",
                json: "responseJSON"
            },

            // Data converters
            // Keys separate source (or catchall "*") and destination types with a single space
            converters: {

                // Convert anything to text
                "* text": String,

                // Text to html (true = no transformation)
                "text html": true,

                // Evaluate text as a json expression
                "text json": jQuery.parseJSON,

                // Parse text as xml
                "text xml": jQuery.parseXML
            },

            // For options that shouldn't be deep extended:
            // you can add your own custom options here if
            // and when you create one that shouldn't be
            // deep extended (see ajaxExtend)
            flatOptions: {
                url: true,
                context: true
            }
        },

        // Creates a full fledged settings object into target
        // with both ajaxSettings and settings fields.
        // If target is omitted, writes into ajaxSettings.
        ajaxSetup: function(target, settings) {
            return settings ?
            // Building a settings object
            ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) :
            // Extending ajaxSettings
            ajaxExtend(jQuery.ajaxSettings, target);
        },

        ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
        ajaxTransport: addToPrefiltersOrTransports(transports),

        // Main method
        ajax: function(url, options) {

            // If url is an object, simulate pre-1.5 signature
            if (typeof url === "object") {
                options = url;
                url = undefined;
            }

            // Force options to be an object
            options = options || {};

            var transport,
            // URL without anti-cache param
            cacheURL,
            // Response headers
            responseHeadersString, responseHeaders,
            // timeout handle
            timeoutTimer,
            // Url cleanup var
            urlAnchor,
            // To know if global events are to be dispatched
            fireGlobals,
            // Loop variable
            i,
            // Create the final options object
            s = jQuery.ajaxSetup({}, options),
            // Callbacks context
            callbackContext = s.context || s,
            // Context for global events is callbackContext if it is a DOM node or jQuery collection
            globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
            // Deferreds
            deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"),
            // Status-dependent callbacks
            statusCode = s.statusCode || {},
            // Headers (they are sent all at once)
            requestHeaders = {}, requestHeadersNames = {},
            // The jqXHR state
            state = 0,
            // Default abort message
            strAbort = "canceled",
            // Fake xhr
            jqXHR = {
                readyState: 0,

                // Builds headers hashtable if needed
                getResponseHeader: function(key) {
                    var match;
                    if (state === 2) {
                        if (!responseHeaders) {
                            responseHeaders = {};
                            while ((match = rheaders.exec(responseHeadersString))) {
                                responseHeaders[match[1].toLowerCase()] = match[2];
                            }
                        }
                        match = responseHeaders[key.toLowerCase()];
                    }
                    return match == null ? null : match;
                },

                // Raw string
                getAllResponseHeaders: function() {
                    return state === 2 ? responseHeadersString : null;
                },

                // Caches the header
                setRequestHeader: function(name, value) {
                    var lname = name.toLowerCase();
                    if (!state) {
                        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
                        requestHeaders[name] = value;
                    }
                    return this;
                },

                // Overrides response content-type header
                overrideMimeType: function(type) {
                    if (!state) {
                        s.mimeType = type;
                    }
                    return this;
                },

                // Status-dependent callbacks
                statusCode: function(map) {
                    var code;
                    if (map) {
                        if (state < 2) {
                            for (code in map) {

                                // Lazy-add the new callback in a way that preserves old ones
                                statusCode[code] = [statusCode[code], map[code]];
                            }
                        } else {

                            // Execute the appropriate callbacks
                            jqXHR.always(map[jqXHR.status]);
                        }
                    }
                    return this;
                },

                // Cancel the request
                abort: function(statusText) {
                    var finalText = statusText || strAbort;
                    if (transport) {
                        transport.abort(finalText);
                    }
                    done(0, finalText);
                    return this;
                }
            };

            // Attach deferreds
            deferred.promise(jqXHR).complete = completeDeferred.add;
            jqXHR.success = jqXHR.done;
            jqXHR.error = jqXHR.fail;

            // Remove hash character (#7531: and string promotion)
            // Add protocol if not provided (prefilters might expect it)
            // Handle falsy url in the settings object (#10093: consistency with old signature)
            // We also use the url parameter if available
            s.url = ((url || s.url || location.href) + "").replace(rhash, "").replace(rprotocol, location.protocol + "//");

            // Alias method option to type as per ticket #12004
            s.type = options.method || options.type || s.method || s.type;

            // Extract dataTypes list
            s.dataTypes = jQuery.trim(s.dataType || "*").toLowerCase().match(rnotwhite) || [""];

            // A cross-domain request is in order when the origin doesn't match the current origin.
            if (s.crossDomain == null) {
                urlAnchor = document.createElement("a");

                // Support: IE8-11+
                // IE throws exception if url is malformed, e.g. http://example.com:80x/
                try {
                    urlAnchor.href = s.url;

                    // Support: IE8-11+
                    // Anchor's host property isn't correctly set when s.url is relative
                    urlAnchor.href = urlAnchor.href;
                    s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !== urlAnchor.protocol + "//" + urlAnchor.host;
                } catch (e) {

                    // If there is an error parsing the URL, assume it is crossDomain,
                    // it can be rejected by the transport if it is invalid
                    s.crossDomain = true;
                }
            }

            // Convert data if not already a string
            if (s.data && s.processData && typeof s.data !== "string") {
                s.data = jQuery.param(s.data, s.traditional);
            }

            // Apply prefilters
            inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);

            // If request was aborted inside a prefilter, stop there
            if (state === 2) {
                return jqXHR;
            }

            // We can fire global events as of now if asked to
            // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
            fireGlobals = jQuery.event && s.global;

            // Watch for a new set of requests
            if (fireGlobals && jQuery.active++ === 0) {
                jQuery.event.trigger("ajaxStart");
            }

            // Uppercase the type
            s.type = s.type.toUpperCase();

            // Determine if request has content
            s.hasContent = !rnoContent.test(s.type);

            // Save the URL in case we're toying with the If-Modified-Since
            // and/or If-None-Match header later on
            cacheURL = s.url;

            // More options handling for requests with no content
            if (!s.hasContent) {

                // If data is available, append data to url
                if (s.data) {
                    cacheURL = (s.url += (rquery.test(cacheURL) ? "&" : "?") + s.data);

                    // #9682: remove data so that it's not used in an eventual retry
                    delete s.data;
                }

                // Add anti-cache in url if needed
                if (s.cache === false) {
                    s.url = rts.test(cacheURL) ?
                    // If there is already a '_' parameter, set its value
                    cacheURL.replace(rts, "$1_=" + nonce++) :
                    // Otherwise add one to the end
                    cacheURL + (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++;
                }
            }

            // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
            if (s.ifModified) {
                if (jQuery.lastModified[cacheURL]) {
                    jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]);
                }
                if (jQuery.etag[cacheURL]) {
                    jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL]);
                }
            }

            // Set the correct header, if data is being sent
            if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
                jqXHR.setRequestHeader("Content-Type", s.contentType);
            }

            // Set the Accepts header for the server, depending on the dataType
            jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== "*" ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);

            // Check for headers option
            for (i in s.headers) {
                jqXHR.setRequestHeader(i, s.headers[i]);
            }

            // Allow custom headers/mimetypes and early abort
            if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {

                // Abort if not done already and return
                return jqXHR.abort();
            }

            // Aborting is no longer a cancellation
            strAbort = "abort";

            // Install callbacks on deferreds
            for (i in {
                success: 1,
                error: 1,
                complete: 1
            }) {
                jqXHR[i](s[i]);
            }

            // Get transport
            transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);

            // If no transport, we auto-abort
            if (!transport) {
                done(-1, "No Transport");
            } else {
                jqXHR.readyState = 1;

                // Send global event
                if (fireGlobals) {
                    globalEventContext.trigger("ajaxSend", [jqXHR, s]);
                }

                // If request was aborted inside ajaxSend, stop there
                if (state === 2) {
                    return jqXHR;
                }

                // Timeout
                if (s.async && s.timeout > 0) {
                    timeoutTimer = window.setTimeout(function() {
                        jqXHR.abort("timeout");
                    }, s.timeout);
                }

                try {
                    state = 1;
                    transport.send(requestHeaders, done);
                } catch (e) {

                    // Propagate exception as error if not done
                    if (state < 2) {
                        done(-1, e);

                        // Simply rethrow otherwise
                    } else {
                        throw e;
                    }
                }
            }

            // Callback for when everything is done
            function done(status, nativeStatusText, responses, headers) {
                var isSuccess, success, error, response, modified, statusText = nativeStatusText;

                // Called once
                if (state === 2) {
                    return;
                }

                // State is "done" now
                state = 2;

                // Clear timeout if it exists
                if (timeoutTimer) {
                    window.clearTimeout(timeoutTimer);
                }

                // Dereference transport for early garbage collection
                // (no matter how long the jqXHR object will be used)
                transport = undefined;

                // Cache response headers
                responseHeadersString = headers || "";

                // Set readyState
                jqXHR.readyState = status > 0 ? 4 : 0;

                // Determine if successful
                isSuccess = status >= 200 && status < 300 || status === 304;

                // Get response data
                if (responses) {
                    response = ajaxHandleResponses(s, jqXHR, responses);
                }

                // Convert no matter what (that way responseXXX fields are always set)
                response = ajaxConvert(s, response, jqXHR, isSuccess);

                // If successful, handle type chaining
                if (isSuccess) {

                    // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
                    if (s.ifModified) {
                        modified = jqXHR.getResponseHeader("Last-Modified");
                        if (modified) {
                            jQuery.lastModified[cacheURL] = modified;
                        }
                        modified = jqXHR.getResponseHeader("etag");
                        if (modified) {
                            jQuery.etag[cacheURL] = modified;
                        }
                    }

                    // if no content
                    if (status === 204 || s.type === "HEAD") {
                        statusText = "nocontent";

                        // if not modified
                    } else if (status === 304) {
                        statusText = "notmodified";

                        // If we have data, let's convert it
                    } else {
                        statusText = response.state;
                        success = response.data;
                        error = response.error;
                        isSuccess = !error;
                    }
                } else {

                    // Extract error from statusText and normalize for non-aborts
                    error = statusText;
                    if (status || !statusText) {
                        statusText = "error";
                        if (status < 0) {
                            status = 0;
                        }
                    }
                }

                // Set data for the fake xhr object
                jqXHR.status = status;
                jqXHR.statusText = (nativeStatusText || statusText) + "";

                // Success/Error
                if (isSuccess) {
                    deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
                } else {
                    deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
                }

                // Status-dependent callbacks
                jqXHR.statusCode(statusCode);
                statusCode = undefined;

                if (fireGlobals) {
                    globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]);
                }

                // Complete
                completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);

                if (fireGlobals) {
                    globalEventContext.trigger("ajaxComplete", [jqXHR, s]);

                    // Handle the global AJAX counter
                    if (!(--jQuery.active)) {
                        jQuery.event.trigger("ajaxStop");
                    }
                }
            }

            return jqXHR;
        },

        getJSON: function(url, data, callback) {
            return jQuery.get(url, data, callback, "json");
        },

        getScript: function(url, callback) {
            return jQuery.get(url, undefined, callback, "script");
        }
    });

    jQuery.each(["get", "post"], function(i, method) {
        jQuery[method] = function(url, data, callback, type) {

            // Shift arguments if data argument was omitted
            if (jQuery.isFunction(data)) {
                type = type || callback;
                callback = data;
                data = undefined;
            }

            // The url can be an options object (which then must have .url)
            return jQuery.ajax(jQuery.extend({
                url: url,
                type: method,
                dataType: type,
                data: data,
                success: callback
            }, jQuery.isPlainObject(url) && url));
        }
        ;
    });

    jQuery._evalUrl = function(url) {
        return jQuery.ajax({
            url: url,

            // Make this explicit, since user can override this through ajaxSetup (#11264)
            type: "GET",
            dataType: "script",
            async: false,
            global: false,
            "throws": true
        });
    }
    ;

    jQuery.fn.extend({
        wrapAll: function(html) {
            var wrap;

            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapAll(html.call(this, i));
                });
            }

            if (this[0]) {

                // The elements to wrap the target around
                wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);

                if (this[0].parentNode) {
                    wrap.insertBefore(this[0]);
                }

                wrap.map(function() {
                    var elem = this;

                    while (elem.firstElementChild) {
                        elem = elem.firstElementChild;
                    }

                    return elem;
                }).append(this);
            }

            return this;
        },

        wrapInner: function(html) {
            if (jQuery.isFunction(html)) {
                return this.each(function(i) {
                    jQuery(this).wrapInner(html.call(this, i));
                });
            }

            return this.each(function() {
                var self = jQuery(this)
                  , contents = self.contents();

                if (contents.length) {
                    contents.wrapAll(html);

                } else {
                    self.append(html);
                }
            });
        },

        wrap: function(html) {
            var isFunction = jQuery.isFunction(html);

            return this.each(function(i) {
                jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
            });
        },

        unwrap: function() {
            return this.parent().each(function() {
                if (!jQuery.nodeName(this, "body")) {
                    jQuery(this).replaceWith(this.childNodes);
                }
            }).end();
        }
    });

    jQuery.expr.filters.hidden = function(elem) {
        return !jQuery.expr.filters.visible(elem);
    }
    ;
    jQuery.expr.filters.visible = function(elem) {

        // Support: Opera <= 12.12
        // Opera reports offsetWidths and offsetHeights less than zero on some elements
        // Use OR instead of AND as the element is not visible if either is true
        // See tickets #10406 and #13132
        return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
    }
    ;

    var r20 = /%20/g
      , rbracket = /\[\]$/
      , rCRLF = /\r?\n/g
      , rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i
      , rsubmittable = /^(?:input|select|textarea|keygen)/i;

    function buildParams(prefix, obj, traditional, add) {
        var name;

        if (jQuery.isArray(obj)) {

            // Serialize array item.
            jQuery.each(obj, function(i, v) {
                if (traditional || rbracket.test(prefix)) {

                    // Treat each array item as a scalar.
                    add(prefix, v);

                } else {

                    // Item is non-scalar (array or object), encode its numeric index.
                    buildParams(prefix + "[" + (typeof v === "object" && v != null ? i : "") + "]", v, traditional, add);
                }
            });

        } else if (!traditional && jQuery.type(obj) === "object") {

            // Serialize object item.
            for (name in obj) {
                buildParams(prefix + "[" + name + "]", obj[name], traditional, add);
            }

        } else {

            // Serialize scalar item.
            add(prefix, obj);
        }
    }

    // Serialize an array of form elements or a set of
    // key/values into a query string
    jQuery.param = function(a, traditional) {
        var prefix, s = [], add = function(key, value) {

            // If value is a function, invoke it and return its value
            value = jQuery.isFunction(value) ? value() : (value == null ? "" : value);
            s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(value);
        };

        // Set traditional to true for jQuery <= 1.3.2 behavior.
        if (traditional === undefined) {
            traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
        }

        // If an array was passed in, assume that it is an array of form elements.
        if (jQuery.isArray(a) || (a.jquery && !jQuery.isPlainObject(a))) {

            // Serialize the form elements
            jQuery.each(a, function() {
                add(this.name, this.value);
            });

        } else {

            // If traditional, encode the "old" way (the way 1.3.2 or older
            // did it), otherwise encode params recursively.
            for (prefix in a) {
                buildParams(prefix, a[prefix], traditional, add);
            }
        }

        // Return the resulting serialization
        return s.join("&").replace(r20, "+");
    }
    ;

    jQuery.fn.extend({
        serialize: function() {
            return jQuery.param(this.serializeArray());
        },
        serializeArray: function() {
            return this.map(function() {

                // Can add propHook for "elements" to filter or add form elements
                var elements = jQuery.prop(this, "elements");
                return elements ? jQuery.makeArray(elements) : this;
            }).filter(function() {
                var type = this.type;

                // Use .is( ":disabled" ) so that fieldset[disabled] works
                return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
            }).map(function(i, elem) {
                var val = jQuery(this).val();

                return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
                    return {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    };
                }) : {
                    name: elem.name,
                    value: val.replace(rCRLF, "\r\n")
                };
            }).get();
        }
    });

    jQuery.ajaxSettings.xhr = function() {
        try {
            return new window.XMLHttpRequest();
        } catch (e) {}
    }
    ;

    var xhrSuccessStatus = {

        // File protocol always yields status code 0, assume 200
        0: 200,

        // Support: IE9
        // #1450: sometimes IE returns 1223 when it should be 204
        1223: 204
    }
      , xhrSupported = jQuery.ajaxSettings.xhr();

    support.cors = !!xhrSupported && ("withCredentials"in xhrSupported);
    support.ajax = xhrSupported = !!xhrSupported;

    jQuery.ajaxTransport(function(options) {
        var callback, errorCallback;

        // Cross domain only allowed if supported through XMLHttpRequest
        if (support.cors || xhrSupported && !options.crossDomain) {
            return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr();

                    xhr.open(options.type, options.url, options.async, options.username, options.password);

                    // Apply custom fields if provided
                    if (options.xhrFields) {
                        for (i in options.xhrFields) {
                            xhr[i] = options.xhrFields[i];
                        }
                    }

                    // Override mime type if needed
                    if (options.mimeType && xhr.overrideMimeType) {
                        xhr.overrideMimeType(options.mimeType);
                    }

                    // X-Requested-With header
                    // For cross-domain requests, seeing as conditions for a preflight are
                    // akin to a jigsaw puzzle, we simply never set it to be sure.
                    // (it can always be set on a per-request basis or even using ajaxSetup)
                    // For same-domain requests, won't change header if already provided.
                    if (!options.crossDomain && !headers["X-Requested-With"]) {
                        headers["X-Requested-With"] = "XMLHttpRequest";
                    }

                    // Set headers
                    for (i in headers) {
                        xhr.setRequestHeader(i, headers[i]);
                    }

                    // Callback
                    callback = function(type) {
                        return function() {
                            if (callback) {
                                callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

                                if (type === "abort") {
                                    xhr.abort();
                                } else if (type === "error") {

                                    // Support: IE9
                                    // On a manual native abort, IE9 throws
                                    // errors on any property access that is not readyState
                                    if (typeof xhr.status !== "number") {
                                        complete(0, "error");
                                    } else {
                                        complete(
                                        // File: protocol always yields status 0; see #8605, #14207
                                        xhr.status, xhr.statusText);
                                    }
                                } else {
                                    complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText,
                                    // Support: IE9 only
                                    // IE9 has no XHR2 but throws on binary (trac-11426)
                                    // For XHR2 non-text, let the caller handle it (gh-2498)
                                    (xhr.responseType || "text") !== "text" || typeof xhr.responseText !== "string" ? {
                                        binary: xhr.response
                                    } : {
                                        text: xhr.responseText
                                    }, xhr.getAllResponseHeaders());
                                }
                            }
                        }
                        ;
                    }
                    ;

                    // Listen to events
                    xhr.onload = callback();
                    errorCallback = xhr.onerror = callback("error");

                    // Support: IE9
                    // Use onreadystatechange to replace onabort
                    // to handle uncaught aborts
                    if (xhr.onabort !== undefined) {
                        xhr.onabort = errorCallback;
                    } else {
                        xhr.onreadystatechange = function() {

                            // Check readyState before timeout as it changes
                            if (xhr.readyState === 4) {

                                // Allow onerror to be called first,
                                // but that will not handle a native abort
                                // Also, save errorCallback to a variable
                                // as xhr.onerror cannot be accessed
                                window.setTimeout(function() {
                                    if (callback) {
                                        errorCallback();
                                    }
                                });
                            }
                        }
                        ;
                    }

                    // Create the abort callback
                    callback = callback("abort");

                    try {

                        // Do send the request (this may raise an exception)
                        xhr.send(options.hasContent && options.data || null);
                    } catch (e) {

                        // #14683: Only rethrow if this hasn't been notified as an error yet
                        if (callback) {
                            throw e;
                        }
                    }
                },

                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });

    // Install script dataType
    jQuery.ajaxSetup({
        accepts: {
            script: "text/javascript, application/javascript, " + "application/ecmascript, application/x-ecmascript"
        },
        contents: {
            script: /\b(?:java|ecma)script\b/
        },
        converters: {
            "text script": function(text) {
                jQuery.globalEval(text);
                return text;
            }
        }
    });

    // Handle cache's special case and crossDomain
    jQuery.ajaxPrefilter("script", function(s) {
        if (s.cache === undefined) {
            s.cache = false;
        }
        if (s.crossDomain) {
            s.type = "GET";
        }
    });

    // Bind script tag hack transport
    jQuery.ajaxTransport("script", function(s) {

        // This transport only deals with cross domain requests
        if (s.crossDomain) {
            var script, callback;
            return {
                send: function(_, complete) {
                    script = jQuery("<script>").prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove();
                        callback = null;
                        if (evt) {
                            complete(evt.type === "error" ? 404 : 200, evt.type);
                        }
                    }
                    );

                    // Use native DOM manipulation to avoid our domManip AJAX trickery
                    document.head.appendChild(script[0]);
                },
                abort: function() {
                    if (callback) {
                        callback();
                    }
                }
            };
        }
    });

    var oldCallbacks = []
      , rjsonp = /(=)\?(?=&|$)|\?\?/;

    // Default jsonp settings
    jQuery.ajaxSetup({
        jsonp: "callback",
        jsonpCallback: function() {
            var callback = oldCallbacks.pop() || (jQuery.expando + "_" + (nonce++));
            this[callback] = true;
            return callback;
        }
    });

    // Detect, normalize options and install callbacks for jsonp requests
    jQuery.ajaxPrefilter("json jsonp", function(s, originalSettings, jqXHR) {

        var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? "url" : typeof s.data === "string" && (s.contentType || "").indexOf("application/x-www-form-urlencoded") === 0 && rjsonp.test(s.data) && "data");

        // Handle iff the expected data type is "jsonp" or we have a parameter to set
        if (jsonProp || s.dataTypes[0] === "jsonp") {

            // Get callback name, remembering preexisting value associated with it
            callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;

            // Insert callback into url or form data
            if (jsonProp) {
                s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName);
            } else if (s.jsonp !== false) {
                s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName;
            }

            // Use data converter to retrieve json after script execution
            s.converters["script json"] = function() {
                if (!responseContainer) {
                    jQuery.error(callbackName + " was not called");
                }
                return responseContainer[0];
            }
            ;

            // Force json dataType
            s.dataTypes[0] = "json";

            // Install callback
            overwritten = window[callbackName];
            window[callbackName] = function() {
                responseContainer = arguments;
            }
            ;

            // Clean-up function (fires after converters)
            jqXHR.always(function() {

                // If previous value didn't exist - remove it
                if (overwritten === undefined) {
                    jQuery(window).removeProp(callbackName);

                    // Otherwise restore preexisting value
                } else {
                    window[callbackName] = overwritten;
                }

                // Save back as free
                if (s[callbackName]) {

                    // Make sure that re-using the options doesn't screw things around
                    s.jsonpCallback = originalSettings.jsonpCallback;

                    // Save the callback name for future use
                    oldCallbacks.push(callbackName);
                }

                // Call if it was a function and we have a response
                if (responseContainer && jQuery.isFunction(overwritten)) {
                    overwritten(responseContainer[0]);
                }

                responseContainer = overwritten = undefined;
            });

            // Delegate to script
            return "script";
        }
    });

    // Argument "data" should be string of html
    // context (optional): If specified, the fragment will be created in this context,
    // defaults to document
    // keepScripts (optional): If true, will include scripts passed in the html string
    jQuery.parseHTML = function(data, context, keepScripts) {
        if (!data || typeof data !== "string") {
            return null;
        }
        if (typeof context === "boolean") {
            keepScripts = context;
            context = false;
        }
        context = context || document;

        var parsed = rsingleTag.exec(data)
          , scripts = !keepScripts && [];

        // Single tag
        if (parsed) {
            return [context.createElement(parsed[1])];
        }

        parsed = buildFragment([data], context, scripts);

        if (scripts && scripts.length) {
            jQuery(scripts).remove();
        }

        return jQuery.merge([], parsed.childNodes);
    }
    ;

    // Keep a copy of the old load method
    var _load = jQuery.fn.load;

    /**
 * Load a url into a page
 */
    jQuery.fn.load = function(url, params, callback) {
        if (typeof url !== "string" && _load) {
            return _load.apply(this, arguments);
        }

        var selector, type, response, self = this, off = url.indexOf(" ");

        if (off > -1) {
            selector = jQuery.trim(url.slice(off));
            url = url.slice(0, off);
        }

        // If it's a function
        if (jQuery.isFunction(params)) {

            // We assume that it's the callback
            callback = params;
            params = undefined;

            // Otherwise, build a param string
        } else if (params && typeof params === "object") {
            type = "POST";
        }

        // If we have elements to modify, make the request
        if (self.length > 0) {
            jQuery.ajax({
                url: url,

                // If "type" variable is undefined, then "GET" method will be used.
                // Make value of this field explicit since
                // user can override it through ajaxSetup method
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function(responseText) {

                // Save response for use in complete callback
                response = arguments;

                self.html(selector ?
                // If a selector was specified, locate the right elements in a dummy div
                // Exclude scripts to avoid IE 'Permission Denied' errors
                jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) :
                // Otherwise use the full result
                responseText);

                // If the request succeeds, this function gets "data", "status", "jqXHR"
                // but they are ignored because response was set above.
                // If it fails, this function gets "jqXHR", "status", "error"
            }).always(callback && function(jqXHR, status) {
                self.each(function() {
                    callback.apply(this, response || [jqXHR.responseText, status, jqXHR]);
                });
            }
            );
        }

        return this;
    }
    ;

    // Attach a bunch of functions for handling common AJAX events
    jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function(i, type) {
        jQuery.fn[type] = function(fn) {
            return this.on(type, fn);
        }
        ;
    });

    jQuery.expr.filters.animated = function(elem) {
        return jQuery.grep(jQuery.timers, function(fn) {
            return elem === fn.elem;
        }).length;
    }
    ;

    /**
 * Gets a window from an element
 */
    function getWindow(elem) {
        return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 && elem.defaultView;
    }

    jQuery.offset = {
        setOffset: function(elem, options, i) {
            var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};

            // Set position first, in-case top/left are set even on static elem
            if (position === "static") {
                elem.style.position = "relative";
            }

            curOffset = curElem.offset();
            curCSSTop = jQuery.css(elem, "top");
            curCSSLeft = jQuery.css(elem, "left");
            calculatePosition = (position === "absolute" || position === "fixed") && (curCSSTop + curCSSLeft).indexOf("auto") > -1;

            // Need to be able to calculate position if either
            // top or left is auto and position is either absolute or fixed
            if (calculatePosition) {
                curPosition = curElem.position();
                curTop = curPosition.top;
                curLeft = curPosition.left;

            } else {
                curTop = parseFloat(curCSSTop) || 0;
                curLeft = parseFloat(curCSSLeft) || 0;
            }

            if (jQuery.isFunction(options)) {

                // Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
                options = options.call(elem, i, jQuery.extend({}, curOffset));
            }

            if (options.top != null) {
                props.top = (options.top - curOffset.top) + curTop;
            }
            if (options.left != null) {
                props.left = (options.left - curOffset.left) + curLeft;
            }

            if ("using"in options) {
                options.using.call(elem, props);

            } else {
                curElem.css(props);
            }
        }
    };

    jQuery.fn.extend({
        offset: function(options) {
            if (arguments.length) {
                return options === undefined ? this : this.each(function(i) {
                    jQuery.offset.setOffset(this, options, i);
                });
            }

            var docElem, win, elem = this[0], box = {
                top: 0,
                left: 0
            }, doc = elem && elem.ownerDocument;

            if (!doc) {
                return;
            }

            docElem = doc.documentElement;

            // Make sure it's not a disconnected DOM node
            if (!jQuery.contains(docElem, elem)) {
                return box;
            }

            box = elem.getBoundingClientRect();
            win = getWindow(doc);
            return {
                top: box.top + win.pageYOffset - docElem.clientTop,
                left: box.left + win.pageXOffset - docElem.clientLeft
            };
        },

        position: function() {
            if (!this[0]) {
                return;
            }

            var offsetParent, offset, elem = this[0], parentOffset = {
                top: 0,
                left: 0
            };

            // Fixed elements are offset from window (parentOffset = {top:0, left: 0},
            // because it is its only offset parent
            if (jQuery.css(elem, "position") === "fixed") {

                // Assume getBoundingClientRect is there when computed position is fixed
                offset = elem.getBoundingClientRect();

            } else {

                // Get *real* offsetParent
                offsetParent = this.offsetParent();

                // Get correct offsets
                offset = this.offset();
                if (!jQuery.nodeName(offsetParent[0], "html")) {
                    parentOffset = offsetParent.offset();
                }

                // Add offsetParent borders
                parentOffset.top += jQuery.css(offsetParent[0], "borderTopWidth", true);
                parentOffset.left += jQuery.css(offsetParent[0], "borderLeftWidth", true);
            }

            // Subtract parent offsets and element margins
            return {
                top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", true),
                left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", true)
            };
        },

        // This method will return documentElement in the following cases:
        // 1) For the element inside the iframe without offsetParent, this method will return
        //    documentElement of the parent window
        // 2) For the hidden or detached element
        // 3) For body or html element, i.e. in case of the html node - it will return itself
        //
        // but those exceptions were never presented as a real life use-cases
        // and might be considered as more preferable results.
        //
        // This logic, however, is not guaranteed and can change at any point in the future
        offsetParent: function() {
            return this.map(function() {
                var offsetParent = this.offsetParent;

                while (offsetParent && jQuery.css(offsetParent, "position") === "static") {
                    offsetParent = offsetParent.offsetParent;
                }

                return offsetParent || documentElement;
            });
        }
    });

    // Create scrollLeft and scrollTop methods
    jQuery.each({
        scrollLeft: "pageXOffset",
        scrollTop: "pageYOffset"
    }, function(method, prop) {
        var top = "pageYOffset" === prop;

        jQuery.fn[method] = function(val) {
            return access(this, function(elem, method, val) {
                var win = getWindow(elem);

                if (val === undefined) {
                    return win ? win[prop] : elem[method];
                }

                if (win) {
                    win.scrollTo(!top ? val : win.pageXOffset, top ? val : win.pageYOffset);

                } else {
                    elem[method] = val;
                }
            }, method, val, arguments.length);
        }
        ;
    });

    // Support: Safari<7-8+, Chrome<37-44+
    // Add the top/left cssHooks using jQuery.fn.position
    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
    // Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
    // getComputedStyle returns percent when specified for top/left/bottom/right;
    // rather than make the css module depend on the offset module, just check for it here
    jQuery.each(["top", "left"], function(i, prop) {
        jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
            if (computed) {
                computed = curCSS(elem, prop);

                // If curCSS returns percentage, fallback to offset
                return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed;
            }
        });
    });

    // Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
    jQuery.each({
        Height: "height",
        Width: "width"
    }, function(name, type) {
        jQuery.each({
            padding: "inner" + name,
            content: type,
            "": "outer" + name
        }, function(defaultExtra, funcName) {

            // Margin is only for outerHeight, outerWidth
            jQuery.fn[funcName] = function(margin, value) {
                var chainable = arguments.length && (defaultExtra || typeof margin !== "boolean")
                  , extra = defaultExtra || (margin === true || value === true ? "margin" : "border");

                return access(this, function(elem, type, value) {
                    var doc;

                    if (jQuery.isWindow(elem)) {

                        // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
                        // isn't a whole lot we can do. See pull request at this URL for discussion:
                        // https://github.com/jquery/jquery/pull/764
                        return elem.document.documentElement["client" + name];
                    }

                    // Get document width or height
                    if (elem.nodeType === 9) {
                        doc = elem.documentElement;

                        // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
                        // whichever is greatest
                        return Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name]);
                    }

                    return value === undefined ?
                    // Get width or height on the element, requesting but not forcing parseFloat
                    jQuery.css(elem, type, extra) :
                    // Set width or height on the element
                    jQuery.style(elem, type, value, extra);
                }, type, chainable ? margin : undefined, chainable, null);
            }
            ;
        });
    });

    jQuery.fn.extend({

        bind: function(types, data, fn) {
            return this.on(types, null, data, fn);
        },
        unbind: function(types, fn) {
            return this.off(types, null, fn);
        },

        delegate: function(selector, types, data, fn) {
            return this.on(types, selector, data, fn);
        },
        undelegate: function(selector, types, fn) {

            // ( namespace ) or ( selector, types [, fn] )
            return arguments.length === 1 ? this.off(selector, "**") : this.off(types, selector || "**", fn);
        },
        size: function() {
            return this.length;
        }
    });

    jQuery.fn.andSelf = jQuery.fn.addBack;

    // Register as a named AMD module, since jQuery can be concatenated with other
    // files that may use define, but not via a proper concatenation script that
    // understands anonymous AMD modules. A named AMD is safest and most robust
    // way to register. Lowercase jquery is used because AMD module names are
    // derived from file names, and jQuery is normally delivered in a lowercase
    // file name. Do this after creating the global so that if an AMD module wants
    // to call noConflict to hide this version of jQuery, it will work.

    // Note that for maximum portability, libraries that are not jQuery should
    // declare themselves as anonymous modules, and avoid setting a global if an
    // AMD loader is present. jQuery is a special case. For more information, see
    // https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

    if (typeof define === "function" && define.amd) {
        define("jquery", [], function() {
            return jQuery;
        });
    }

    var
    // Map over jQuery in case of overwrite
    _jQuery = window.jQuery
      ,
    // Map over the $ in case of overwrite
    _$ = window.$;

    jQuery.noConflict = function(deep) {
        if (window.$ === jQuery) {
            window.$ = _$;
        }

        if (deep && window.jQuery === jQuery) {
            window.jQuery = _jQuery;
        }

        return jQuery;
    }
    ;

    // Expose jQuery and $ identifiers, even in AMD
    // (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
    // and CommonJS for browser emulators (#13566)
    if (!noGlobal) {
        window.jQuery = window.$ = jQuery;
    }

    return jQuery;
}));

$j = jQuery.noConflict();

/*
 * Foundation Responsive Library
 * http://foundation.zurb.com
 * Copyright 2015, ZURB
 * Free to use under the MIT license.
 * http://www.opensource.org/licenses/mit-license.php
*/

(function($, window, document, undefined) {
    'use strict';

    var header_helpers = function(class_array) {
        var head = $('head');
        head.prepend($.map(class_array, function(class_name) {
            if (head.has('.' + class_name).length === 0) {
                return '<meta class="' + class_name + '" />';
            }
        }));
    };

    header_helpers(['foundation-mq-small', 'foundation-mq-small-only', 'foundation-mq-medium', 'foundation-mq-medium-only', 'foundation-mq-large', 'foundation-mq-large-only', 'foundation-mq-xlarge', 'foundation-mq-xlarge-only', 'foundation-mq-xxlarge', 'foundation-data-attribute-namespace']);

    // Enable FastClick if present

    $(function() {
        if (typeof FastClick !== 'undefined') {
            // Don't attach to body if undefined
            if (typeof document.body !== 'undefined') {
                FastClick.attach(document.body);
            }
        }
    });

    // private Fast Selector wrapper,
    // returns jQuery object. Only use where
    // getElementById is not available.
    var S = function(selector, context) {
        if (typeof selector === 'string') {
            if (context) {
                var cont;
                if (context.jquery) {
                    cont = context[0];
                    if (!cont) {
                        return context;
                    }
                } else {
                    cont = context;
                }
                return $(cont.querySelectorAll(selector));
            }

            return $(document.querySelectorAll(selector));
        }

        return $(selector, context);
    };

    // Namespace functions.

    var attr_name = function(init) {
        var arr = [];
        if (!init) {
            arr.push('data');
        }
        if (this.namespace.length > 0) {
            arr.push(this.namespace);
        }
        arr.push(this.name);

        return arr.join('-');
    };

    var add_namespace = function(str) {
        var parts = str.split('-')
          , i = parts.length
          , arr = [];

        while (i--) {
            if (i !== 0) {
                arr.push(parts[i]);
            } else {
                if (this.namespace.length > 0) {
                    arr.push(this.namespace, parts[i]);
                } else {
                    arr.push(parts[i]);
                }
            }
        }

        return arr.reverse().join('-');
    };

    // Event binding and data-options updating.

    var bindings = function(method, options) {
        var self = this
          , bind = function() {
            var $this = S(this)
              , should_bind_events = !$this.data(self.attr_name(true) + '-init');
            $this.data(self.attr_name(true) + '-init', $.extend({}, self.settings, (options || method), self.data_options($this)));

            if (should_bind_events) {
                self.events(this);
            }
        };

        if (S(this.scope).is('[' + this.attr_name() + ']')) {
            bind.call(this.scope);
        } else {
            S('[' + this.attr_name() + ']', this.scope).each(bind);
        }
        // # Patch to fix #5043 to move this *after* the if/else clause in order for Backbone and similar frameworks to have improved control over event binding and data-options updating.
        if (typeof method === 'string') {
            return this[method].call(this, options);
        }

    };

    var single_image_loaded = function(image, callback) {
        function loaded() {
            callback(image[0]);
        }

        function bindLoad() {
            this.one('load', loaded);

            if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)) {
                var src = this.attr('src')
                  , param = src.match(/\?/) ? '&' : '?';

                param += 'random=' + (new Date()).getTime();
                this.attr('src', src + param);
            }
        }

        if (!image.attr('src')) {
            loaded();
            return;
        }

        if (image[0].complete || image[0].readyState === 4) {
            loaded();
        } else {
            bindLoad.call(image);
        }
    };

    /*! matchMedia() polyfill - Test a CSS media type/query in JS. Authors & copyright (c) 2012: Scott Jehl, Paul Irish, Nicholas Zakas, David Knight. Dual MIT/BSD license */

    window.matchMedia || (window.matchMedia = function() {
        "use strict";

        // For browsers that support matchMedium api such as IE 9 and webkit
        var styleMedia = (window.styleMedia || window.media);

        // For those that don't support matchMedium
        if (!styleMedia) {
            var style = document.createElement('style')
              , script = document.getElementsByTagName('script')[0]
              , info = null;

            style.type = 'text/css';
            style.id = 'matchmediajs-test';

            script.parentNode.insertBefore(style, script);

            // 'style.currentStyle' is used by IE <= 8 and 'window.getComputedStyle' for all other browsers
            info = ('getComputedStyle'in window) && window.getComputedStyle(style, null) || style.currentStyle;

            styleMedia = {
                matchMedium: function(media) {
                    var text = '@media ' + media + '{ #matchmediajs-test { width: 1px; } }';

                    // 'style.styleSheet' is used by IE <= 8 and 'style.textContent' for all other browsers
                    if (style.styleSheet) {
                        style.styleSheet.cssText = text;
                    } else {
                        style.textContent = text;
                    }

                    // Test if media query is true or false
                    return info.width === '1px';
                }
            };
        }

        return function(media) {
            return {
                matches: styleMedia.matchMedium(media || 'all'),
                media: media || 'all'
            };
        }
        ;
    }());

    /*
   * jquery.requestAnimationFrame
   * https://github.com/gnarf37/jquery-requestAnimationFrame
   * Requires jQuery 1.8+
   *
   * Copyright (c) 2012 Corey Frang
   * Licensed under the MIT license.
   */

    (function(jQuery) {

        // requestAnimationFrame polyfill adapted from Erik Möller
        // fixes from Paul Irish and Tino Zijdel
        // http://paulirish.com/2011/requestanimationframe-for-smart-animating/
        // http://my.opera.com/emoller/blog/2011/12/20/requestanimationframe-for-smart-er-animating

        var animating, lastTime = 0, vendors = ['webkit', 'moz'], requestAnimationFrame = window.requestAnimationFrame, cancelAnimationFrame = window.cancelAnimationFrame, jqueryFxAvailable = 'undefined' !== typeof jQuery.fx;

        for (; lastTime < vendors.length && !requestAnimationFrame; lastTime++) {
            requestAnimationFrame = window[vendors[lastTime] + 'RequestAnimationFrame'];
            cancelAnimationFrame = cancelAnimationFrame || window[vendors[lastTime] + 'CancelAnimationFrame'] || window[vendors[lastTime] + 'CancelRequestAnimationFrame'];
        }

        function raf() {
            if (animating) {
                requestAnimationFrame(raf);

                if (jqueryFxAvailable) {
                    jQuery.fx.tick();
                }
            }
        }

        if (requestAnimationFrame) {
            // use rAF
            window.requestAnimationFrame = requestAnimationFrame;
            window.cancelAnimationFrame = cancelAnimationFrame;

            if (jqueryFxAvailable) {
                jQuery.fx.timer = function(timer) {
                    if (timer() && jQuery.timers.push(timer) && !animating) {
                        animating = true;
                        raf();
                    }
                }
                ;

                jQuery.fx.stop = function() {
                    animating = false;
                }
                ;
            }
        } else {
            // polyfill
            window.requestAnimationFrame = function(callback) {
                var currTime = new Date().getTime()
                  , timeToCall = Math.max(0, 16 - (currTime - lastTime))
                  , id = window.setTimeout(function() {
                    callback(currTime + timeToCall);
                }, timeToCall);
                lastTime = currTime + timeToCall;
                return id;
            }
            ;

            window.cancelAnimationFrame = function(id) {
                clearTimeout(id);
            }
            ;

        }

    }($));

    function removeQuotes(string) {
        if (typeof string === 'string' || string instanceof String) {
            string = string.replace(/^['\\/"]+|(;\s?})+|['\\/"]+$/g, '');
        }

        return string;
    }

    function MediaQuery(selector) {
        this.selector = selector;
        this.query = '';
    }

    MediaQuery.prototype.toString = function() {
        return this.query || (this.query = S(this.selector).css('font-family').replace(/^[\/\\'"]+|(;\s?})+|[\/\\'"]+$/g, ''));
    }
    ;

    window.Foundation = {
        name: 'Foundation',

        version: '5.5.3',

        media_queries: {
            'small': new MediaQuery('.foundation-mq-small'),
            'small-only': new MediaQuery('.foundation-mq-small-only'),
            'medium': new MediaQuery('.foundation-mq-medium'),
            'medium-only': new MediaQuery('.foundation-mq-medium-only'),
            'large': new MediaQuery('.foundation-mq-large'),
            'large-only': new MediaQuery('.foundation-mq-large-only'),
            'xlarge': new MediaQuery('.foundation-mq-xlarge'),
            'xlarge-only': new MediaQuery('.foundation-mq-xlarge-only'),
            'xxlarge': new MediaQuery('.foundation-mq-xxlarge')
        },

        stylesheet: $('<style></style>').appendTo('head')[0].sheet,

        global: {
            namespace: undefined
        },

        init: function(scope, libraries, method, options, response) {
            var args = [scope, method, options, response]
              , responses = [];

            // check RTL
            this.rtl = /rtl/i.test(S('html').attr('dir'));

            // set foundation global scope
            this.scope = scope || this.scope;

            this.set_namespace();

            if (libraries && typeof libraries === 'string' && !/reflow/i.test(libraries)) {
                if (this.libs.hasOwnProperty(libraries)) {
                    responses.push(this.init_lib(libraries, args));
                }
            } else {
                for (var lib in this.libs) {
                    responses.push(this.init_lib(lib, libraries));
                }
            }

            S(window).load(function() {
                S(window).trigger('resize.fndtn.clearing').trigger('resize.fndtn.dropdown').trigger('resize.fndtn.equalizer').trigger('resize.fndtn.interchange').trigger('resize.fndtn.joyride').trigger('resize.fndtn.magellan').trigger('resize.fndtn.topbar').trigger('resize.fndtn.slider');
            });

            return scope;
        },

        init_lib: function(lib, args) {
            if (this.libs.hasOwnProperty(lib)) {
                this.patch(this.libs[lib]);

                if (args && args.hasOwnProperty(lib)) {
                    if (typeof this.libs[lib].settings !== 'undefined') {
                        $.extend(true, this.libs[lib].settings, args[lib]);
                    } else if (typeof this.libs[lib].defaults !== 'undefined') {
                        $.extend(true, this.libs[lib].defaults, args[lib]);
                    }
                    return this.libs[lib].init.apply(this.libs[lib], [this.scope, args[lib]]);
                }

                args = args instanceof Array ? args : new Array(args);
                return this.libs[lib].init.apply(this.libs[lib], args);
            }

            return function() {}
            ;
        },

        patch: function(lib) {
            lib.scope = this.scope;
            lib.namespace = this.global.namespace;
            lib.rtl = this.rtl;
            lib['data_options'] = this.utils.data_options;
            lib['attr_name'] = attr_name;
            lib['add_namespace'] = add_namespace;
            lib['bindings'] = bindings;
            lib['S'] = this.utils.S;
        },

        inherit: function(scope, methods) {
            var methods_arr = methods.split(' ')
              , i = methods_arr.length;

            while (i--) {
                if (this.utils.hasOwnProperty(methods_arr[i])) {
                    scope[methods_arr[i]] = this.utils[methods_arr[i]];
                }
            }
        },

        set_namespace: function() {

            // Description:
            //    Don't bother reading the namespace out of the meta tag
            //    if the namespace has been set globally in javascript
            //
            // Example:
            //    Foundation.global.namespace = 'my-namespace';
            // or make it an empty string:
            //    Foundation.global.namespace = '';
            //
            //

            // If the namespace has not been set (is undefined), try to read it out of the meta element.
            // Otherwise use the globally defined namespace, even if it's empty ('')
            var namespace = (this.global.namespace === undefined) ? $('.foundation-data-attribute-namespace').css('font-family') : this.global.namespace;

            // Finally, if the namsepace is either undefined or false, set it to an empty string.
            // Otherwise use the namespace value.
            this.global.namespace = (namespace === undefined || /false/i.test(namespace)) ? '' : namespace;
        },

        libs: {},

        // methods that can be inherited in libraries
        utils: {

            // Description:
            //    Fast Selector wrapper returns jQuery object. Only use where getElementById
            //    is not available.
            //
            // Arguments:
            //    Selector (String): CSS selector describing the element(s) to be
            //    returned as a jQuery object.
            //
            //    Scope (String): CSS selector describing the area to be searched. Default
            //    is document.
            //
            // Returns:
            //    Element (jQuery Object): jQuery object containing elements matching the
            //    selector within the scope.
            S: S,

            // Description:
            //    Executes a function a max of once every n milliseconds
            //
            // Arguments:
            //    Func (Function): Function to be throttled.
            //
            //    Delay (Integer): Function execution threshold in milliseconds.
            //
            // Returns:
            //    Lazy_function (Function): Function with throttling applied.
            throttle: function(func, delay) {
                var timer = null;

                return function() {
                    var context = this
                      , args = arguments;

                    if (timer == null) {
                        timer = setTimeout(function() {
                            func.apply(context, args);
                            timer = null;
                        }, delay);
                    }
                }
                ;
            },

            // Description:
            //    Executes a function when it stops being invoked for n seconds
            //    Modified version of _.debounce() http://underscorejs.org
            //
            // Arguments:
            //    Func (Function): Function to be debounced.
            //
            //    Delay (Integer): Function execution threshold in milliseconds.
            //
            //    Immediate (Bool): Whether the function should be called at the beginning
            //    of the delay instead of the end. Default is false.
            //
            // Returns:
            //    Lazy_function (Function): Function with debouncing applied.
            debounce: function(func, delay, immediate) {
                var timeout, result;
                return function() {
                    var context = this
                      , args = arguments;
                    var later = function() {
                        timeout = null;
                        if (!immediate) {
                            result = func.apply(context, args);
                        }
                    };
                    var callNow = immediate && !timeout;
                    clearTimeout(timeout);
                    timeout = setTimeout(later, delay);
                    if (callNow) {
                        result = func.apply(context, args);
                    }
                    return result;
                }
                ;
            },

            // Description:
            //    Parses data-options attribute
            //
            // Arguments:
            //    El (jQuery Object): Element to be parsed.
            //
            // Returns:
            //    Options (Javascript Object): Contents of the element's data-options
            //    attribute.
            data_options: function(el, data_attr_name) {
                data_attr_name = data_attr_name || 'options';
                var opts = {}, ii, p, opts_arr, data_options = function(el) {
                    var namespace = Foundation.global.namespace;

                    if (namespace.length > 0) {
                        return el.data(namespace + '-' + data_attr_name);
                    }

                    return el.data(data_attr_name);
                };

                var cached_options = data_options(el);

                if (typeof cached_options === 'object') {
                    return cached_options;
                }

                opts_arr = (cached_options || ':').split(';');
                ii = opts_arr.length;

                function isNumber(o) {
                    return !isNaN(o - 0) && o !== null && o !== '' && o !== false && o !== true;
                }

                function trim(str) {
                    if (typeof str === 'string') {
                        return $.trim(str);
                    }
                    return str;
                }

                while (ii--) {
                    p = opts_arr[ii].split(':');
                    p = [p[0], p.slice(1).join(':')];

                    if (/true/i.test(p[1])) {
                        p[1] = true;
                    }
                    if (/false/i.test(p[1])) {
                        p[1] = false;
                    }
                    if (isNumber(p[1])) {
                        if (p[1].indexOf('.') === -1) {
                            p[1] = parseInt(p[1], 10);
                        } else {
                            p[1] = parseFloat(p[1]);
                        }
                    }

                    if (p.length === 2 && p[0].length > 0) {
                        opts[trim(p[0])] = trim(p[1]);
                    }
                }

                return opts;
            },

            // Description:
            //    Adds JS-recognizable media queries
            //
            // Arguments:
            //    Media (String): Key string for the media query to be stored as in
            //    Foundation.media_queries
            //
            //    Class (String): Class name for the generated <meta> tag
            register_media: function(media, media_class) {
                if (Foundation.media_queries[media] === undefined) {
                    $('head').append('<meta class="' + media_class + '"/>');
                    Foundation.media_queries[media] = removeQuotes($('.' + media_class).css('font-family'));
                }
            },

            // Description:
            //    Add custom CSS within a JS-defined media query
            //
            // Arguments:
            //    Rule (String): CSS rule to be appended to the document.
            //
            //    Media (String): Optional media query string for the CSS rule to be
            //    nested under.
            add_custom_rule: function(rule, media) {
                if (media === undefined && Foundation.stylesheet) {
                    Foundation.stylesheet.insertRule(rule, Foundation.stylesheet.cssRules.length);
                } else {
                    var query = Foundation.media_queries[media];

                    if (query !== undefined) {
                        Foundation.stylesheet.insertRule('@media ' + Foundation.media_queries[media] + '{ ' + rule + ' }', Foundation.stylesheet.cssRules.length);
                    }
                }
            },

            // Description:
            //    Performs a callback function when an image is fully loaded
            //
            // Arguments:
            //    Image (jQuery Object): Image(s) to check if loaded.
            //
            //    Callback (Function): Function to execute when image is fully loaded.
            image_loaded: function(images, callback) {
                var self = this
                  , unloaded = images.length;

                function pictures_has_height(images) {
                    var pictures_number = images.length;

                    for (var i = pictures_number - 1; i >= 0; i--) {
                        if (images.attr('height') === undefined) {
                            return false;
                        }
                        ;
                    }
                    ;
                    return true;
                }

                if (unloaded === 0 || pictures_has_height(images)) {
                    callback(images);
                }

                images.each(function() {
                    single_image_loaded(self.S(this), function() {
                        unloaded -= 1;
                        if (unloaded === 0) {
                            callback(images);
                        }
                    });
                });
            },

            // Description:
            //    Returns a random, alphanumeric string
            //
            // Arguments:
            //    Length (Integer): Length of string to be generated. Defaults to random
            //    integer.
            //
            // Returns:
            //    Rand (String): Pseudo-random, alphanumeric string.
            random_str: function() {
                if (!this.fidx) {
                    this.fidx = 0;
                }
                this.prefix = this.prefix || [(this.name || 'F'), (+new Date).toString(36)].join('-');

                return this.prefix + (this.fidx++).toString(36);
            },

            // Description:
            //    Helper for window.matchMedia
            //
            // Arguments:
            //    mq (String): Media query
            //
            // Returns:
            //    (Boolean): Whether the media query passes or not
            match: function(mq) {
                return window.matchMedia(mq).matches;
            },

            // Description:
            //    Helpers for checking Foundation default media queries with JS
            //
            // Returns:
            //    (Boolean): Whether the media query passes or not

            is_small_up: function() {
                return this.match(Foundation.media_queries.small);
            },

            is_medium_up: function() {
                return this.match(Foundation.media_queries.medium);
            },

            is_large_up: function() {
                return this.match(Foundation.media_queries.large);
            },

            is_xlarge_up: function() {
                return this.match(Foundation.media_queries.xlarge);
            },

            is_xxlarge_up: function() {
                return this.match(Foundation.media_queries.xxlarge);
            },

            is_small_only: function() {
                return !this.is_medium_up() && !this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();
            },

            is_medium_only: function() {
                return this.is_medium_up() && !this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();
            },

            is_large_only: function() {
                return this.is_medium_up() && this.is_large_up() && !this.is_xlarge_up() && !this.is_xxlarge_up();
            },

            is_xlarge_only: function() {
                return this.is_medium_up() && this.is_large_up() && this.is_xlarge_up() && !this.is_xxlarge_up();
            },

            is_xxlarge_only: function() {
                return this.is_medium_up() && this.is_large_up() && this.is_xlarge_up() && this.is_xxlarge_up();
            }
        }
    };

    $.fn.foundation = function() {
        var args = Array.prototype.slice.call(arguments, 0);

        return this.each(function() {
            Foundation.init.apply(Foundation, [this].concat(args));
            return this;
        });
    }
    ;

}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.abide = {
        name: 'abide',

        version: '5.5.3',

        settings: {
            live_validate: true,
            // validate the form as you go
            validate_on_blur: true,
            // validate whenever you focus/blur on an input field
            // validate_on: 'tab', // tab (when user tabs between fields), change (input changes), manual (call custom events)

            focus_on_invalid: true,
            // automatically bring the focus to an invalid input field
            error_labels: true,
            // labels with a for="inputId" will receive an `error` class
            error_class: 'error',
            // labels with a for="inputId" will receive an `error` class
            // the amount of time Abide will take before it validates the form (in ms).
            // smaller time will result in faster validation
            timeout: 1000,
            patterns: {
                alpha: /^[a-zA-Z]+$/,
                alpha_numeric: /^[a-zA-Z0-9]+$/,
                integer: /^[-+]?\d+$/,
                number: /^[-+]?\d*(?:[\.\,]\d+)?$/,

                // amex, visa, diners
                card: /^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/,
                cvv: /^([0-9]){3,4}$/,

                // http://www.whatwg.org/specs/web-apps/current-work/multipage/states-of-the-type-attribute.html#valid-e-mail-address
                email: /^[a-zA-Z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+$/,

                // http://blogs.lse.ac.uk/lti/2008/04/23/a-regular-expression-to-match-any-url/
                url: /^(https?|ftp|file|ssh):\/\/([-;:&=\+\$,\w]+@{1})?([-A-Za-z0-9\.]+)+:?(\d+)?((\/[-\+~%\/\.\w]+)?\??([-\+=&;%@\.\w]+)?#?([\w]+)?)?/,
                // abc.de
                domain: /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,8}$/,

                datetime: /^([0-2][0-9]{3})\-([0-1][0-9])\-([0-3][0-9])T([0-5][0-9])\:([0-5][0-9])\:([0-5][0-9])(Z|([\-\+]([0-1][0-9])\:00))$/,
                // YYYY-MM-DD
                date: /(?:19|20)[0-9]{2}-(?:(?:0[1-9]|1[0-2])-(?:0[1-9]|1[0-9]|2[0-9])|(?:(?!02)(?:0[1-9]|1[0-2])-(?:30))|(?:(?:0[13578]|1[02])-31))$/,
                // HH:MM:SS
                time: /^(0[0-9]|1[0-9]|2[0-3])(:[0-5][0-9]){2}$/,
                dateISO: /^\d{4}[\/\-]\d{1,2}[\/\-]\d{1,2}$/,
                // MM/DD/YYYY
                month_day_year: /^(0[1-9]|1[012])[- \/.](0[1-9]|[12][0-9]|3[01])[- \/.]\d{4}$/,
                // DD/MM/YYYY
                day_month_year: /^(0[1-9]|[12][0-9]|3[01])[- \/.](0[1-9]|1[012])[- \/.]\d{4}$/,

                // #FFF or #FFFFFF
                color: /^#?([a-fA-F0-9]{6}|[a-fA-F0-9]{3})$/
            },
            validators: {
                equalTo: function(el, required, parent) {
                    var from = document.getElementById(el.getAttribute(this.add_namespace('data-equalto'))).value
                      , to = el.value
                      , valid = (from === to);

                    return valid;
                }
            }
        },

        timer: null,

        init: function(scope, method, options) {
            this.bindings(method, options);
        },

        events: function(scope) {
            var self = this
              , form = self.S(scope).attr('novalidate', 'novalidate')
              , settings = form.data(this.attr_name(true) + '-init') || {};

            this.invalid_attr = this.add_namespace('data-invalid');

            function validate(originalSelf, e) {
                clearTimeout(self.timer);
                self.timer = setTimeout(function() {
                    self.validate([originalSelf], e);
                }
                .bind(originalSelf), settings.timeout);
            }

            form.off('.abide').on('submit.fndtn.abide', function(e) {
                var is_ajax = /ajax/i.test(self.S(this).attr(self.attr_name()));
                return self.validate(self.S(this).find('input, textarea, select').not(":hidden, [data-abide-ignore]").get(), e, is_ajax);
            }).on('validate.fndtn.abide', function(e) {
                if (settings.validate_on === 'manual') {
                    self.validate([e.target], e);
                }
            }).on('reset', function(e) {
                return self.reset($(this), e);
            }).find('input, textarea, select').not(":hidden, [data-abide-ignore]").off('.abide').on('blur.fndtn.abide change.fndtn.abide', function(e) {
                var id = this.getAttribute('id')
                  , eqTo = form.find('[data-equalto="' + id + '"]');
                // old settings fallback
                // will be deprecated with F6 release
                if (settings.validate_on_blur && settings.validate_on_blur === true) {
                    validate(this, e);
                }
                // checks if there is an equalTo equivalent related by id
                if (typeof eqTo.get(0) !== "undefined" && eqTo.val().length) {
                    validate(eqTo.get(0), e);
                }
                // new settings combining validate options into one setting
                if (settings.validate_on === 'change') {
                    validate(this, e);
                }
            }).on('keydown.fndtn.abide', function(e) {
                var id = this.getAttribute('id')
                  , eqTo = form.find('[data-equalto="' + id + '"]');
                // old settings fallback
                // will be deprecated with F6 release
                if (settings.live_validate && settings.live_validate === true && e.which != 9) {
                    validate(this, e);
                }
                // checks if there is an equalTo equivalent related by id
                if (typeof eqTo.get(0) !== "undefined" && eqTo.val().length) {
                    validate(eqTo.get(0), e);
                }
                // new settings combining validate options into one setting
                if (settings.validate_on === 'tab' && e.which === 9) {
                    validate(this, e);
                } else if (settings.validate_on === 'change') {
                    validate(this, e);
                }
            }).on('focus', function(e) {
                if (navigator.userAgent.match(/iPad|iPhone|Android|BlackBerry|Windows Phone|webOS/i)) {
                    $('html, body').animate({
                        scrollTop: $(e.target).offset().top
                    }, 100);
                }
            });
        },

        reset: function(form, e) {
            var self = this;
            form.removeAttr(self.invalid_attr);

            $('[' + self.invalid_attr + ']', form).removeAttr(self.invalid_attr);
            $('.' + self.settings.error_class, form).not('small').removeClass(self.settings.error_class);
            $(':input', form).not(':button, :submit, :reset, :hidden, [data-abide-ignore]').val('').removeAttr(self.invalid_attr);
        },

        validate: function(els, e, is_ajax) {
            var validations = this.parse_patterns(els)
              , validation_count = validations.length
              , form = this.S(els[0]).closest('form')
              , submit_event = /submit/.test(e.type);

            // Has to count up to make sure the focus gets applied to the top error
            for (var i = 0; i < validation_count; i++) {
                if (!validations[i] && (submit_event || is_ajax)) {
                    if (this.settings.focus_on_invalid) {
                        els[i].focus();
                    }
                    form.trigger('invalid.fndtn.abide');
                    this.S(els[i]).closest('form').attr(this.invalid_attr, '');
                    return false;
                }
            }

            if (submit_event || is_ajax) {
                form.trigger('valid.fndtn.abide');
            }

            form.removeAttr(this.invalid_attr);

            if (is_ajax) {
                return false;
            }

            return true;
        },

        parse_patterns: function(els) {
            var i = els.length
              , el_patterns = [];

            while (i--) {
                el_patterns.push(this.pattern(els[i]));
            }

            return this.check_validation_and_apply_styles(el_patterns);
        },

        pattern: function(el) {
            var type = el.getAttribute('type')
              , required = typeof el.getAttribute('required') === 'string';

            var pattern = el.getAttribute('pattern') || '';

            if (this.settings.patterns.hasOwnProperty(pattern) && pattern.length > 0) {
                return [el, this.settings.patterns[pattern], required];
            } else if (pattern.length > 0) {
                return [el, new RegExp(pattern), required];
            }

            if (this.settings.patterns.hasOwnProperty(type)) {
                return [el, this.settings.patterns[type], required];
            }

            pattern = /.*/;

            return [el, pattern, required];
        },

        // TODO: Break this up into smaller methods, getting hard to read.
        check_validation_and_apply_styles: function(el_patterns) {
            var i = el_patterns.length
              , validations = [];
            if (i == 0) {
                return validations;
            }
            var form = this.S(el_patterns[0][0]).closest('[data-' + this.attr_name(true) + ']')
              , settings = form.data(this.attr_name(true) + '-init') || {};
            while (i--) {
                var el = el_patterns[i][0]
                  , required = el_patterns[i][2]
                  , value = el.value.trim()
                  , direct_parent = this.S(el).parent()
                  , validator = el.getAttribute(this.add_namespace('data-abide-validator'))
                  , is_radio = el.type === 'radio'
                  , is_checkbox = el.type === 'checkbox'
                  , label = this.S('label[for="' + el.getAttribute('id') + '"]')
                  , valid_length = (required) ? (el.value.length > 0) : true
                  , el_validations = [];

                var parent, valid;

                // support old way to do equalTo validations
                if (el.getAttribute(this.add_namespace('data-equalto'))) {
                    validator = 'equalTo'
                }

                if (!direct_parent.is('label')) {
                    parent = direct_parent;
                } else {
                    parent = direct_parent.parent();
                }

                if (is_radio && required) {
                    el_validations.push(this.valid_radio(el, required));
                } else if (is_checkbox && required) {
                    el_validations.push(this.valid_checkbox(el, required));

                } else if (validator) {
                    // Validate using each of the specified (space-delimited) validators.
                    var validators = validator.split(' ');
                    var last_valid = true
                      , all_valid = true;
                    for (var iv = 0; iv < validators.length; iv++) {
                        valid = this.settings.validators[validators[iv]].apply(this, [el, required, parent])
                        el_validations.push(valid);
                        all_valid = valid && last_valid;
                        last_valid = valid;
                    }
                    if (all_valid) {
                        this.S(el).removeAttr(this.invalid_attr);
                        parent.removeClass('error');
                        if (label.length > 0 && this.settings.error_labels) {
                            label.removeClass(this.settings.error_class).removeAttr('role');
                        }
                        $(el).triggerHandler('valid');
                    } else {
                        this.S(el).attr(this.invalid_attr, '');
                        parent.addClass('error');
                        if (label.length > 0 && this.settings.error_labels) {
                            label.addClass(this.settings.error_class).attr('role', 'alert');
                        }
                        $(el).triggerHandler('invalid');
                    }
                } else {

                    if (el_patterns[i][1].test(value) && valid_length || !required && el.value.length < 1 || $(el).attr('disabled')) {
                        el_validations.push(true);
                    } else {
                        el_validations.push(false);
                    }

                    el_validations = [el_validations.every(function(valid) {
                        return valid;
                    })];
                    if (el_validations[0]) {
                        this.S(el).removeAttr(this.invalid_attr);
                        el.setAttribute('aria-invalid', 'false');
                        el.removeAttribute('aria-describedby');
                        parent.removeClass(this.settings.error_class);
                        if (label.length > 0 && this.settings.error_labels) {
                            label.removeClass(this.settings.error_class).removeAttr('role');
                        }
                        $(el).triggerHandler('valid');
                    } else {
                        this.S(el).attr(this.invalid_attr, '');
                        el.setAttribute('aria-invalid', 'true');

                        // Try to find the error associated with the input
                        var errorElem = parent.find('small.' + this.settings.error_class, 'span.' + this.settings.error_class);
                        var errorID = errorElem.length > 0 ? errorElem[0].id : '';
                        if (errorID.length > 0) {
                            el.setAttribute('aria-describedby', errorID);
                        }

                        // el.setAttribute('aria-describedby', $(el).find('.error')[0].id);
                        parent.addClass(this.settings.error_class);
                        if (label.length > 0 && this.settings.error_labels) {
                            label.addClass(this.settings.error_class).attr('role', 'alert');
                        }
                        $(el).triggerHandler('invalid');
                    }
                }
                validations = validations.concat(el_validations);
            }

            return validations;
        },

        valid_checkbox: function(el, required) {
            var el = this.S(el)
              , valid = (el.is(':checked') || !required || el.get(0).getAttribute('disabled'));

            if (valid) {
                el.removeAttr(this.invalid_attr).parent().removeClass(this.settings.error_class);
                $(el).triggerHandler('valid');
            } else {
                el.attr(this.invalid_attr, '').parent().addClass(this.settings.error_class);
                $(el).triggerHandler('invalid');
            }

            return valid;
        },

        valid_radio: function(el, required) {
            var name = el.getAttribute('name')
              , group = this.S(el).closest('[data-' + this.attr_name(true) + ']').find("[name='" + name + "']")
              , count = group.length
              , valid = false
              , disabled = false;

            // Has to count up to make sure the focus gets applied to the top error
            for (var i = 0; i < count; i++) {
                if (group[i].getAttribute('disabled')) {
                    disabled = true;
                    valid = true;
                } else {
                    if (group[i].checked) {
                        valid = true;
                    } else {
                        if (disabled) {
                            valid = false;
                        }
                    }
                }
            }

            // Has to count up to make sure the focus gets applied to the top error
            for (var i = 0; i < count; i++) {
                if (valid) {
                    this.S(group[i]).removeAttr(this.invalid_attr).parent().removeClass(this.settings.error_class);
                    $(group[i]).triggerHandler('valid');
                } else {
                    this.S(group[i]).attr(this.invalid_attr, '').parent().addClass(this.settings.error_class);
                    $(group[i]).triggerHandler('invalid');
                }
            }

            return valid;
        },

        valid_equal: function(el, required, parent) {
            var from = document.getElementById(el.getAttribute(this.add_namespace('data-equalto'))).value
              , to = el.value
              , valid = (from === to);

            if (valid) {
                this.S(el).removeAttr(this.invalid_attr);
                parent.removeClass(this.settings.error_class);
                if (label.length > 0 && settings.error_labels) {
                    label.removeClass(this.settings.error_class);
                }
            } else {
                this.S(el).attr(this.invalid_attr, '');
                parent.addClass(this.settings.error_class);
                if (label.length > 0 && settings.error_labels) {
                    label.addClass(this.settings.error_class);
                }
            }

            return valid;
        },

        valid_oneof: function(el, required, parent, doNotValidateOthers) {
            var el = this.S(el)
              , others = this.S('[' + this.add_namespace('data-oneof') + ']')
              , valid = others.filter(':checked').length > 0;

            if (valid) {
                el.removeAttr(this.invalid_attr).parent().removeClass(this.settings.error_class);
            } else {
                el.attr(this.invalid_attr, '').parent().addClass(this.settings.error_class);
            }

            if (!doNotValidateOthers) {
                var _this = this;
                others.each(function() {
                    _this.valid_oneof.call(_this, this, null, null, true);
                });
            }

            return valid;
        },

        reflow: function(scope, options) {
            var self = this
              , form = self.S('[' + this.attr_name() + ']').attr('novalidate', 'novalidate');
            self.S(form).each(function(idx, el) {
                self.events(el);
            });
        }
    };
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.alert = {
        name: 'alert',

        version: '5.5.3',

        settings: {
            callback: function() {}
        },

        init: function(scope, method, options) {
            this.bindings(method, options);
        },

        events: function() {
            var self = this
              , S = this.S;

            $(this.scope).off('.alert').on('click.fndtn.alert', '[' + this.attr_name() + '] .close', function(e) {
                var alertBox = S(this).closest('[' + self.attr_name() + ']')
                  , settings = alertBox.data(self.attr_name(true) + '-init') || self.settings;

                e.preventDefault();
                if (Modernizr.csstransitions) {
                    alertBox.addClass('alert-close');
                    alertBox.on('transitionend webkitTransitionEnd oTransitionEnd', function(e) {
                        S(this).trigger('close.fndtn.alert').remove();
                        settings.callback();
                    });
                } else {
                    alertBox.fadeOut(300, function() {
                        S(this).trigger('close.fndtn.alert').remove();
                        settings.callback();
                    });
                }
            });
        },

        reflow: function() {}
    };
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.clearing = {
        name: 'clearing',

        version: '5.5.3',

        settings: {
            templates: {
                viewing: '<a href="#" class="clearing-close">&times;</a>' + '<div class="visible-img" style="display: none"><div class="clearing-touch-label"></div><img src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs%3D" alt="" />' + '<p class="clearing-caption"></p><a href="#" class="clearing-main-prev"><span></span></a>' + '<a href="#" class="clearing-main-next"><span></span></a></div>' + '<img class="clearing-preload-next" style="display: none" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs%3D" alt="" />' + '<img class="clearing-preload-prev" style="display: none" src="data:image/gif;base64,R0lGODlhAQABAAD/ACwAAAAAAQABAAACADs%3D" alt="" />'
            },

            // comma delimited list of selectors that, on click, will close clearing,
            // add 'div.clearing-blackout, div.visible-img' to close on background click
            close_selectors: '.clearing-close, div.clearing-blackout',

            // Default to the entire li element.
            open_selectors: '',

            // Image will be skipped in carousel.
            skip_selector: '',

            touch_label: '',

            // event initializer and locks
            init: false,
            locked: false
        },

        init: function(scope, method, options) {
            var self = this;
            Foundation.inherit(this, 'throttle image_loaded');

            this.bindings(method, options);

            if (self.S(this.scope).is('[' + this.attr_name() + ']')) {
                this.assemble(self.S('li', this.scope));
            } else {
                self.S('[' + this.attr_name() + ']', this.scope).each(function() {
                    self.assemble(self.S('li', this));
                });
            }
        },

        events: function(scope) {
            var self = this
              , S = self.S
              , $scroll_container = $('.scroll-container');

            if ($scroll_container.length > 0) {
                this.scope = $scroll_container;
            }

            S(this.scope).off('.clearing').on('click.fndtn.clearing', 'ul[' + this.attr_name() + '] li ' + this.settings.open_selectors, function(e, current, target) {
                var current = current || S(this)
                  , target = target || current
                  , next = current.next('li')
                  , settings = current.closest('[' + self.attr_name() + ']').data(self.attr_name(true) + '-init')
                  , image = S(e.target);

                e.preventDefault();

                if (!settings) {
                    self.init();
                    settings = current.closest('[' + self.attr_name() + ']').data(self.attr_name(true) + '-init');
                }

                // if clearing is open and the current image is
                // clicked, go to the next image in sequence
                if (target.hasClass('visible') && current[0] === target[0] && next.length > 0 && self.is_open(current)) {
                    target = next;
                    image = S('img', target);
                }

                // set current and target to the clicked li if not otherwise defined.
                self.open(image, current, target);
                self.update_paddles(target);
            })
            .on('click.fndtn.clearing', '.clearing-main-next', function(e) {
                self.nav(e, 'next')
            }).on('click.fndtn.clearing', '.clearing-main-prev', function(e) {
                self.nav(e, 'prev')
            }).on('click.fndtn.clearing', this.settings.close_selectors, function(e) {
                Foundation.libs.clearing.close(e, this)
            });

            $(document).on('keydown.fndtn.clearing', function(e) {
                self.keydown(e)
            });

            S(window).off('.clearing').on('resize.fndtn.clearing', function() {
                self.resize()
            });

            this.swipe_events(scope);
        },

        swipe_events: function(scope) {
            var self = this
              , S = self.S;

            S(this.scope).on('touchstart.fndtn.clearing', '.visible-img', function(e) {
                if (!e.touches) {
                    e = e.originalEvent;
                }
                var data = {
                    start_page_x: e.touches[0].pageX,
                    start_page_y: e.touches[0].pageY,
                    start_time: (new Date()).getTime(),
                    delta_x: 0,
                    is_scrolling: undefined
                };

                S(this).data('swipe-transition', data);
                e.stopPropagation();
            }).on('touchmove.fndtn.clearing', '.visible-img', function(e) {
                if (!e.touches) {
                    e = e.originalEvent;
                }
                // Ignore pinch/zoom events
                if (e.touches.length > 1 || e.scale && e.scale !== 1) {
                    return;
                }

                var data = S(this).data('swipe-transition');

                if (typeof data === 'undefined') {
                    data = {};
                }

                data.delta_x = e.touches[0].pageX - data.start_page_x;

                if (Foundation.rtl) {
                    data.delta_x = -data.delta_x;
                }

                if (typeof data.is_scrolling === 'undefined') {
                    data.is_scrolling = !!(data.is_scrolling || Math.abs(data.delta_x) < Math.abs(e.touches[0].pageY - data.start_page_y));
                }

                if (!data.is_scrolling && !data.active) {
                    e.preventDefault();
                    var direction = (data.delta_x < 0) ? 'next' : 'prev';
                    data.active = true;
                    self.nav(e, direction);
                }
            }).on('touchend.fndtn.clearing', '.visible-img', function(e) {
                S(this).data('swipe-transition', {});
                e.stopPropagation();
            });
        },

        assemble: function($li) {
            var $el = $li.parent();

            if ($el.parent().hasClass('carousel')) {
                return;
            }

            $el.after('<div id="foundationClearingHolder"></div>');

            var grid = $el.detach()
              , grid_outerHTML = '';

            if (grid[0] == null) {
                return;
            } else {
                grid_outerHTML = grid[0].outerHTML;
            }

            var holder = this.S('#foundationClearingHolder')
              , settings = $el.data(this.attr_name(true) + '-init')
              , data = {
                grid: '<div class="carousel">' + grid_outerHTML + '</div>',
                viewing: settings.templates.viewing
            }
              , wrapper = '<div class="clearing-assembled"><div>' + data.viewing + data.grid + '</div></div>'
              , touch_label = this.settings.touch_label;

            if (Modernizr.touch) {
                wrapper = $(wrapper).find('.clearing-touch-label').html(touch_label).end();
            }

            holder.after(wrapper).remove();
        },

        open: function($image, current, target) {
            var self = this
              , body = $(document.body)
              , root = target.closest('.clearing-assembled')
              , container = self.S('div', root).first()
              , visible_image = self.S('.visible-img', container)
              , image = self.S('img', visible_image).not($image)
              , label = self.S('.clearing-touch-label', container)
              , error = false
              , loaded = {};

            // Event to disable scrolling on touch devices when Clearing is activated
            $('body').on('touchmove', function(e) {
                e.preventDefault();
            });

            image.error(function() {
                error = true;
            });

            function startLoad() {
                setTimeout(function() {
                    this.image_loaded(image, function() {
                        if (image.outerWidth() === 1 && !error) {
                            startLoad.call(this);
                        } else {
                            cb.call(this, image);
                        }
                    }
                    .bind(this));
                }
                .bind(this), 100);
            }

            function cb(image) {
                var $image = $(image);
                $image.css('visibility', 'visible');
                $image.trigger('imageVisible');
                // toggle the gallery
                body.css('overflow', 'hidden');
                root.addClass('clearing-blackout');
                container.addClass('clearing-container');
                visible_image.show();
                this.fix_height(target).caption(self.S('.clearing-caption', visible_image), self.S('img', target)).center_and_label(image, label).shift(current, target, function() {
                    target.closest('li').siblings().removeClass('visible');
                    target.closest('li').addClass('visible');
                });
                visible_image.trigger('opened.fndtn.clearing')
            }

            if (!this.locked()) {
                visible_image.trigger('open.fndtn.clearing');
                // set the image to the selected thumbnail
                loaded = this.load($image);
                if (loaded.interchange) {
                    image.attr('data-interchange', loaded.interchange).foundation('interchange', 'reflow');
                } else {
                    image.attr('src', loaded.src).attr('data-interchange', '');
                }
                image.css('visibility', 'hidden');

                startLoad.call(this);
            }
        },

        close: function(e, el) {
            e.preventDefault();

            var root = (function(target) {
                if (/blackout/.test(target.selector)) {
                    return target;
                } else {
                    return target.closest('.clearing-blackout');
                }
            }($(el))), body = $(document.body), container, visible_image;

            if (el === e.target && root) {
                body.css('overflow', '');
                container = $('div', root).first();
                visible_image = $('.visible-img', container);
                visible_image.trigger('close.fndtn.clearing');
                this.settings.prev_index = 0;
                $('ul[' + this.attr_name() + ']', root).attr('style', '').closest('.clearing-blackout').removeClass('clearing-blackout');
                container.removeClass('clearing-container');
                visible_image.hide();
                visible_image.trigger('closed.fndtn.clearing');
            }

            // Event to re-enable scrolling on touch devices
            $('body').off('touchmove');

            return false;
        },

        is_open: function(current) {
            return current.parent().prop('style').length > 0;
        },

        keydown: function(e) {
            var clearing = $('.clearing-blackout ul[' + this.attr_name() + ']')
              , NEXT_KEY = this.rtl ? 37 : 39
              , PREV_KEY = this.rtl ? 39 : 37
              , ESC_KEY = 27;

            if (e.which === NEXT_KEY) {
                this.go(clearing, 'next');
            }
            if (e.which === PREV_KEY) {
                this.go(clearing, 'prev');
            }
            if (e.which === ESC_KEY) {
                this.S('a.clearing-close').trigger('click.fndtn.clearing');
            }
        },

        nav: function(e, direction) {
            var clearing = $('ul[' + this.attr_name() + ']', '.clearing-blackout');

            e.preventDefault();
            this.go(clearing, direction);
        },

        resize: function() {
            var image = $('img', '.clearing-blackout .visible-img')
              , label = $('.clearing-touch-label', '.clearing-blackout');

            if (image.length) {
                this.center_and_label(image, label);
                image.trigger('resized.fndtn.clearing')
            }
        },

        // visual adjustments
        fix_height: function(target) {
            var lis = target.parent().children()
              , self = this;

            lis.each(function() {
                var li = self.S(this)
                  , image = li.find('img');

                if (li.height() > image.outerHeight()) {
                    li.addClass('fix-height');
                }
            }).closest('ul').width(lis.length * 100 + '%');

            return this;
        },

        update_paddles: function(target) {
            target = target.closest('li');
            var visible_image = target.closest('.carousel').siblings('.visible-img');

            if (target.next().length > 0) {
                this.S('.clearing-main-next', visible_image).removeClass('disabled');
            } else {
                this.S('.clearing-main-next', visible_image).addClass('disabled');
            }

            if (target.prev().length > 0) {
                this.S('.clearing-main-prev', visible_image).removeClass('disabled');
            } else {
                this.S('.clearing-main-prev', visible_image).addClass('disabled');
            }
        },

        center_and_label: function(target, label) {
            if (!this.rtl && label.length > 0) {
                label.css({
                    marginLeft: -(label.outerWidth() / 2),
                    marginTop: -(target.outerHeight() / 2) - label.outerHeight() - 10
                });
            } else {
                label.css({
                    marginRight: -(label.outerWidth() / 2),
                    marginTop: -(target.outerHeight() / 2) - label.outerHeight() - 10,
                    left: 'auto',
                    right: '50%'
                });
            }
            return this;
        },

        // image loading and preloading

        load: function($image) {
            var href, interchange, closest_a;

            if ($image[0].nodeName === 'A') {
                href = $image.attr('href');
                interchange = $image.data('clearing-interchange');
            } else {
                closest_a = $image.closest('a');
                href = closest_a.attr('href');
                interchange = closest_a.data('clearing-interchange');
            }

            this.preload($image);

            return {
                'src': href ? href : $image.attr('src'),
                'interchange': href ? interchange : $image.data('clearing-interchange')
            }
        },

        preload: function($image) {
            this.img($image.closest('li').next(), 'next').img($image.closest('li').prev(), 'prev');
        },

        img: function(img, sibling_type) {
            if (img.length) {
                var preload_img = $('.clearing-preload-' + sibling_type), new_a = this.S('a', img), src, interchange, image;

                if (new_a.length) {
                    src = new_a.attr('href');
                    interchange = new_a.data('clearing-interchange');
                } else {
                    image = this.S('img', img);
                    src = image.attr('src');
                    interchange = image.data('clearing-interchange');
                }

                if (interchange) {
                    preload_img.attr('data-interchange', interchange);
                } else {
                    preload_img.attr('src', src);
                    preload_img.attr('data-interchange', '');
                }
            }
            return this;
        },

        // image caption

        caption: function(container, $image) {
            var caption = $image.attr('data-caption');

            if (caption) {
                var containerPlain = container.get(0);
                containerPlain.innerHTML = caption;
                container.show();
            } else {
                container.text('').hide();
            }
            return this;
        },

        // directional methods

        go: function($ul, direction) {
            var current = this.S('.visible', $ul)
              , target = current[direction]();

            // Check for skip selector.
            if (this.settings.skip_selector && target.find(this.settings.skip_selector).length != 0) {
                target = target[direction]();
            }

            if (target.length) {
                this.S('img', target).trigger('click.fndtn.clearing', [current, target]).trigger('change.fndtn.clearing');
            }
        },

        shift: function(current, target, callback) {
            var clearing = target.parent(), old_index = this.settings.prev_index || target.index(), direction = this.direction(clearing, current, target), dir = this.rtl ? 'right' : 'left', left = parseInt(clearing.css('left'), 10), width = target.outerWidth(), skip_shift;

            var dir_obj = {};

            // we use jQuery animate instead of CSS transitions because we
            // need a callback to unlock the next animation
            // needs support for RTL **
            if (target.index() !== old_index && !/skip/.test(direction)) {
                if (/left/.test(direction)) {
                    this.lock();
                    dir_obj[dir] = left + width;
                    clearing.animate(dir_obj, 300, this.unlock());
                } else if (/right/.test(direction)) {
                    this.lock();
                    dir_obj[dir] = left - width;
                    clearing.animate(dir_obj, 300, this.unlock());
                }
            } else if (/skip/.test(direction)) {
                // the target image is not adjacent to the current image, so
                // do we scroll right or not
                skip_shift = target.index() - this.settings.up_count;
                this.lock();

                if (skip_shift > 0) {
                    dir_obj[dir] = -(skip_shift * width);
                    clearing.animate(dir_obj, 300, this.unlock());
                } else {
                    dir_obj[dir] = 0;
                    clearing.animate(dir_obj, 300, this.unlock());
                }
            }

            callback();
        },

        direction: function($el, current, target) {
            var lis = this.S('li', $el), li_width = lis.outerWidth() + (lis.outerWidth() / 4), up_count = Math.floor(this.S('.clearing-container').outerWidth() / li_width) - 1, target_index = lis.index(target), response;

            this.settings.up_count = up_count;

            if (this.adjacent(this.settings.prev_index, target_index)) {
                if ((target_index > up_count) && target_index > this.settings.prev_index) {
                    response = 'right';
                } else if ((target_index > up_count - 1) && target_index <= this.settings.prev_index) {
                    response = 'left';
                } else {
                    response = false;
                }
            } else {
                response = 'skip';
            }

            this.settings.prev_index = target_index;

            return response;
        },

        adjacent: function(current_index, target_index) {
            for (var i = target_index + 1; i >= target_index - 1; i--) {
                if (i === current_index) {
                    return true;
                }
            }
            return false;
        },

        // lock management

        lock: function() {
            this.settings.locked = true;
        },

        unlock: function() {
            this.settings.locked = false;
        },

        locked: function() {
            return this.settings.locked;
        },

        off: function() {
            this.S(this.scope).off('.fndtn.clearing');
            this.S(window).off('.fndtn.clearing');
        },

        reflow: function() {
            this.init();
        }
    };

}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.dropdown = {
        name: 'dropdown',

        version: '5.5.3',

        settings: {
            active_class: 'open',
            disabled_class: 'disabled',
            mega_class: 'mega',
            align: 'bottom',
            is_hover: false,
            hover_timeout: 150,
            opened: function() {},
            closed: function() {}
        },

        init: function(scope, method, options) {
            Foundation.inherit(this, 'throttle');

            $.extend(true, this.settings, method, options);
            this.bindings(method, options);
        },

        events: function(scope) {
            var self = this
              , S = self.S;

            S(this.scope).off('.dropdown').on('click.fndtn.dropdown', '[' + this.attr_name() + ']', function(e) {
                var settings = S(this).data(self.attr_name(true) + '-init') || self.settings;
                if (!settings.is_hover || Modernizr.touch) {
                    e.preventDefault();
                    if (S(this).parent('[data-reveal-id]').length) {
                        e.stopPropagation();
                    }
                    self.toggle($(this));
                }
            }).on('mouseenter.fndtn.dropdown', '[' + this.attr_name() + '], [' + this.attr_name() + '-content]', function(e) {
                var $this = S(this), dropdown, target;

                clearTimeout(self.timeout);

                if ($this.data(self.data_attr())) {
                    dropdown = S('#' + $this.data(self.data_attr()));
                    target = $this;
                } else {
                    dropdown = $this;
                    target = S('[' + self.attr_name() + '="' + dropdown.attr('id') + '"]');
                }

                var settings = target.data(self.attr_name(true) + '-init') || self.settings;

                if (S(e.currentTarget).data(self.data_attr()) && settings.is_hover) {
                    self.closeall.call(self);
                }

                if (settings.is_hover) {
                    self.open.apply(self, [dropdown, target]);
                }
            }).on('mouseleave.fndtn.dropdown', '[' + this.attr_name() + '], [' + this.attr_name() + '-content]', function(e) {
                var $this = S(this);
                var settings;

                if ($this.data(self.data_attr())) {
                    settings = $this.data(self.data_attr(true) + '-init') || self.settings;
                } else {
                    var target = S('[' + self.attr_name() + '="' + S(this).attr('id') + '"]')
                      , settings = target.data(self.attr_name(true) + '-init') || self.settings;
                }

                self.timeout = setTimeout(function() {
                    if ($this.data(self.data_attr())) {
                        if (settings.is_hover) {
                            self.close.call(self, S('#' + $this.data(self.data_attr())));
                        }
                    } else {
                        if (settings.is_hover) {
                            self.close.call(self, $this);
                        }
                    }
                }
                .bind(this), settings.hover_timeout);
            }).on('click.fndtn.dropdown', function(e) {
                var parent = S(e.target).closest('[' + self.attr_name() + '-content]');
                var links = parent.find('a');

                if (links.length > 0 && parent.attr('aria-autoclose') !== 'false') {
                    self.close.call(self, S('[' + self.attr_name() + '-content]'));
                }

                if (e.target !== document && !$.contains(document.documentElement, e.target)) {
                    return;
                }

                if (S(e.target).closest('[' + self.attr_name() + ']').length > 0) {
                    return;
                }

                if (!(S(e.target).data('revealId')) && (parent.length > 0 && (S(e.target).is('[' + self.attr_name() + '-content]') || $.contains(parent.first()[0], e.target)))) {
                    e.stopPropagation();
                    return;
                }

                self.close.call(self, S('[' + self.attr_name() + '-content]'));
            }).on('opened.fndtn.dropdown', '[' + self.attr_name() + '-content]', function() {
                self.settings.opened.call(this);
            }).on('closed.fndtn.dropdown', '[' + self.attr_name() + '-content]', function() {
                self.settings.closed.call(this);
            });

            S(window).off('.dropdown').on('resize.fndtn.dropdown', self.throttle(function() {
                self.resize.call(self);
            }, 50));

            this.resize();
        },

        close: function(dropdown) {
            var self = this;
            dropdown.each(function(idx) {
                var original_target = $('[' + self.attr_name() + '=' + dropdown[idx].id + ']') || $('aria-controls=' + dropdown[idx].id + ']');
                original_target.attr('aria-expanded', 'false');
                if (self.S(this).hasClass(self.settings.active_class)) {
                    self.S(this).css(Foundation.rtl ? 'right' : 'left', '-99999px').attr('aria-hidden', 'true').removeClass(self.settings.active_class).prev('[' + self.attr_name() + ']').removeClass(self.settings.active_class).removeData('target');

                    self.S(this).trigger('closed.fndtn.dropdown', [dropdown]);
                }
            });
            dropdown.removeClass('f-open-' + this.attr_name(true));
        },

        closeall: function() {
            var self = this;
            $.each(self.S('.f-open-' + this.attr_name(true)), function() {
                self.close.call(self, self.S(this));
            });
        },

        open: function(dropdown, target) {
            this.css(dropdown.addClass(this.settings.active_class), target);
            dropdown.prev('[' + this.attr_name() + ']').addClass(this.settings.active_class);
            dropdown.data('target', target.get(0)).trigger('opened.fndtn.dropdown', [dropdown, target]);
            dropdown.attr('aria-hidden', 'false');
            target.attr('aria-expanded', 'true');
            dropdown.focus();
            dropdown.addClass('f-open-' + this.attr_name(true));
        },

        data_attr: function() {
            if (this.namespace.length > 0) {
                return this.namespace + '-' + this.name;
            }

            return this.name;
        },

        toggle: function(target) {
            if (target.hasClass(this.settings.disabled_class)) {
                return;
            }
            var dropdown = this.S('#' + target.data(this.data_attr()));
            if (dropdown.length === 0) {
                // No dropdown found, not continuing
                return;
            }

            this.close.call(this, this.S('[' + this.attr_name() + '-content]').not(dropdown));

            if (dropdown.hasClass(this.settings.active_class)) {
                this.close.call(this, dropdown);
                if (dropdown.data('target') !== target.get(0)) {
                    this.open.call(this, dropdown, target);
                }
            } else {
                this.open.call(this, dropdown, target);
            }
        },

        resize: function() {
            var dropdown = this.S('[' + this.attr_name() + '-content].open');
            var target = $(dropdown.data("target"));

            if (dropdown.length && target.length) {
                this.css(dropdown, target);
            }
        },

        css: function(dropdown, target) {
            var left_offset = Math.max((target.width() - dropdown.width()) / 2, 8)
              , settings = target.data(this.attr_name(true) + '-init') || this.settings
              , parentOverflow = dropdown.parent().css('overflow-y') || dropdown.parent().css('overflow');

            this.clear_idx();

            if (this.small()) {
                var p = this.dirs.bottom.call(dropdown, target, settings);

                dropdown.attr('style', '').removeClass('drop-left drop-right drop-top').css({
                    position: 'absolute',
                    width: '95%',
                    'max-width': 'none',
                    top: p.top
                });

                dropdown.css(Foundation.rtl ? 'right' : 'left', left_offset);
            }// detect if dropdown is in an overflow container
            else if (parentOverflow !== 'visible') {
                var offset = target[0].offsetTop + target[0].offsetHeight;

                dropdown.attr('style', '').css({
                    position: 'absolute',
                    top: offset
                });

                dropdown.css(Foundation.rtl ? 'right' : 'left', left_offset);
            } else {

                this.style(dropdown, target, settings);
            }

            return dropdown;
        },

        style: function(dropdown, target, settings) {
            var css = $.extend({
                position: 'absolute'
            }, this.dirs[settings.align].call(dropdown, target, settings));

            dropdown.attr('style', '').css(css);
        },

        // return CSS property object
        // `this` is the dropdown
        dirs: {
            // Calculate target offset
            _base: function(t, s) {
                var o_p = this.offsetParent()
                  , o = o_p.offset()
                  , p = t.offset();

                p.top -= o.top;
                p.left -= o.left;

                //set some flags on the p object to pass along
                p.missRight = false;
                p.missTop = false;
                p.missLeft = false;
                p.leftRightFlag = false;

                //lets see if the panel will be off the screen
                //get the actual width of the page and store it
                var actualBodyWidth;
                var windowWidth = window.innerWidth;

                if (document.getElementsByClassName('row')[0]) {
                    actualBodyWidth = document.getElementsByClassName('row')[0].clientWidth;
                } else {
                    actualBodyWidth = windowWidth;
                }

                var actualMarginWidth = (windowWidth - actualBodyWidth) / 2;
                var actualBoundary = actualBodyWidth;

                if (!this.hasClass('mega') && !s.ignore_repositioning) {
                    var outerWidth = this.outerWidth();
                    var o_left = t.offset().left;

                    //miss top
                    if (t.offset().top <= this.outerHeight()) {
                        p.missTop = true;
                        actualBoundary = windowWidth - actualMarginWidth;
                        p.leftRightFlag = true;
                    }

                    //miss right
                    if (o_left + outerWidth > o_left + actualMarginWidth && o_left - actualMarginWidth > outerWidth) {
                        p.missRight = true;
                        p.missLeft = false;
                    }

                    //miss left
                    if (o_left - outerWidth <= 0) {
                        p.missLeft = true;
                        p.missRight = false;
                    }
                }

                return p;
            },

            top: function(t, s) {
                var self = Foundation.libs.dropdown
                  , p = self.dirs._base.call(this, t, s);

                this.addClass('drop-top');

                if (p.missTop == true) {
                    p.top = p.top + t.outerHeight() + this.outerHeight();
                    this.removeClass('drop-top');
                }

                if (p.missRight == true) {
                    p.left = p.left - this.outerWidth() + t.outerWidth();
                }

                if (t.outerWidth() < this.outerWidth() || self.small() || this.hasClass(s.mega_menu)) {
                    self.adjust_pip(this, t, s, p);
                }

                if (Foundation.rtl) {
                    return {
                        left: p.left - this.outerWidth() + t.outerWidth(),
                        top: p.top - this.outerHeight()
                    };
                }

                return {
                    left: p.left,
                    top: p.top - this.outerHeight()
                };
            },

            bottom: function(t, s) {
                var self = Foundation.libs.dropdown
                  , p = self.dirs._base.call(this, t, s);

                if (p.missRight == true) {
                    p.left = p.left - this.outerWidth() + t.outerWidth();
                }

                if (t.outerWidth() < this.outerWidth() || self.small() || this.hasClass(s.mega_menu)) {
                    self.adjust_pip(this, t, s, p);
                }

                if (self.rtl) {
                    return {
                        left: p.left - this.outerWidth() + t.outerWidth(),
                        top: p.top + t.outerHeight()
                    };
                }

                return {
                    left: p.left,
                    top: p.top + t.outerHeight()
                };
            },

            left: function(t, s) {
                var p = Foundation.libs.dropdown.dirs._base.call(this, t, s);

                this.addClass('drop-left');

                if (p.missLeft == true) {
                    p.left = p.left + this.outerWidth();
                    p.top = p.top + t.outerHeight();
                    this.removeClass('drop-left');
                }

                return {
                    left: p.left - this.outerWidth(),
                    top: p.top
                };
            },

            right: function(t, s) {
                var p = Foundation.libs.dropdown.dirs._base.call(this, t, s);

                this.addClass('drop-right');

                if (p.missRight == true) {
                    p.left = p.left - this.outerWidth();
                    p.top = p.top + t.outerHeight();
                    this.removeClass('drop-right');
                } else {
                    p.triggeredRight = true;
                }

                var self = Foundation.libs.dropdown;

                if (t.outerWidth() < this.outerWidth() || self.small() || this.hasClass(s.mega_menu)) {
                    self.adjust_pip(this, t, s, p);
                }

                return {
                    left: p.left + t.outerWidth(),
                    top: p.top
                };
            }
        },

        // Insert rule to style psuedo elements
        adjust_pip: function(dropdown, target, settings, position) {
            var sheet = Foundation.stylesheet
              , pip_offset_base = 8;

            if (dropdown.hasClass(settings.mega_class)) {
                pip_offset_base = position.left + (target.outerWidth() / 2) - 8;
            } else if (this.small()) {
                pip_offset_base += position.left - 8;
            }

            this.rule_idx = sheet.cssRules.length;

            //default
            var sel_before = '.f-dropdown.open:before'
              , sel_after = '.f-dropdown.open:after'
              , css_before = 'left: ' + pip_offset_base + 'px;'
              , css_after = 'left: ' + (pip_offset_base - 1) + 'px;';

            if (position.missRight == true) {
                pip_offset_base = dropdown.outerWidth() - 23;
                sel_before = '.f-dropdown.open:before',
                sel_after = '.f-dropdown.open:after',
                css_before = 'left: ' + pip_offset_base + 'px;',
                css_after = 'left: ' + (pip_offset_base - 1) + 'px;';
            }

            //just a case where right is fired, but its not missing right
            if (position.triggeredRight == true) {
                sel_before = '.f-dropdown.open:before',
                sel_after = '.f-dropdown.open:after',
                css_before = 'left:-12px;',
                css_after = 'left:-14px;';
            }

            if (sheet.insertRule) {
                sheet.insertRule([sel_before, '{', css_before, '}'].join(' '), this.rule_idx);
                sheet.insertRule([sel_after, '{', css_after, '}'].join(' '), this.rule_idx + 1);
            } else {
                sheet.addRule(sel_before, css_before, this.rule_idx);
                sheet.addRule(sel_after, css_after, this.rule_idx + 1);
            }
        },

        // Remove old dropdown rule index
        clear_idx: function() {
            var sheet = Foundation.stylesheet;

            if (typeof this.rule_idx !== 'undefined') {
                sheet.deleteRule(this.rule_idx);
                sheet.deleteRule(this.rule_idx);
                delete this.rule_idx;
            }
        },

        small: function() {
            return matchMedia(Foundation.media_queries.small).matches && !matchMedia(Foundation.media_queries.medium).matches;
        },

        off: function() {
            this.S(this.scope).off('.fndtn.dropdown');
            this.S('html, body').off('.fndtn.dropdown');
            this.S(window).off('.fndtn.dropdown');
            this.S('[data-dropdown-content]').off('.fndtn.dropdown');
        },

        reflow: function() {}
    };
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.equalizer = {
        name: 'equalizer',

        version: '5.5.3',

        settings: {
            use_tallest: true,
            before_height_change: $.noop,
            after_height_change: $.noop,
            equalize_on_stack: false,
            act_on_hidden_el: false
        },

        init: function(scope, method, options) {
            Foundation.inherit(this, 'image_loaded');
            this.bindings(method, options);
            this.reflow();
        },

        events: function() {
            this.S(window).off('.equalizer').on('resize.fndtn.equalizer', function(e) {
                this.reflow();
            }
            .bind(this));
        },

        equalize: function(equalizer) {
            var isStacked = false, group = equalizer.data('equalizer'), settings = equalizer.data(this.attr_name(true) + '-init') || this.settings, vals, firstTopOffset;

            if (settings.act_on_hidden_el) {
                vals = group ? equalizer.find('[' + this.attr_name() + '-watch="' + group + '"]') : equalizer.find('[' + this.attr_name() + '-watch]');
            } else {
                vals = group ? equalizer.find('[' + this.attr_name() + '-watch="' + group + '"]:visible') : equalizer.find('[' + this.attr_name() + '-watch]:visible');
            }

            if (vals.length === 0) {
                return;
            }

            settings.before_height_change();
            equalizer.trigger('before-height-change.fndth.equalizer');
            vals.height('inherit');

            if (settings.equalize_on_stack === false) {
                firstTopOffset = vals.first().offset().top;
                vals.each(function() {
                    if ($(this).offset().top !== firstTopOffset) {
                        isStacked = true;
                        return false;
                    }
                });
                if (isStacked) {
                    return;
                }
            }

            var heights = vals.map(function() {
                return $(this).outerHeight(false)
            }).get();

            if (settings.use_tallest) {
                var max = Math.max.apply(null, heights);
                vals.css('height', max);
            } else {
                var min = Math.min.apply(null, heights);
                vals.css('height', min);
            }

            settings.after_height_change();
            equalizer.trigger('after-height-change.fndtn.equalizer');
        },

        reflow: function() {
            var self = this;

            this.S('[' + this.attr_name() + ']', this.scope).each(function() {
                var $eq_target = $(this)
                  , media_query = $eq_target.data('equalizer-mq')
                  , ignore_media_query = true;

                if (media_query) {
                    media_query = 'is_' + media_query.replace(/-/g, '_');
                    if (Foundation.utils.hasOwnProperty(media_query)) {
                        ignore_media_query = false;
                    }
                }

                self.image_loaded(self.S('img', this), function() {
                    if (ignore_media_query || Foundation.utils[media_query]()) {
                        self.equalize($eq_target)
                    } else {
                        var vals = $eq_target.find('[' + self.attr_name() + '-watch]:visible');
                        vals.css('height', 'auto');
                    }
                });
            });
        }
    };
}
)(jQuery, window, window.document);

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.interchange = {
        name: 'interchange',

        version: '5.5.3',

        cache: {},

        images_loaded: false,
        nodes_loaded: false,

        settings: {
            load_attr: 'interchange',

            named_queries: {
                'default': 'only screen',
                'small': Foundation.media_queries['small'],
                'small-only': Foundation.media_queries['small-only'],
                'medium': Foundation.media_queries['medium'],
                'medium-only': Foundation.media_queries['medium-only'],
                'large': Foundation.media_queries['large'],
                'large-only': Foundation.media_queries['large-only'],
                'xlarge': Foundation.media_queries['xlarge'],
                'xlarge-only': Foundation.media_queries['xlarge-only'],
                'xxlarge': Foundation.media_queries['xxlarge'],
                'landscape': 'only screen and (orientation: landscape)',
                'portrait': 'only screen and (orientation: portrait)',
                'retina': 'only screen and (-webkit-min-device-pixel-ratio: 2),' + 'only screen and (min--moz-device-pixel-ratio: 2),' + 'only screen and (-o-min-device-pixel-ratio: 2/1),' + 'only screen and (min-device-pixel-ratio: 2),' + 'only screen and (min-resolution: 192dpi),' + 'only screen and (min-resolution: 2dppx)'
            },

            directives: {
                replace: function(el, path, trigger) {
                    // The trigger argument, if called within the directive, fires
                    // an event named after the directive on the element, passing
                    // any parameters along to the event that you pass to trigger.
                    //
                    // ex. trigger(), trigger([a, b, c]), or trigger(a, b, c)
                    //
                    // This allows you to bind a callback like so:
                    // $('#interchangeContainer').on('replace', function (e, a, b, c) {
                    //   console.log($(this).html(), a, b, c);
                    // });

                    if (/IMG/.test(el[0].nodeName)) {
                        var orig_path = el[0].src;

                        if (new RegExp(path,'i').test(orig_path))
                            return;

                        el[0].src = path;

                        //return trigger(el[0].src);
                        return;
                    }
                    var last_path = el.data(this.data_attr + '-last-path')
                      ,
                    self = this;

                    if (last_path == path)
                        return;

                    if (/\.(gif|jpg|jpeg|tiff|png)([?#].*)?/i.test(path)) {
                        $(el).css('background-image', 'url(' + path + ')');
                        el.data('interchange-last-path', path);
                        //return trigger(path);
                        return;
                    }

                    return $.get(path, function(response) {
                        el.html(response);
                        el.data(self.data_attr + '-last-path', path);
                        //trigger();
                    });

                }
            }
        },

        init: function(scope, method, options) {
            Foundation.inherit(this, 'throttle random_str');

            this.data_attr = this.set_data_attr();
            $.extend(true, this.settings, method, options);
            this.bindings(method, options);
            this.reflow();
        },

        get_media_hash: function() {
            var mediaHash = '';
            for (var queryName in this.settings.named_queries) {
                mediaHash += matchMedia(this.settings.named_queries[queryName]).matches.toString();
            }
            return mediaHash;
        },

        events: function() {
            var self = this, prevMediaHash;

            $(window).off('.interchange').on('resize.fndtn.interchange', self.throttle(function() {
                var currMediaHash = self.get_media_hash();
                if (currMediaHash !== prevMediaHash) {
                    self.resize();
                }
                prevMediaHash = currMediaHash;
            }, 50));

            return this;
        },

        resize: function() {
            var cache = this.cache;

            if (!this.images_loaded || !this.nodes_loaded) {
                setTimeout($.proxy(this.resize, this), 50);
                return;
            }

            for (var uuid in cache) {
                if (cache.hasOwnProperty(uuid)) {
                    var passed = this.results(uuid, cache[uuid]);
                    if (passed) {
                        this.settings.directives[passed.scenario[1]].call(this, passed.el, passed.scenario[0], (function(passed) {
                            if (arguments[0]instanceof Array) {
                                var args = arguments[0];
                            } else {
                                var args = Array.prototype.slice.call(arguments, 0);
                            }

                            return function() {
                                passed.el.trigger(passed.scenario[1], args);
                            }
                        }(passed)));
                    }
                }
            }

        },

        results: function(uuid, scenarios) {
            var count = scenarios.length;

            if (count > 0) {
                var el = this.S('[' + this.add_namespace('data-uuid') + '="' + uuid + '"]');

                while (count--) {
                    var mq, rule = scenarios[count][2];
                    if (this.settings.named_queries.hasOwnProperty(rule)) {
                        mq = matchMedia(this.settings.named_queries[rule]);
                    } else {
                        mq = matchMedia(rule);
                    }
                    if (mq.matches) {
                        return {
                            el: el,
                            scenario: scenarios[count]
                        };
                    }
                }
            }

            return false;
        },

        load: function(type, force_update) {
            if (typeof this['cached_' + type] === 'undefined' || force_update) {
                this['update_' + type]();
            }

            return this['cached_' + type];
        },

        update_images: function() {
            var images = this.S('img[' + this.data_attr + ']')
              , count = images.length
              , i = count
              , loaded_count = 0
              , data_attr = this.data_attr;

            this.cache = {};
            this.cached_images = [];
            this.images_loaded = (count === 0);

            while (i--) {
                loaded_count++;
                if (images[i]) {
                    var str = images[i].getAttribute(data_attr) || '';

                    if (str.length > 0) {
                        this.cached_images.push(images[i]);
                    }
                }

                if (loaded_count === count) {
                    this.images_loaded = true;
                    this.enhance('images');
                }
            }

            return this;
        },

        update_nodes: function() {
            var nodes = this.S('[' + this.data_attr + ']').not('img')
              , count = nodes.length
              , i = count
              , loaded_count = 0
              , data_attr = this.data_attr;

            this.cached_nodes = [];
            this.nodes_loaded = (count === 0);

            while (i--) {
                loaded_count++;
                var str = nodes[i].getAttribute(data_attr) || '';

                if (str.length > 0) {
                    this.cached_nodes.push(nodes[i]);
                }

                if (loaded_count === count) {
                    this.nodes_loaded = true;
                    this.enhance('nodes');
                }
            }

            return this;
        },

        enhance: function(type) {
            var i = this['cached_' + type].length;

            while (i--) {
                this.object($(this['cached_' + type][i]));
            }

            return $(window).trigger('resize.fndtn.interchange');
        },

        convert_directive: function(directive) {

            var trimmed = this.trim(directive);

            if (trimmed.length > 0) {
                return trimmed;
            }

            return 'replace';
        },

        parse_scenario: function(scenario) {
            // This logic had to be made more complex since some users were using commas in the url path
            // So we cannot simply just split on a comma

            var directive_match = scenario[0].match(/(.+),\s*(\w+)\s*$/)
              , // getting the mq has gotten a bit complicated since we started accounting for several use cases
            // of URLs. For now we'll continue to match these scenarios, but we may consider having these scenarios
            // as nested objects or arrays in F6.
            // regex: match everything before close parenthesis for mq
            media_query = scenario[1].match(/(.*)\)/);

            if (directive_match) {
                var path = directive_match[1]
                  , directive = directive_match[2];

            } else {
                var cached_split = scenario[0].split(/,\s*$/)
                  , path = cached_split[0]
                  , directive = '';
            }

            return [this.trim(path), this.convert_directive(directive), this.trim(media_query[1])];
        },

        object: function(el) {
            var raw_arr = this.parse_data_attr(el)
              , scenarios = []
              , i = raw_arr.length;

            if (i > 0) {
                while (i--) {
                    // split array between comma delimited content and mq
                    // regex: comma, optional space, open parenthesis
                    var scenario = raw_arr[i].split(/,\s?\(/);

                    if (scenario.length > 1) {
                        var params = this.parse_scenario(scenario);
                        scenarios.push(params);
                    }
                }
            }

            return this.store(el, scenarios);
        },

        store: function(el, scenarios) {
            var uuid = this.random_str()
              , current_uuid = el.data(this.add_namespace('uuid', true));

            if (this.cache[current_uuid]) {
                return this.cache[current_uuid];
            }

            el.attr(this.add_namespace('data-uuid'), uuid);
            return this.cache[uuid] = scenarios;
        },

        trim: function(str) {

            if (typeof str === 'string') {
                return $.trim(str);
            }

            return str;
        },

        set_data_attr: function(init) {
            if (init) {
                if (this.namespace.length > 0) {
                    return this.namespace + '-' + this.settings.load_attr;
                }

                return this.settings.load_attr;
            }

            if (this.namespace.length > 0) {
                return 'data-' + this.namespace + '-' + this.settings.load_attr;
            }

            return 'data-' + this.settings.load_attr;
        },

        parse_data_attr: function(el) {
            var raw = el.attr(this.attr_name()).split(/\[(.*?)\]/)
              , i = raw.length
              , output = [];

            while (i--) {
                if (raw[i].replace(/[\W\d]+/, '').length > 4) {
                    output.push(raw[i]);
                }
            }

            return output;
        },

        reflow: function() {
            this.load('images', true);
            this.load('nodes', true);
        }

    };

}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    var Modernizr = Modernizr || false;

    Foundation.libs.joyride = {
        name: 'joyride',

        version: '5.5.3',

        defaults: {
            expose: false,
            // turn on or off the expose feature
            modal: true,
            // Whether to cover page with modal during the tour
            keyboard: true,
            // enable left, right and esc keystrokes
            tip_location: 'bottom',
            // 'top', 'bottom', 'left' or 'right' in relation to parent
            nub_position: 'auto',
            // override on a per tooltip bases
            scroll_speed: 1500,
            // Page scrolling speed in milliseconds, 0 = no scroll animation
            scroll_animation: 'linear',
            // supports 'swing' and 'linear', extend with jQuery UI.
            timer: 0,
            // 0 = no timer , all other numbers = timer in milliseconds
            start_timer_on_click: true,
            // true or false - true requires clicking the first button start the timer
            start_offset: 0,
            // the index of the tooltip you want to start on (index of the li)
            next_button: true,
            // true or false to control whether a next button is used
            prev_button: true,
            // true or false to control whether a prev button is used
            tip_animation: 'fade',
            // 'pop' or 'fade' in each tip
            pause_after: [],
            // array of indexes where to pause the tour after
            exposed: [],
            // array of expose elements
            tip_animation_fade_speed: 300,
            // when tipAnimation = 'fade' this is speed in milliseconds for the transition
            cookie_monster: false,
            // true or false to control whether cookies are used
            cookie_name: 'joyride',
            // Name the cookie you'll use
            cookie_domain: false,
            // Will this cookie be attached to a domain, ie. '.notableapp.com'
            cookie_expires: 365,
            // set when you would like the cookie to expire.
            tip_container: 'body',
            // Where will the tip be attached
            abort_on_close: true,
            // When true, the close event will not fire any callback
            tip_location_patterns: {
                top: ['bottom'],
                bottom: [],
                // bottom should not need to be repositioned
                left: ['right', 'top', 'bottom'],
                right: ['left', 'top', 'bottom']
            },
            post_ride_callback: function() {},
            // A method to call once the tour closes (canceled or complete)
            post_step_callback: function() {},
            // A method to call after each step
            pre_step_callback: function() {},
            // A method to call before each step
            pre_ride_callback: function() {},
            // A method to call before the tour starts (passed index, tip, and cloned exposed element)
            post_expose_callback: function() {},
            // A method to call after an element has been exposed
            template: {
                // HTML segments for tip layout
                link: '<a href="#close" class="joyride-close-tip">&times;</a>',
                timer: '<div class="joyride-timer-indicator-wrap"><span class="joyride-timer-indicator"></span></div>',
                tip: '<div class="joyride-tip-guide"><span class="joyride-nub"></span></div>',
                wrapper: '<div class="joyride-content-wrapper"></div>',
                button: '<a href="#" class="small button joyride-next-tip"></a>',
                prev_button: '<a href="#" class="small button joyride-prev-tip"></a>',
                modal: '<div class="joyride-modal-bg"></div>',
                expose: '<div class="joyride-expose-wrapper"></div>',
                expose_cover: '<div class="joyride-expose-cover"></div>'
            },
            expose_add_class: ''// One or more space-separated class names to be added to exposed element
        },

        init: function(scope, method, options) {
            Foundation.inherit(this, 'throttle random_str');

            this.settings = this.settings || $.extend({}, this.defaults, (options || method));

            this.bindings(method, options)
        },

        go_next: function() {
            if (this.settings.$li.next().length < 1) {
                this.end();
            } else if (this.settings.timer > 0) {
                clearTimeout(this.settings.automate);
                this.hide();
                this.show();
                this.startTimer();
            } else {
                this.hide();
                this.show();
            }
        },

        go_prev: function() {
            if (this.settings.$li.prev().length < 1) {// Do nothing if there are no prev element
            } else if (this.settings.timer > 0) {
                clearTimeout(this.settings.automate);
                this.hide();
                this.show(null, true);
                this.startTimer();
            } else {
                this.hide();
                this.show(null, true);
            }
        },

        events: function() {
            var self = this;

            $(this.scope).off('.joyride').on('click.fndtn.joyride', '.joyride-next-tip, .joyride-modal-bg', function(e) {
                e.preventDefault();
                this.go_next()
            }
            .bind(this)).on('click.fndtn.joyride', '.joyride-prev-tip', function(e) {
                e.preventDefault();
                this.go_prev();
            }
            .bind(this))
            .on('click.fndtn.joyride', '.joyride-close-tip', function(e) {
                e.preventDefault();
                this.end(this.settings.abort_on_close);
            }
            .bind(this))
            .on('keyup.fndtn.joyride', function(e) {
                // Don't do anything if keystrokes are disabled
                // or if the joyride is not being shown
                if (!this.settings.keyboard || !this.settings.riding) {
                    return;
                }

                switch (e.which) {
                case 39:
                    // right arrow
                    e.preventDefault();
                    this.go_next();
                    break;
                case 37:
                    // left arrow
                    e.preventDefault();
                    this.go_prev();
                    break;
                case 27:
                    // escape
                    e.preventDefault();
                    this.end(this.settings.abort_on_close);
                }
            }
            .bind(this));

            $(window).off('.joyride').on('resize.fndtn.joyride', self.throttle(function() {
                if ($('[' + self.attr_name() + ']').length > 0 && self.settings.$next_tip && self.settings.riding) {
                    if (self.settings.exposed.length > 0) {
                        var $els = $(self.settings.exposed);

                        $els.each(function() {
                            var $this = $(this);
                            self.un_expose($this);
                            self.expose($this);
                        });
                    }

                    if (self.is_phone()) {
                        self.pos_phone();
                    } else {
                        self.pos_default(false);
                    }
                }
            }, 100));
        },

        start: function() {
            var self = this
              , $this = $('[' + this.attr_name() + ']', this.scope)
              , integer_settings = ['timer', 'scrollSpeed', 'startOffset', 'tipAnimationFadeSpeed', 'cookieExpires']
              , int_settings_count = integer_settings.length;

            if (!$this.length > 0) {
                return;
            }

            if (!this.settings.init) {
                this.events();
            }

            this.settings = $this.data(this.attr_name(true) + '-init');

            // non configureable settings
            this.settings.$content_el = $this;
            this.settings.$body = $(this.settings.tip_container);
            this.settings.body_offset = $(this.settings.tip_container).position();
            this.settings.$tip_content = this.settings.$content_el.find('> li');
            this.settings.paused = false;
            this.settings.attempts = 0;
            this.settings.riding = true;

            // can we create cookies?
            if (typeof $.cookie !== 'function') {
                this.settings.cookie_monster = false;
            }

            // generate the tips and insert into dom.
            if (!this.settings.cookie_monster || this.settings.cookie_monster && !$.cookie(this.settings.cookie_name)) {
                this.settings.$tip_content.each(function(index) {
                    var $this = $(this);
                    this.settings = $.extend({}, self.defaults, self.data_options($this));

                    // Make sure that settings parsed from data_options are integers where necessary
                    var i = int_settings_count;
                    while (i--) {
                        self.settings[integer_settings[i]] = parseInt(self.settings[integer_settings[i]], 10);
                    }
                    self.create({
                        $li: $this,
                        index: index
                    });
                });

                // show first tip
                if (!this.settings.start_timer_on_click && this.settings.timer > 0) {
                    this.show('init');
                    this.startTimer();
                } else {
                    this.show('init');
                }

            }
        },

        resume: function() {
            this.set_li();
            this.show();
        },

        tip_template: function(opts) {
            var $blank, content;

            opts.tip_class = opts.tip_class || '';

            $blank = $(this.settings.template.tip).addClass(opts.tip_class);
            content = $.trim($(opts.li).html()) + this.prev_button_text(opts.prev_button_text, opts.index) + this.button_text(opts.button_text) + this.settings.template.link + this.timer_instance(opts.index);

            $blank.append($(this.settings.template.wrapper));
            $blank.first().attr(this.add_namespace('data-index'), opts.index);
            $('.joyride-content-wrapper', $blank).append(content);

            return $blank[0];
        },

        timer_instance: function(index) {
            var txt;

            if ((index === 0 && this.settings.start_timer_on_click && this.settings.timer > 0) || this.settings.timer === 0) {
                txt = '';
            } else {
                txt = $(this.settings.template.timer)[0].outerHTML;
            }
            return txt;
        },

        button_text: function(txt) {
            if (this.settings.tip_settings.next_button) {
                txt = $.trim(txt) || 'Next';
                txt = $(this.settings.template.button).append(txt)[0].outerHTML;
            } else {
                txt = '';
            }
            return txt;
        },

        prev_button_text: function(txt, idx) {
            if (this.settings.tip_settings.prev_button) {
                txt = $.trim(txt) || 'Previous';

                // Add the disabled class to the button if it's the first element
                if (idx == 0) {
                    txt = $(this.settings.template.prev_button).append(txt).addClass('disabled')[0].outerHTML;
                } else {
                    txt = $(this.settings.template.prev_button).append(txt)[0].outerHTML;
                }
            } else {
                txt = '';
            }
            return txt;
        },

        create: function(opts) {
            this.settings.tip_settings = $.extend({}, this.settings, this.data_options(opts.$li));
            var buttonText = opts.$li.attr(this.add_namespace('data-button')) || opts.$li.attr(this.add_namespace('data-text'))
              , prevButtonText = opts.$li.attr(this.add_namespace('data-button-prev')) || opts.$li.attr(this.add_namespace('data-prev-text'))
              , tipClass = opts.$li.attr('class')
              , $tip_content = $(this.tip_template({
                tip_class: tipClass,
                index: opts.index,
                button_text: buttonText,
                prev_button_text: prevButtonText,
                li: opts.$li
            }));

            $(this.settings.tip_container).append($tip_content);
        },

        show: function(init, is_prev) {
            var $timer = null;

            // are we paused?
            if (this.settings.$li === undefined || ($.inArray(this.settings.$li.index(), this.settings.pause_after) === -1)) {

                // don't go to the next li if the tour was paused
                if (this.settings.paused) {
                    this.settings.paused = false;
                } else {
                    this.set_li(init, is_prev);
                }

                this.settings.attempts = 0;

                if (this.settings.$li.length && this.settings.$target.length > 0) {
                    if (init) {
                        //run when we first start
                        this.settings.pre_ride_callback(this.settings.$li.index(), this.settings.$next_tip);
                        if (this.settings.modal) {
                            this.show_modal();
                        }
                    }

                    this.settings.pre_step_callback(this.settings.$li.index(), this.settings.$next_tip);

                    if (this.settings.modal && this.settings.expose) {
                        this.expose();
                    }

                    this.settings.tip_settings = $.extend({}, this.settings, this.data_options(this.settings.$li));

                    this.settings.timer = parseInt(this.settings.timer, 10);

                    this.settings.tip_settings.tip_location_pattern = this.settings.tip_location_patterns[this.settings.tip_settings.tip_location];

                    // scroll and hide bg if not modal and not expose
                    if (!/body/i.test(this.settings.$target.selector) && !this.settings.expose) {
                        var joyridemodalbg = $('.joyride-modal-bg');
                        if (/pop/i.test(this.settings.tipAnimation)) {
                            joyridemodalbg.hide();
                        } else {
                            joyridemodalbg.fadeOut(this.settings.tipAnimationFadeSpeed);
                        }
                        this.scroll_to();
                    }

                    if (this.is_phone()) {
                        this.pos_phone(true);
                    } else {
                        this.pos_default(true);
                    }

                    $timer = this.settings.$next_tip.find('.joyride-timer-indicator');

                    if (/pop/i.test(this.settings.tip_animation)) {

                        $timer.width(0);

                        if (this.settings.timer > 0) {

                            this.settings.$next_tip.show();

                            setTimeout(function() {
                                $timer.animate({
                                    width: $timer.parent().width()
                                }, this.settings.timer, 'linear');
                            }
                            .bind(this), this.settings.tip_animation_fade_speed);

                        } else {
                            this.settings.$next_tip.show();

                        }

                    } else if (/fade/i.test(this.settings.tip_animation)) {

                        $timer.width(0);

                        if (this.settings.timer > 0) {

                            this.settings.$next_tip.fadeIn(this.settings.tip_animation_fade_speed).show();

                            setTimeout(function() {
                                $timer.animate({
                                    width: $timer.parent().width()
                                }, this.settings.timer, 'linear');
                            }
                            .bind(this), this.settings.tip_animation_fade_speed);

                        } else {
                            this.settings.$next_tip.fadeIn(this.settings.tip_animation_fade_speed);
                        }
                    }

                    this.settings.$current_tip = this.settings.$next_tip;

                    // skip non-existant targets
                } else if (this.settings.$li && this.settings.$target.length < 1) {

                    this.show(init, is_prev);

                } else {

                    this.end();

                }
            } else {

                this.settings.paused = true;

            }

        },

        is_phone: function() {
            return matchMedia(Foundation.media_queries.small).matches && !matchMedia(Foundation.media_queries.medium).matches;
        },

        hide: function() {
            if (this.settings.modal && this.settings.expose) {
                this.un_expose();
            }

            if (!this.settings.modal) {
                $('.joyride-modal-bg').hide();
            }

            // Prevent scroll bouncing...wait to remove from layout
            this.settings.$current_tip.css('visibility', 'hidden');
            setTimeout($.proxy(function() {
                this.hide();
                this.css('visibility', 'visible');
            }, this.settings.$current_tip), 0);
            this.settings.post_step_callback(this.settings.$li.index(), this.settings.$current_tip);
        },

        set_li: function(init, is_prev) {
            if (init) {
                this.settings.$li = this.settings.$tip_content.eq(this.settings.start_offset);
                this.set_next_tip();
                this.settings.$current_tip = this.settings.$next_tip;
            } else {
                if (is_prev) {
                    this.settings.$li = this.settings.$li.prev();
                } else {
                    this.settings.$li = this.settings.$li.next();
                }
                this.set_next_tip();
            }

            this.set_target();
        },

        set_next_tip: function() {
            this.settings.$next_tip = $('.joyride-tip-guide').eq(this.settings.$li.index());
            this.settings.$next_tip.data('closed', '');
        },

        set_target: function() {
            var cl = this.settings.$li.attr(this.add_namespace('data-class'))
              , id = this.settings.$li.attr(this.add_namespace('data-id'))
              , $sel = function() {
                if (id) {
                    return $(document.getElementById(id));
                } else if (cl) {
                    return $('.' + cl).first();
                } else {
                    return $('body');
                }
            };

            this.settings.$target = $sel();
        },

        scroll_to: function() {
            var window_half, tipOffset;

            window_half = $(window).height() / 2;
            tipOffset = Math.ceil(this.settings.$target.offset().top - window_half + this.settings.$next_tip.outerHeight());

            if (tipOffset != 0) {
                $('html, body').stop().animate({
                    scrollTop: tipOffset
                }, this.settings.scroll_speed, 'swing');
            }
        },

        paused: function() {
            return ($.inArray((this.settings.$li.index() + 1), this.settings.pause_after) === -1);
        },

        restart: function() {
            this.hide();
            this.settings.$li = undefined;
            this.show('init');
        },

        pos_default: function(init) {
            var $nub = this.settings.$next_tip.find('.joyride-nub')
              , nub_width = Math.ceil($nub.outerWidth() / 2)
              , nub_height = Math.ceil($nub.outerHeight() / 2)
              , toggle = init || false;

            // tip must not be "display: none" to calculate position
            if (toggle) {
                this.settings.$next_tip.css('visibility', 'hidden');
                this.settings.$next_tip.show();
            }

            if (!/body/i.test(this.settings.$target.selector)) {
                var topAdjustment = this.settings.tip_settings.tipAdjustmentY ? parseInt(this.settings.tip_settings.tipAdjustmentY) : 0
                  , leftAdjustment = this.settings.tip_settings.tipAdjustmentX ? parseInt(this.settings.tip_settings.tipAdjustmentX) : 0;

                if (this.bottom()) {
                    if (this.rtl) {
                        this.settings.$next_tip.css({
                            top: (this.settings.$target.offset().top + nub_height + this.settings.$target.outerHeight() + topAdjustment),
                            left: this.settings.$target.offset().left + this.settings.$target.outerWidth() - this.settings.$next_tip.outerWidth() + leftAdjustment
                        });
                    } else {
                        this.settings.$next_tip.css({
                            top: (this.settings.$target.offset().top + nub_height + this.settings.$target.outerHeight() + topAdjustment),
                            left: this.settings.$target.offset().left + leftAdjustment
                        });
                    }

                    this.nub_position($nub, this.settings.tip_settings.nub_position, 'top');

                } else if (this.top()) {
                    if (this.rtl) {
                        this.settings.$next_tip.css({
                            top: (this.settings.$target.offset().top - this.settings.$next_tip.outerHeight() - nub_height + topAdjustment),
                            left: this.settings.$target.offset().left + this.settings.$target.outerWidth() - this.settings.$next_tip.outerWidth()
                        });
                    } else {
                        this.settings.$next_tip.css({
                            top: (this.settings.$target.offset().top - this.settings.$next_tip.outerHeight() - nub_height + topAdjustment),
                            left: this.settings.$target.offset().left + leftAdjustment
                        });
                    }

                    this.nub_position($nub, this.settings.tip_settings.nub_position, 'bottom');

                } else if (this.right()) {

                    this.settings.$next_tip.css({
                        top: this.settings.$target.offset().top + topAdjustment,
                        left: (this.settings.$target.outerWidth() + this.settings.$target.offset().left + nub_width + leftAdjustment)
                    });

                    this.nub_position($nub, this.settings.tip_settings.nub_position, 'left');

                } else if (this.left()) {

                    this.settings.$next_tip.css({
                        top: this.settings.$target.offset().top + topAdjustment,
                        left: (this.settings.$target.offset().left - this.settings.$next_tip.outerWidth() - nub_width + leftAdjustment)
                    });

                    this.nub_position($nub, this.settings.tip_settings.nub_position, 'right');

                }

                if (!this.visible(this.corners(this.settings.$next_tip)) && this.settings.attempts < this.settings.tip_settings.tip_location_pattern.length) {

                    $nub.removeClass('bottom').removeClass('top').removeClass('right').removeClass('left');

                    this.settings.tip_settings.tip_location = this.settings.tip_settings.tip_location_pattern[this.settings.attempts];

                    this.settings.attempts++;

                    this.pos_default();

                }

            } else if (this.settings.$li.length) {

                this.pos_modal($nub);

            }

            if (toggle) {
                this.settings.$next_tip.hide();
                this.settings.$next_tip.css('visibility', 'visible');
            }

        },

        pos_phone: function(init) {
            var tip_height = this.settings.$next_tip.outerHeight()
              , tip_offset = this.settings.$next_tip.offset()
              , target_height = this.settings.$target.outerHeight()
              , $nub = $('.joyride-nub', this.settings.$next_tip)
              , nub_height = Math.ceil($nub.outerHeight() / 2)
              , toggle = init || false;

            $nub.removeClass('bottom').removeClass('top').removeClass('right').removeClass('left');

            if (toggle) {
                this.settings.$next_tip.css('visibility', 'hidden');
                this.settings.$next_tip.show();
            }

            if (!/body/i.test(this.settings.$target.selector)) {

                if (this.top()) {

                    this.settings.$next_tip.offset({
                        top: this.settings.$target.offset().top - tip_height - nub_height
                    });
                    $nub.addClass('bottom');

                } else {

                    this.settings.$next_tip.offset({
                        top: this.settings.$target.offset().top + target_height + nub_height
                    });
                    $nub.addClass('top');

                }

            } else if (this.settings.$li.length) {
                this.pos_modal($nub);
            }

            if (toggle) {
                this.settings.$next_tip.hide();
                this.settings.$next_tip.css('visibility', 'visible');
            }
        },

        pos_modal: function($nub) {
            this.center();
            $nub.hide();

            this.show_modal();
        },

        show_modal: function() {
            if (!this.settings.$next_tip.data('closed')) {
                var joyridemodalbg = $('.joyride-modal-bg');
                if (joyridemodalbg.length < 1) {
                    var joyridemodalbg = $(this.settings.template.modal);
                    joyridemodalbg.appendTo('body');
                }

                if (/pop/i.test(this.settings.tip_animation)) {
                    joyridemodalbg.show();
                } else {
                    joyridemodalbg.fadeIn(this.settings.tip_animation_fade_speed);
                }
            }
        },

        expose: function() {
            var expose, exposeCover, el, origCSS, origClasses, randId = 'expose-' + this.random_str(6);

            if (arguments.length > 0 && arguments[0]instanceof $) {
                el = arguments[0];
            } else if (this.settings.$target && !/body/i.test(this.settings.$target.selector)) {
                el = this.settings.$target;
            } else {
                return false;
            }

            if (el.length < 1) {
                if (window.console) {
                    console.error('element not valid', el);
                }
                return false;
            }

            expose = $(this.settings.template.expose);
            this.settings.$body.append(expose);
            expose.css({
                top: el.offset().top,
                left: el.offset().left,
                width: el.outerWidth(true),
                height: el.outerHeight(true)
            });

            exposeCover = $(this.settings.template.expose_cover);

            origCSS = {
                zIndex: el.css('z-index'),
                position: el.css('position')
            };

            origClasses = el.attr('class') == null ? '' : el.attr('class');

            el.css('z-index', parseInt(expose.css('z-index')) + 1);

            if (origCSS.position == 'static') {
                el.css('position', 'relative');
            }

            el.data('expose-css', origCSS);
            el.data('orig-class', origClasses);
            el.attr('class', origClasses + ' ' + this.settings.expose_add_class);

            exposeCover.css({
                top: el.offset().top,
                left: el.offset().left,
                width: el.outerWidth(true),
                height: el.outerHeight(true)
            });

            if (this.settings.modal) {
                this.show_modal();
            }

            this.settings.$body.append(exposeCover);
            expose.addClass(randId);
            exposeCover.addClass(randId);
            el.data('expose', randId);
            this.settings.post_expose_callback(this.settings.$li.index(), this.settings.$next_tip, el);
            this.add_exposed(el);
        },

        un_expose: function() {
            var exposeId, el, expose, origCSS, origClasses, clearAll = false;

            if (arguments.length > 0 && arguments[0]instanceof $) {
                el = arguments[0];
            } else if (this.settings.$target && !/body/i.test(this.settings.$target.selector)) {
                el = this.settings.$target;
            } else {
                return false;
            }

            if (el.length < 1) {
                if (window.console) {
                    console.error('element not valid', el);
                }
                return false;
            }

            exposeId = el.data('expose');
            expose = $('.' + exposeId);

            if (arguments.length > 1) {
                clearAll = arguments[1];
            }

            if (clearAll === true) {
                $('.joyride-expose-wrapper,.joyride-expose-cover').remove();
            } else {
                expose.remove();
            }

            origCSS = el.data('expose-css');

            if (origCSS.zIndex == 'auto') {
                el.css('z-index', '');
            } else {
                el.css('z-index', origCSS.zIndex);
            }

            if (origCSS.position != el.css('position')) {
                if (origCSS.position == 'static') {
                    // this is default, no need to set it.
                    el.css('position', '');
                } else {
                    el.css('position', origCSS.position);
                }
            }

            origClasses = el.data('orig-class');
            el.attr('class', origClasses);
            el.removeData('orig-classes');

            el.removeData('expose');
            el.removeData('expose-z-index');
            this.remove_exposed(el);
        },

        add_exposed: function(el) {
            this.settings.exposed = this.settings.exposed || [];
            if (el instanceof $ || typeof el === 'object') {
                this.settings.exposed.push(el[0]);
            } else if (typeof el == 'string') {
                this.settings.exposed.push(el);
            }
        },

        remove_exposed: function(el) {
            var search, i;
            if (el instanceof $) {
                search = el[0]
            } else if (typeof el == 'string') {
                search = el;
            }

            this.settings.exposed = this.settings.exposed || [];
            i = this.settings.exposed.length;

            while (i--) {
                if (this.settings.exposed[i] == search) {
                    this.settings.exposed.splice(i, 1);
                    return;
                }
            }
        },

        center: function() {
            var $w = $(window);

            this.settings.$next_tip.css({
                top: ((($w.height() - this.settings.$next_tip.outerHeight()) / 2) + $w.scrollTop()),
                left: ((($w.width() - this.settings.$next_tip.outerWidth()) / 2) + $w.scrollLeft())
            });

            return true;
        },

        bottom: function() {
            return /bottom/i.test(this.settings.tip_settings.tip_location);
        },

        top: function() {
            return /top/i.test(this.settings.tip_settings.tip_location);
        },

        right: function() {
            return /right/i.test(this.settings.tip_settings.tip_location);
        },

        left: function() {
            return /left/i.test(this.settings.tip_settings.tip_location);
        },

        corners: function(el) {
            if (el.length === 0) {
                return [false, false, false, false];
            }

            var w = $(window)
              , window_half = w.height() / 2
              , //using this to calculate since scroll may not have finished yet.
            tipOffset = Math.ceil(this.settings.$target.offset().top - window_half + this.settings.$next_tip.outerHeight())
              , right = w.width() + w.scrollLeft()
              , offsetBottom = w.height() + tipOffset
              , bottom = w.height() + w.scrollTop()
              , top = w.scrollTop();

            if (tipOffset < top) {
                if (tipOffset < 0) {
                    top = 0;
                } else {
                    top = tipOffset;
                }
            }

            if (offsetBottom > bottom) {
                bottom = offsetBottom;
            }

            return [el.offset().top < top, right < el.offset().left + el.outerWidth(), bottom < el.offset().top + el.outerHeight(), w.scrollLeft() > el.offset().left];
        },

        visible: function(hidden_corners) {
            var i = hidden_corners.length;

            while (i--) {
                if (hidden_corners[i]) {
                    return false;
                }
            }

            return true;
        },

        nub_position: function(nub, pos, def) {
            if (pos === 'auto') {
                nub.addClass(def);
            } else {
                nub.addClass(pos);
            }
        },

        startTimer: function() {
            if (this.settings.$li.length) {
                this.settings.automate = setTimeout(function() {
                    this.hide();
                    this.show();
                    this.startTimer();
                }
                .bind(this), this.settings.timer);
            } else {
                clearTimeout(this.settings.automate);
            }
        },

        end: function(abort) {
            if (this.settings.cookie_monster) {
                $.cookie(this.settings.cookie_name, 'ridden', {
                    expires: this.settings.cookie_expires,
                    domain: this.settings.cookie_domain
                });
            }

            if (this.settings.timer > 0) {
                clearTimeout(this.settings.automate);
            }

            if (this.settings.modal && this.settings.expose) {
                this.un_expose();
            }

            // Unplug keystrokes listener
            $(this.scope).off('keyup.joyride')

            this.settings.$next_tip.data('closed', true);
            this.settings.riding = false;

            $('.joyride-modal-bg').hide();
            this.settings.$current_tip.hide();

            if (typeof abort === 'undefined' || abort === false) {
                this.settings.post_step_callback(this.settings.$li.index(), this.settings.$current_tip);
                this.settings.post_ride_callback(this.settings.$li.index(), this.settings.$current_tip);
            }

            $('.joyride-tip-guide').remove();
        },

        off: function() {
            $(this.scope).off('.joyride');
            $(window).off('.joyride');
            $('.joyride-close-tip, .joyride-next-tip, .joyride-modal-bg').off('.joyride');
            $('.joyride-tip-guide, .joyride-modal-bg').remove();
            clearTimeout(this.settings.automate);
        },

        reflow: function() {}
    };
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs['magellan-expedition'] = {
        name: 'magellan-expedition',

        version: '5.5.3',

        settings: {
            active_class: 'active',
            threshold: 0,
            // pixels from the top of the expedition for it to become fixes
            destination_threshold: 20,
            // pixels from the top of destination for it to be considered active
            throttle_delay: 30,
            // calculation throttling to increase framerate
            fixed_top: 0,
            // top distance in pixels assigend to the fixed element on scroll
            offset_by_height: true,
            // whether to offset the destination by the expedition height. Usually you want this to be true, unless your expedition is on the side.
            duration: 700,
            // animation duration time
            easing: 'swing'// animation easing
        },

        init: function(scope, method, options) {
            Foundation.inherit(this, 'throttle');
            this.bindings(method, options);
        },

        events: function() {
            var self = this
              , S = self.S
              , settings = self.settings;

            // initialize expedition offset
            self.set_expedition_position();

            S(self.scope).off('.magellan').on('click.fndtn.magellan', '[' + self.add_namespace('data-magellan-arrival') + '] a[href*=#]', function(e) {
                var sameHost = ((this.hostname === location.hostname) || !this.hostname)
                  , samePath = self.filterPathname(location.pathname) === self.filterPathname(this.pathname)
                  , testHash = this.hash.replace(/(:|\.|\/)/g, '\\$1')
                  , anchor = this;

                if (sameHost && samePath && testHash) {
                    e.preventDefault();
                    var expedition = $(this).closest('[' + self.attr_name() + ']')
                      , settings = expedition.data('magellan-expedition-init')
                      , hash = this.hash.split('#').join('')
                      , target = $('a[name="' + hash + '"]');

                    if (target.length === 0) {
                        target = $('#' + hash);

                    }

                    // Account for expedition height if fixed position
                    var scroll_top = target.offset().top - settings.destination_threshold + 1;
                    if (settings.offset_by_height) {
                        scroll_top = scroll_top - expedition.outerHeight();
                    }
                    $('html, body').stop().animate({
                        'scrollTop': scroll_top
                    }, settings.duration, settings.easing, function() {
                        if (history.pushState) {
                            history.pushState(null, null, anchor.pathname + anchor.search + '#' + hash);
                        } else {
                            location.hash = anchor.pathname + anchor.search + '#' + hash;
                        }
                    });
                }
            }).on('scroll.fndtn.magellan', self.throttle(this.check_for_arrivals.bind(this), settings.throttle_delay));
        },

        check_for_arrivals: function() {
            var self = this;
            self.update_arrivals();
            self.update_expedition_positions();
        },

        set_expedition_position: function() {
            var self = this;
            $('[' + this.attr_name() + '=fixed]', self.scope).each(function(idx, el) {
                var expedition = $(this), settings = expedition.data('magellan-expedition-init'), styles = expedition.attr('styles'), // save styles
                top_offset, fixed_top;

                expedition.attr('style', '');
                top_offset = expedition.offset().top + settings.threshold;

                //set fixed-top by attribute
                fixed_top = parseInt(expedition.data('magellan-fixed-top'));
                if (!isNaN(fixed_top)) {
                    self.settings.fixed_top = fixed_top;
                }

                expedition.data(self.data_attr('magellan-top-offset'), top_offset);
                expedition.attr('style', styles);
            });
        },

        update_expedition_positions: function() {
            var self = this
              , window_top_offset = $(window).scrollTop();

            $('[' + this.attr_name() + '=fixed]', self.scope).each(function() {
                var expedition = $(this)
                  , settings = expedition.data('magellan-expedition-init')
                  , styles = expedition.attr('style')
                  , // save styles
                top_offset = expedition.data('magellan-top-offset');

                //scroll to the top distance
                if (window_top_offset + self.settings.fixed_top >= top_offset) {
                    // Placeholder allows height calculations to be consistent even when
                    // appearing to switch between fixed/non-fixed placement
                    var placeholder = expedition.prev('[' + self.add_namespace('data-magellan-expedition-clone') + ']');
                    if (placeholder.length === 0) {
                        placeholder = expedition.clone();
                        placeholder.removeAttr(self.attr_name());
                        placeholder.attr(self.add_namespace('data-magellan-expedition-clone'), '');
                        expedition.before(placeholder);
                    }
                    expedition.css({
                        position: 'fixed',
                        top: settings.fixed_top
                    }).addClass('fixed');
                } else {
                    expedition.prev('[' + self.add_namespace('data-magellan-expedition-clone') + ']').remove();
                    expedition.attr('style', styles).css('position', '').css('top', '').removeClass('fixed');
                }
            });
        },

        update_arrivals: function() {
            var self = this
              , window_top_offset = $(window).scrollTop();

            $('[' + this.attr_name() + ']', self.scope).each(function() {
                var expedition = $(this)
                  , settings = expedition.data(self.attr_name(true) + '-init')
                  , offsets = self.offsets(expedition, window_top_offset)
                  , arrivals = expedition.find('[' + self.add_namespace('data-magellan-arrival') + ']')
                  , active_item = false;
                offsets.each(function(idx, item) {
                    if (item.viewport_offset >= item.top_offset) {
                        var arrivals = expedition.find('[' + self.add_namespace('data-magellan-arrival') + ']');
                        arrivals.not(item.arrival).removeClass(settings.active_class);
                        item.arrival.addClass(settings.active_class);
                        active_item = true;
                        return true;
                    }
                });

                if (!active_item) {
                    arrivals.removeClass(settings.active_class);
                }
            });
        },

        offsets: function(expedition, window_offset) {
            var self = this
              , settings = expedition.data(self.attr_name(true) + '-init')
              , viewport_offset = window_offset;

            return expedition.find('[' + self.add_namespace('data-magellan-arrival') + ']').map(function(idx, el) {
                var name = $(this).data(self.data_attr('magellan-arrival'))
                  , dest = $('[' + self.add_namespace('data-magellan-destination') + '=' + name + ']');
                if (dest.length > 0) {
                    var top_offset = dest.offset().top - settings.destination_threshold;
                    if (settings.offset_by_height) {
                        top_offset = top_offset - expedition.outerHeight();
                    }
                    top_offset = Math.floor(top_offset);
                    return {
                        destination: dest,
                        arrival: $(this),
                        top_offset: top_offset,
                        viewport_offset: viewport_offset
                    }
                }
            }).sort(function(a, b) {
                if (a.top_offset < b.top_offset) {
                    return -1;
                }
                if (a.top_offset > b.top_offset) {
                    return 1;
                }
                return 0;
            });
        },

        data_attr: function(str) {
            if (this.namespace.length > 0) {
                return this.namespace + '-' + str;
            }

            return str;
        },

        off: function() {
            this.S(this.scope).off('.magellan');
            this.S(window).off('.magellan');
        },

        filterPathname: function(pathname) {
            pathname = pathname || '';
            return pathname.replace(/^\//, '').replace(/(?:index|default).[a-zA-Z]{3,4}$/, '').replace(/\/$/, '');
        },

        reflow: function() {
            var self = this;
            // remove placeholder expeditions used for height calculation purposes
            $('[' + self.add_namespace('data-magellan-expedition-clone') + ']', self.scope).remove();
        }
    };
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.offcanvas = {
        name: 'offcanvas',

        version: '5.5.3',

        settings: {
            open_method: 'move',
            close_on_click: false
        },

        init: function(scope, method, options) {
            this.bindings(method, options);
        },

        events: function() {
            var self = this
              , S = self.S
              , move_class = ''
              , right_postfix = ''
              , left_postfix = ''
              , top_postfix = ''
              , bottom_postfix = '';

            if (this.settings.open_method === 'move') {
                move_class = 'move-';
                right_postfix = 'right';
                left_postfix = 'left';
                top_postfix = 'top';
                bottom_postfix = 'bottom';
            } else if (this.settings.open_method === 'overlap_single') {
                move_class = 'offcanvas-overlap-';
                right_postfix = 'right';
                left_postfix = 'left';
                top_postfix = 'top';
                bottom_postfix = 'bottom';
            } else if (this.settings.open_method === 'overlap') {
                move_class = 'offcanvas-overlap';
            }

            S(this.scope).off('.offcanvas').on('click.fndtn.offcanvas', '.left-off-canvas-toggle', function(e) {
                self.click_toggle_class(e, move_class + right_postfix);
                if (self.settings.open_method !== 'overlap') {
                    S('.left-submenu').removeClass(move_class + right_postfix);
                }
                $('.left-off-canvas-toggle').attr('aria-expanded', 'true');
            }).on('click.fndtn.offcanvas', '.left-off-canvas-menu a', function(e) {
                var settings = self.get_settings(e);
                var parent = S(this).parent();

                if (settings.close_on_click && !parent.hasClass('has-submenu') && !parent.hasClass('back')) {
                    self.hide.call(self, move_class + right_postfix, self.get_wrapper(e));
                    parent.parent().removeClass(move_class + right_postfix);
                } else if (S(this).parent().hasClass('has-submenu')) {
                    e.preventDefault();
                    S(this).siblings('.left-submenu').toggleClass(move_class + right_postfix);
                } else if (parent.hasClass('back')) {
                    e.preventDefault();
                    parent.parent().removeClass(move_class + right_postfix);
                }
                $('.left-off-canvas-toggle').attr('aria-expanded', 'true');
            })//end of left canvas
            .on('click.fndtn.offcanvas', '.right-off-canvas-toggle', function(e) {
                self.click_toggle_class(e, move_class + left_postfix);
                if (self.settings.open_method !== 'overlap') {
                    S('.right-submenu').removeClass(move_class + left_postfix);
                }
                $('.right-off-canvas-toggle').attr('aria-expanded', 'true');
            }).on('click.fndtn.offcanvas', '.right-off-canvas-menu a', function(e) {
                var settings = self.get_settings(e);
                var parent = S(this).parent();

                if (settings.close_on_click && !parent.hasClass('has-submenu') && !parent.hasClass('back')) {
                    self.hide.call(self, move_class + left_postfix, self.get_wrapper(e));
                    parent.parent().removeClass(move_class + left_postfix);
                } else if (S(this).parent().hasClass('has-submenu')) {
                    e.preventDefault();
                    S(this).siblings('.right-submenu').toggleClass(move_class + left_postfix);
                } else if (parent.hasClass('back')) {
                    e.preventDefault();
                    parent.parent().removeClass(move_class + left_postfix);
                }
                $('.right-off-canvas-toggle').attr('aria-expanded', 'true');
            })//end of right canvas
            .on('click.fndtn.offcanvas', '.top-off-canvas-toggle', function(e) {
                self.click_toggle_class(e, move_class + bottom_postfix);
                if (self.settings.open_method !== 'overlap') {
                    S('.top-submenu').removeClass(move_class + bottom_postfix);
                }
                $('.top-off-canvas-toggle').attr('aria-expanded', 'true');
            }).on('click.fndtn.offcanvas', '.top-off-canvas-menu a', function(e) {
                var settings = self.get_settings(e);
                var parent = S(this).parent();

                if (settings.close_on_click && !parent.hasClass('has-submenu') && !parent.hasClass('back')) {
                    self.hide.call(self, move_class + bottom_postfix, self.get_wrapper(e));
                    parent.parent().removeClass(move_class + bottom_postfix);
                } else if (S(this).parent().hasClass('has-submenu')) {
                    e.preventDefault();
                    S(this).siblings('.top-submenu').toggleClass(move_class + bottom_postfix);
                } else if (parent.hasClass('back')) {
                    e.preventDefault();
                    parent.parent().removeClass(move_class + bottom_postfix);
                }
                $('.top-off-canvas-toggle').attr('aria-expanded', 'true');
            })//end of top canvas
            .on('click.fndtn.offcanvas', '.bottom-off-canvas-toggle', function(e) {
                self.click_toggle_class(e, move_class + top_postfix);
                if (self.settings.open_method !== 'overlap') {
                    S('.bottom-submenu').removeClass(move_class + top_postfix);
                }
                $('.bottom-off-canvas-toggle').attr('aria-expanded', 'true');
            }).on('click.fndtn.offcanvas', '.bottom-off-canvas-menu a', function(e) {
                var settings = self.get_settings(e);
                var parent = S(this).parent();

                if (settings.close_on_click && !parent.hasClass('has-submenu') && !parent.hasClass('back')) {
                    self.hide.call(self, move_class + top_postfix, self.get_wrapper(e));
                    parent.parent().removeClass(move_class + top_postfix);
                } else if (S(this).parent().hasClass('has-submenu')) {
                    e.preventDefault();
                    S(this).siblings('.bottom-submenu').toggleClass(move_class + top_postfix);
                } else if (parent.hasClass('back')) {
                    e.preventDefault();
                    parent.parent().removeClass(move_class + top_postfix);
                }
                $('.bottom-off-canvas-toggle').attr('aria-expanded', 'true');
            })//end of bottom
            .on('click.fndtn.offcanvas', '.exit-off-canvas', function(e) {
                self.click_remove_class(e, move_class + left_postfix);
                S('.right-submenu').removeClass(move_class + left_postfix);
                if (right_postfix) {
                    self.click_remove_class(e, move_class + right_postfix);
                    S('.left-submenu').removeClass(move_class + left_postfix);
                }
                $('.right-off-canvas-toggle').attr('aria-expanded', 'true');
            }).on('click.fndtn.offcanvas', '.exit-off-canvas', function(e) {
                self.click_remove_class(e, move_class + left_postfix);
                $('.left-off-canvas-toggle').attr('aria-expanded', 'false');
                if (right_postfix) {
                    self.click_remove_class(e, move_class + right_postfix);
                    $('.right-off-canvas-toggle').attr('aria-expanded', 'false');
                }
            }).on('click.fndtn.offcanvas', '.exit-off-canvas', function(e) {
                self.click_remove_class(e, move_class + top_postfix);
                S('.bottom-submenu').removeClass(move_class + top_postfix);
                if (bottom_postfix) {
                    self.click_remove_class(e, move_class + bottom_postfix);
                    S('.top-submenu').removeClass(move_class + top_postfix);
                }
                $('.bottom-off-canvas-toggle').attr('aria-expanded', 'true');
            }).on('click.fndtn.offcanvas', '.exit-off-canvas', function(e) {
                self.click_remove_class(e, move_class + top_postfix);
                $('.top-off-canvas-toggle').attr('aria-expanded', 'false');
                if (bottom_postfix) {
                    self.click_remove_class(e, move_class + bottom_postfix);
                    $('.bottom-off-canvas-toggle').attr('aria-expanded', 'false');
                }
            });
        },

        toggle: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper();
            if ($off_canvas.is('.' + class_name)) {
                this.hide(class_name, $off_canvas);
            } else {
                this.show(class_name, $off_canvas);
            }
        },

        show: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper();
            $off_canvas.trigger('open.fndtn.offcanvas');
            $off_canvas.addClass(class_name);
        },

        hide: function(class_name, $off_canvas) {
            $off_canvas = $off_canvas || this.get_wrapper();
            $off_canvas.trigger('close.fndtn.offcanvas');
            $off_canvas.removeClass(class_name);
        },

        click_toggle_class: function(e, class_name) {
            e.preventDefault();
            var $off_canvas = this.get_wrapper(e);
            this.toggle(class_name, $off_canvas);
        },

        click_remove_class: function(e, class_name) {
            e.preventDefault();
            var $off_canvas = this.get_wrapper(e);
            this.hide(class_name, $off_canvas);
        },

        get_settings: function(e) {
            var offcanvas = this.S(e.target).closest('[' + this.attr_name() + ']');
            return offcanvas.data(this.attr_name(true) + '-init') || this.settings;
        },

        get_wrapper: function(e) {
            var $off_canvas = this.S(e ? e.target : this.scope).closest('.off-canvas-wrap');

            if ($off_canvas.length === 0) {
                $off_canvas = this.S('.off-canvas-wrap');
            }
            return $off_canvas;
        },

        reflow: function() {}
    };
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    var noop = function() {};

    var Orbit = function(el, settings) {
        // Don't reinitialize plugin
        if (el.hasClass(settings.slides_container_class)) {
            return this;
        }

        var self = this, container, slides_container = el, number_container, bullets_container, timer_container, idx = 0, animate, timer, locked = false, adjust_height_after = false;

        self.slides = function() {
            return slides_container.children(settings.slide_selector);
        }
        ;

        self.slides().first().addClass(settings.active_slide_class);

        self.update_slide_number = function(index) {
            if (settings.slide_number) {
                number_container.find('span:first').text(parseInt(index) + 1);
                number_container.find('span:last').text(self.slides().length);
            }
            if (settings.bullets) {
                bullets_container.children().removeClass(settings.bullets_active_class);
                $(bullets_container.children().get(index)).addClass(settings.bullets_active_class);
            }
        }
        ;

        self.update_active_link = function(index) {
            var link = $('[data-orbit-link="' + self.slides().eq(index).attr('data-orbit-slide') + '"]');
            link.siblings().removeClass(settings.bullets_active_class);
            link.addClass(settings.bullets_active_class);
        }
        ;

        self.build_markup = function() {
            slides_container.wrap('<div class="' + settings.container_class + '"></div>');
            container = slides_container.parent();
            slides_container.addClass(settings.slides_container_class);

            if (settings.stack_on_small) {
                container.addClass(settings.stack_on_small_class);
            }

            if (settings.navigation_arrows) {
                container.append($('<a href="#"><span></span></a>').addClass(settings.prev_class));
                container.append($('<a href="#"><span></span></a>').addClass(settings.next_class));
            }

            if (settings.timer) {
                timer_container = $('<div>').addClass(settings.timer_container_class);
                timer_container.append('<span>');
                timer_container.append($('<div>').addClass(settings.timer_progress_class));
                timer_container.addClass(settings.timer_paused_class);
                container.append(timer_container);
            }

            if (settings.slide_number) {
                number_container = $('<div>').addClass(settings.slide_number_class);
                number_container.append('<span></span> ' + settings.slide_number_text + ' <span></span>');
                container.append(number_container);
            }

            if (settings.bullets) {
                bullets_container = $('<ol>').addClass(settings.bullets_container_class);
                container.append(bullets_container);
                bullets_container.wrap('<div class="orbit-bullets-container"></div>');
                self.slides().each(function(idx, el) {
                    var bullet = $('<li>').attr('data-orbit-slide', idx).on('click', self.link_bullet);
                    ;bullets_container.append(bullet);
                });
            }

        }
        ;

        self._goto = function(next_idx, start_timer) {
            // if (locked) {return false;}
            if (next_idx === idx) {
                return false;
            }
            if (typeof timer === 'object') {
                timer.restart();
            }
            var slides = self.slides();

            var dir = 'next';
            locked = true;
            if (next_idx < idx) {
                dir = 'prev';
            }
            if (next_idx >= slides.length) {
                if (!settings.circular) {
                    return false;
                }
                next_idx = 0;
            } else if (next_idx < 0) {
                if (!settings.circular) {
                    return false;
                }
                next_idx = slides.length - 1;
            }

            var current = $(slides.get(idx));
            var next = $(slides.get(next_idx));

            current.css('zIndex', 2);
            current.removeClass(settings.active_slide_class);
            next.css('zIndex', 4).addClass(settings.active_slide_class);

            slides_container.trigger('before-slide-change.fndtn.orbit');
            settings.before_slide_change();
            self.update_active_link(next_idx);

            var callback = function() {
                var unlock = function() {
                    idx = next_idx;
                    locked = false;
                    if (start_timer === true) {
                        timer = self.create_timer();
                        timer.start();
                    }
                    self.update_slide_number(idx);
                    slides_container.trigger('after-slide-change.fndtn.orbit', [{
                        slide_number: idx,
                        total_slides: slides.length
                    }]);
                    settings.after_slide_change(idx, slides.length);
                };
                if (slides_container.outerHeight() != next.outerHeight() && settings.variable_height) {
                    slides_container.animate({
                        'height': next.outerHeight()
                    }, 250, 'linear', unlock);
                } else {
                    unlock();
                }
            };

            if (slides.length === 1) {
                callback();
                return false;
            }

            var start_animation = function() {
                if (dir === 'next') {
                    animate.next(current, next, callback);
                }
                if (dir === 'prev') {
                    animate.prev(current, next, callback);
                }
            };

            if (next.outerHeight() > slides_container.outerHeight() && settings.variable_height) {
                slides_container.animate({
                    'height': next.outerHeight()
                }, 250, 'linear', start_animation);
            } else {
                start_animation();
            }
        }
        ;

        self.next = function(e) {
            e.stopImmediatePropagation();
            e.preventDefault();
            self._goto(idx + 1);
        }
        ;

        self.prev = function(e) {
            e.stopImmediatePropagation();
            e.preventDefault();
            self._goto(idx - 1);
        }
        ;

        self.link_custom = function(e) {
            e.preventDefault();
            var link = $(this).attr('data-orbit-link');
            if ((typeof link === 'string') && (link = $.trim(link)) != '') {
                var slide = container.find('[data-orbit-slide=' + link + ']');
                if (slide.index() != -1) {
                    self._goto(slide.index());
                }
            }
        }
        ;

        self.link_bullet = function(e) {
            var index = $(this).attr('data-orbit-slide');
            if ((typeof index === 'string') && (index = $.trim(index)) != '') {
                if (isNaN(parseInt(index))) {
                    var slide = container.find('[data-orbit-slide=' + index + ']');
                    if (slide.index() != -1) {
                        self._goto(slide.index() + 1);
                    }
                } else {
                    self._goto(parseInt(index));
                }
            }

        }

        self.timer_callback = function() {
            self._goto(idx + 1, true);
        }

        self.compute_dimensions = function() {
            var current = $(self.slides().get(idx));
            var h = current.outerHeight();
            if (!settings.variable_height) {
                self.slides().each(function() {
                    if ($(this).outerHeight() > h) {
                        h = $(this).outerHeight();
                    }
                });
            }
            slides_container.height(h);
        }
        ;

        self.create_timer = function() {
            var t = new Timer(container.find('.' + settings.timer_container_class),settings,self.timer_callback);
            return t;
        }
        ;

        self.stop_timer = function() {
            if (typeof timer === 'object') {
                timer.stop();
            }
        }
        ;

        self.toggle_timer = function() {
            var t = container.find('.' + settings.timer_container_class);
            if (t.hasClass(settings.timer_paused_class)) {
                if (typeof timer === 'undefined') {
                    timer = self.create_timer();
                }
                timer.start();
            } else {
                if (typeof timer === 'object') {
                    timer.stop();
                }
            }
        }
        ;

        self.init = function() {
            self.build_markup();
            if (settings.timer) {
                timer = self.create_timer();
                Foundation.utils.image_loaded(this.slides().children('img'), timer.start);
            }
            animate = new FadeAnimation(settings,slides_container);
            if (settings.animation === 'slide') {
                animate = new SlideAnimation(settings,slides_container);
            }

            container.on('click', '.' + settings.next_class, self.next);
            container.on('click', '.' + settings.prev_class, self.prev);

            if (settings.next_on_click) {
                container.on('click', '.' + settings.slides_container_class + ' [data-orbit-slide]', self.link_bullet);
            }

            container.on('click', self.toggle_timer);
            if (settings.swipe) {
                container.on('touchstart.fndtn.orbit', function(e) {
                    if (!e.touches) {
                        e = e.originalEvent;
                    }
                    var data = {
                        start_page_x: e.touches[0].pageX,
                        start_page_y: e.touches[0].pageY,
                        start_time: (new Date()).getTime(),
                        delta_x: 0,
                        is_scrolling: undefined
                    };
                    container.data('swipe-transition', data);
                    e.stopPropagation();
                }).on('touchmove.fndtn.orbit', function(e) {
                    if (!e.touches) {
                        e = e.originalEvent;
                    }
                    // Ignore pinch/zoom events
                    if (e.touches.length > 1 || e.scale && e.scale !== 1) {
                        return;
                    }

                    var data = container.data('swipe-transition');
                    if (typeof data === 'undefined') {
                        data = {};
                    }

                    data.delta_x = e.touches[0].pageX - data.start_page_x;

                    if (typeof data.is_scrolling === 'undefined') {
                        data.is_scrolling = !!(data.is_scrolling || Math.abs(data.delta_x) < Math.abs(e.touches[0].pageY - data.start_page_y));
                    }

                    if (!data.is_scrolling && !data.active) {
                        e.preventDefault();
                        var direction = (data.delta_x < 0) ? (idx + 1) : (idx - 1);
                        data.active = true;
                        self._goto(direction);
                    }
                }).on('touchend.fndtn.orbit', function(e) {
                    container.data('swipe-transition', {});
                    e.stopPropagation();
                })
            }
            container.on('mouseenter.fndtn.orbit', function(e) {
                if (settings.timer && settings.pause_on_hover) {
                    self.stop_timer();
                }
            }).on('mouseleave.fndtn.orbit', function(e) {
                if (settings.timer && settings.resume_on_mouseout) {
                    timer.start();
                }
            });

            $(document).on('click', '[data-orbit-link]', self.link_custom);
            $(window).on('load resize', self.compute_dimensions);
            Foundation.utils.image_loaded(this.slides().children('img'), self.compute_dimensions);
            Foundation.utils.image_loaded(this.slides().children('img'), function() {
                container.prev('.' + settings.preloader_class).css('display', 'none');
                self.update_slide_number(0);
                self.update_active_link(0);
                slides_container.trigger('ready.fndtn.orbit');
            });
        }
        ;

        self.init();
    };

    var Timer = function(el, settings, callback) {
        var self = this, duration = settings.timer_speed, progress = el.find('.' + settings.timer_progress_class), start, timeout, left = -1;

        this.update_progress = function(w) {
            var new_progress = progress.clone();
            new_progress.attr('style', '');
            new_progress.css('width', w + '%');
            progress.replaceWith(new_progress);
            progress = new_progress;
        }
        ;

        this.restart = function() {
            clearTimeout(timeout);
            el.addClass(settings.timer_paused_class);
            left = -1;
            self.update_progress(0);
        }
        ;

        this.start = function() {
            if (!el.hasClass(settings.timer_paused_class)) {
                return true;
            }
            left = (left === -1) ? duration : left;
            el.removeClass(settings.timer_paused_class);
            start = new Date().getTime();
            progress.animate({
                'width': '100%'
            }, left, 'linear');
            timeout = setTimeout(function() {
                self.restart();
                callback();
            }, left);
            el.trigger('timer-started.fndtn.orbit')
        }
        ;

        this.stop = function() {
            if (el.hasClass(settings.timer_paused_class)) {
                return true;
            }
            clearTimeout(timeout);
            el.addClass(settings.timer_paused_class);
            var end = new Date().getTime();
            left = left - (end - start);
            var w = 100 - ((left / duration) * 100);
            self.update_progress(w);
            el.trigger('timer-stopped.fndtn.orbit');
        }
        ;
    };

    var SlideAnimation = function(settings, container) {
        var duration = settings.animation_speed;
        var is_rtl = ($('html[dir=rtl]').length === 1);
        var margin = is_rtl ? 'marginRight' : 'marginLeft';
        var animMargin = {};
        animMargin[margin] = '0%';

        this.next = function(current, next, callback) {
            current.animate({
                marginLeft: '-100%'
            }, duration);
            next.animate(animMargin, duration, function() {
                current.css(margin, '100%');
                callback();
            });
        }
        ;

        this.prev = function(current, prev, callback) {
            current.animate({
                marginLeft: '100%'
            }, duration);
            prev.css(margin, '-100%');
            prev.animate(animMargin, duration, function() {
                current.css(margin, '100%');
                callback();
            });
        }
        ;
    };

    var FadeAnimation = function(settings, container) {
        var duration = settings.animation_speed;
        var is_rtl = ($('html[dir=rtl]').length === 1);
        var margin = is_rtl ? 'marginRight' : 'marginLeft';

        this.next = function(current, next, callback) {
            next.css({
                'margin': '0%',
                'opacity': '0.01'
            });
            next.animate({
                'opacity': '1'
            }, duration, 'linear', function() {
                current.css('margin', '100%');
                callback();
            });
        }
        ;

        this.prev = function(current, prev, callback) {
            prev.css({
                'margin': '0%',
                'opacity': '0.01'
            });
            prev.animate({
                'opacity': '1'
            }, duration, 'linear', function() {
                current.css('margin', '100%');
                callback();
            });
        }
        ;
    };

    Foundation.libs = Foundation.libs || {};

    Foundation.libs.orbit = {
        name: 'orbit',

        version: '5.5.3',

        settings: {
            animation: 'slide',
            timer_speed: 10000,
            pause_on_hover: true,
            resume_on_mouseout: false,
            next_on_click: true,
            animation_speed: 500,
            stack_on_small: false,
            navigation_arrows: true,
            slide_number: true,
            slide_number_text: 'of',
            container_class: 'orbit-container',
            stack_on_small_class: 'orbit-stack-on-small',
            next_class: 'orbit-next',
            prev_class: 'orbit-prev',
            timer_container_class: 'orbit-timer',
            timer_paused_class: 'paused',
            timer_progress_class: 'orbit-progress',
            slides_container_class: 'orbit-slides-container',
            preloader_class: 'preloader',
            slide_selector: '*',
            bullets_container_class: 'orbit-bullets',
            bullets_active_class: 'active',
            slide_number_class: 'orbit-slide-number',
            caption_class: 'orbit-caption',
            active_slide_class: 'active',
            orbit_transition_class: 'orbit-transitioning',
            bullets: true,
            circular: true,
            timer: true,
            variable_height: false,
            swipe: true,
            before_slide_change: noop,
            after_slide_change: noop
        },

        init: function(scope, method, options) {
            var self = this;
            this.bindings(method, options);
        },

        events: function(instance) {
            var orbit_instance = new Orbit(this.S(instance),this.S(instance).data('orbit-init'));
            this.S(instance).data(this.name + '-instance', orbit_instance);
        },

        reflow: function() {
            var self = this;

            if (self.S(self.scope).is('[data-orbit]')) {
                var $el = self.S(self.scope);
                var instance = $el.data(self.name + '-instance');
                instance.compute_dimensions();
            } else {
                self.S('[data-orbit]', self.scope).each(function(idx, el) {
                    var $el = self.S(el);
                    var opts = self.data_options($el);
                    var instance = $el.data(self.name + '-instance');
                    instance.compute_dimensions();
                });
            }
        }
    };

}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    var openModals = [];

    Foundation.libs.reveal = {
        name: 'reveal',

        version: '5.5.3',

        locked: false,

        settings: {
            animation: 'fadeAndPop',
            animation_speed: 250,
            close_on_background_click: true,
            close_on_esc: true,
            dismiss_modal_class: 'close-reveal-modal',
            multiple_opened: false,
            bg_class: 'reveal-modal-bg',
            root_element: 'body',
            open: function() {},
            opened: function() {},
            close: function() {},
            closed: function() {},
            on_ajax_error: $.noop,
            bg: $('.reveal-modal-bg'),
            css: {
                open: {
                    'opacity': 0,
                    'visibility': 'visible',
                    'display': 'block'
                },
                close: {
                    'opacity': 1,
                    'visibility': 'hidden',
                    'display': 'none'
                }
            }
        },

        init: function(scope, method, options) {
            $.extend(true, this.settings, method, options);
            this.bindings(method, options);
        },

        events: function(scope) {
            var self = this
              , S = self.S;

            S(this.scope).off('.reveal').on('click.fndtn.reveal', '[' + this.add_namespace('data-reveal-id') + ']:not([disabled])', function(e) {
                e.preventDefault();

                if (!self.locked) {
                    var element = S(this)
                      , ajax = element.data(self.data_attr('reveal-ajax'))
                      , replaceContentSel = element.data(self.data_attr('reveal-replace-content'));

                    self.locked = true;

                    if (typeof ajax === 'undefined') {
                        self.open.call(self, element);
                    } else {
                        var url = ajax === true ? element.attr('href') : ajax;
                        self.open.call(self, element, {
                            url: url
                        }, {
                            replaceContentSel: replaceContentSel
                        });
                    }
                }
            });

            S(document).on('click.fndtn.reveal', this.close_targets(), function(e) {
                e.preventDefault();
                if (!self.locked) {
                    var settings = S('[' + self.attr_name() + '].open').data(self.attr_name(true) + '-init') || self.settings
                      , bg_clicked = S(e.target)[0] === S('.' + settings.bg_class)[0];

                    if (bg_clicked) {
                        if (settings.close_on_background_click) {
                            e.stopPropagation();
                        } else {
                            return;
                        }
                    }

                    self.locked = true;
                    self.close.call(self, bg_clicked ? S('[' + self.attr_name() + '].open:not(.toback)') : S(this).closest('[' + self.attr_name() + ']'));
                }
            });

            if (S('[' + self.attr_name() + ']', this.scope).length > 0) {
                S(this.scope)// .off('.reveal')
                .on('open.fndtn.reveal', this.settings.open).on('opened.fndtn.reveal', this.settings.opened).on('opened.fndtn.reveal', this.open_video).on('close.fndtn.reveal', this.settings.close).on('closed.fndtn.reveal', this.settings.closed).on('closed.fndtn.reveal', this.close_video);
            } else {
                S(this.scope)// .off('.reveal')
                .on('open.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.open).on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.opened).on('opened.fndtn.reveal', '[' + self.attr_name() + ']', this.open_video).on('close.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.close).on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.settings.closed).on('closed.fndtn.reveal', '[' + self.attr_name() + ']', this.close_video);
            }

            return true;
        },

        // PATCH #3: turning on key up capture only when a reveal window is open
        key_up_on: function(scope) {
            var self = this;

            // PATCH #1: fixing multiple keyup event trigger from single key press
            self.S('body').off('keyup.fndtn.reveal').on('keyup.fndtn.reveal', function(event) {
                var open_modal = self.S('[' + self.attr_name() + '].open')
                  , settings = open_modal.data(self.attr_name(true) + '-init') || self.settings;
                // PATCH #2: making sure that the close event can be called only while unlocked,
                //           so that multiple keyup.fndtn.reveal events don't prevent clean closing of the reveal window.
                if (settings && event.which === 27 && settings.close_on_esc && !self.locked) {
                    // 27 is the keycode for the Escape key
                    self.close.call(self, open_modal);
                }
            });

            return true;
        },

        // PATCH #3: turning on key up capture only when a reveal window is open
        key_up_off: function(scope) {
            this.S('body').off('keyup.fndtn.reveal');
            return true;
        },

        open: function(target, ajax_settings) {
            var self = this, modal;

            if (target) {
                if (typeof target.selector !== 'undefined') {
                    // Find the named node; only use the first one found, since the rest of the code assumes there's only one node
                    modal = self.S('#' + target.data(self.data_attr('reveal-id'))).first();
                } else {
                    modal = self.S(this.scope);

                    ajax_settings = target;
                }
            } else {
                modal = self.S(this.scope);
            }

            var settings = modal.data(self.attr_name(true) + '-init');
            settings = settings || this.settings;

            if (modal.hasClass('open') && target !== undefined && target.attr('data-reveal-id') == modal.attr('id')) {
                return self.close(modal);
            }

            if (!modal.hasClass('open')) {
                var open_modal = self.S('[' + self.attr_name() + '].open');

                if (typeof modal.data('css-top') === 'undefined') {
                    modal.data('css-top', parseInt(modal.css('top'), 10)).data('offset', this.cache_offset(modal));
                }

                modal.attr('tabindex', '0').attr('aria-hidden', 'false');

                this.key_up_on(modal);
                // PATCH #3: turning on key up capture only when a reveal window is open

                // Prevent namespace event from triggering twice
                modal.on('open.fndtn.reveal', function(e) {
                    if (e.namespace !== 'fndtn.reveal')
                        return;
                });

                modal.on('open.fndtn.reveal').trigger('open.fndtn.reveal');

                if (open_modal.length < 1) {
                    this.toggle_bg(modal, true);
                }

                if (typeof ajax_settings === 'string') {
                    ajax_settings = {
                        url: ajax_settings
                    };
                }

                var openModal = function() {
                    if (open_modal.length > 0) {
                        if (settings.multiple_opened) {
                            self.to_back(open_modal);
                        } else {
                            self.hide(open_modal, settings.css.close);
                        }
                    }

                    // bl: add the open_modal that isn't already in the background to the openModals array
                    if (settings.multiple_opened) {
                        openModals.push(modal);
                    }

                    self.show(modal, settings.css.open);
                };

                if (typeof ajax_settings === 'undefined' || !ajax_settings.url) {
                    openModal();
                } else {
                    var old_success = typeof ajax_settings.success !== 'undefined' ? ajax_settings.success : null;
                    $.extend(ajax_settings, {
                        success: function(data, textStatus, jqXHR) {
                            if ($.isFunction(old_success)) {
                                var result = old_success(data, textStatus, jqXHR);
                                if (typeof result == 'string') {
                                    data = result;
                                }
                            }

                            if (typeof options !== 'undefined' && typeof options.replaceContentSel !== 'undefined') {
                                modal.find(options.replaceContentSel).html(data);
                            } else {
                                modal.html(data);
                            }

                            self.S(modal).foundation('section', 'reflow');
                            self.S(modal).children().foundation();

                            openModal();
                        }
                    });

                    // check for if user initalized with error callback
                    if (settings.on_ajax_error !== $.noop) {
                        $.extend(ajax_settings, {
                            error: settings.on_ajax_error
                        });
                    }

                    $.ajax(ajax_settings);
                }
            }
            self.S(window).trigger('resize');
        },

        close: function(modal) {
            var modal = modal && modal.length ? modal : this.S(this.scope)
              , open_modals = this.S('[' + this.attr_name() + '].open')
              , settings = modal.data(this.attr_name(true) + '-init') || this.settings
              , self = this;

            if (open_modals.length > 0) {

                modal.removeAttr('tabindex', '0').attr('aria-hidden', 'true');

                this.locked = true;
                this.key_up_off(modal);
                // PATCH #3: turning on key up capture only when a reveal window is open

                modal.trigger('close.fndtn.reveal');

                if ((settings.multiple_opened && open_modals.length === 1) || !settings.multiple_opened || modal.length > 1) {
                    self.toggle_bg(modal, false);
                    self.to_front(modal);
                }

                if (settings.multiple_opened) {
                    var isCurrent = modal.is(':not(.toback)');
                    self.hide(modal, settings.css.close, settings);
                    if (isCurrent) {
                        // remove the last modal since it is now closed
                        openModals.pop();
                    } else {
                        // if this isn't the current modal, then find it in the array and remove it
                        openModals = $.grep(openModals, function(elt) {
                            var isThis = elt[0] === modal[0];
                            if (isThis) {
                                // since it's not currently in the front, put it in the front now that it is hidden
                                // so that if it's re-opened, it won't be .toback
                                self.to_front(modal);
                            }
                            return !isThis;
                        });
                    }
                    // finally, show the next modal in the stack, if there is one
                    if (openModals.length > 0) {
                        self.to_front(openModals[openModals.length - 1]);
                    }
                } else {
                    self.hide(open_modals, settings.css.close, settings);
                }
            }
        },

        close_targets: function() {
            var base = '.' + this.settings.dismiss_modal_class;

            if (this.settings.close_on_background_click) {
                return base + ', .' + this.settings.bg_class;
            }

            return base;
        },

        toggle_bg: function(modal, state) {
            if (this.S('.' + this.settings.bg_class).length === 0) {
                this.settings.bg = $('<div />', {
                    'class': this.settings.bg_class
                }).appendTo('body').hide();
            }

            var visible = this.settings.bg.filter(':visible').length > 0;
            if (state != visible) {
                if (state == undefined ? visible : !state) {
                    this.hide(this.settings.bg);
                } else {
                    this.show(this.settings.bg);
                }
            }
        },

        show: function(el, css) {
            // is modal
            if (css) {
                var settings = el.data(this.attr_name(true) + '-init') || this.settings
                  , root_element = settings.root_element
                  , context = this;

                if (el.parent(root_element).length === 0) {
                    var placeholder = el.wrap('<div style="display: none;" />').parent();

                    el.on('closed.fndtn.reveal.wrapped', function() {
                        el.detach().appendTo(placeholder);
                        el.unwrap().unbind('closed.fndtn.reveal.wrapped');
                    });

                    el.detach().appendTo(root_element);
                }

                var animData = getAnimationData(settings.animation);
                if (!animData.animate) {
                    this.locked = false;
                }
                if (animData.pop) {
                    css.top = $(window).scrollTop() - el.data('offset') + 'px';
                    var end_css = {
                        top: $(window).scrollTop() + el.data('css-top') + 'px',
                        opacity: 1
                    };

                    return setTimeout(function() {
                        return el.css(css).animate(end_css, settings.animation_speed, 'linear', function() {
                            context.locked = false;
                            el.trigger('opened.fndtn.reveal');
                        }).addClass('open');
                    }, settings.animation_speed / 2);
                }

                css.top = $(window).scrollTop() + el.data('css-top') + 'px';

                if (animData.fade) {
                    var end_css = {
                        opacity: 1
                    };

                    return setTimeout(function() {
                        return el.css(css).animate(end_css, settings.animation_speed, 'linear', function() {
                            context.locked = false;
                            el.trigger('opened.fndtn.reveal');
                        }).addClass('open');
                    }, settings.animation_speed / 2);
                }

                return el.css(css).show().css({
                    opacity: 1
                }).addClass('open').trigger('opened.fndtn.reveal');
            }

            var settings = this.settings;

            // should we animate the background?
            if (getAnimationData(settings.animation).fade) {
                return el.fadeIn(settings.animation_speed / 2);
            }

            this.locked = false;

            return el.show();
        },

        to_back: function(el) {
            el.addClass('toback');
        },

        to_front: function(el) {
            el.removeClass('toback');
        },

        hide: function(el, css) {
            // is modal
            if (css) {
                var settings = el.data(this.attr_name(true) + '-init')
                  , context = this;
                settings = settings || this.settings;

                var animData = getAnimationData(settings.animation);
                if (!animData.animate) {
                    this.locked = false;
                }
                if (animData.pop) {
                    var end_css = {
                        top: -$(window).scrollTop() - el.data('offset') + 'px',
                        opacity: 0
                    };

                    return setTimeout(function() {
                        return el.animate(end_css, settings.animation_speed, 'linear', function() {
                            context.locked = false;
                            el.css(css).trigger('closed.fndtn.reveal');
                        }).removeClass('open');
                    }, settings.animation_speed / 2);
                }

                if (animData.fade) {
                    var end_css = {
                        opacity: 0
                    };

                    return setTimeout(function() {
                        return el.animate(end_css, settings.animation_speed, 'linear', function() {
                            context.locked = false;
                            el.css(css).trigger('closed.fndtn.reveal');
                        }).removeClass('open');
                    }, settings.animation_speed / 2);
                }

                return el.hide().css(css).removeClass('open').trigger('closed.fndtn.reveal');
            }

            var settings = this.settings;

            // should we animate the background?
            if (getAnimationData(settings.animation).fade) {
                return el.fadeOut(settings.animation_speed / 2);
            }

            return el.hide();
        },

        close_video: function(e) {
            var video = $('.flex-video', e.target)
              , iframe = $('iframe', video);

            if (iframe.length > 0) {
                iframe.attr('data-src', iframe[0].src);
                iframe.attr('src', iframe.attr('src'));
                video.hide();
            }
        },

        open_video: function(e) {
            var video = $('.flex-video', e.target)
              , iframe = video.find('iframe');

            if (iframe.length > 0) {
                var data_src = iframe.attr('data-src');
                if (typeof data_src === 'string') {
                    iframe[0].src = iframe.attr('data-src');
                } else {
                    var src = iframe[0].src;
                    iframe[0].src = undefined;
                    iframe[0].src = src;
                }
                video.show();
            }
        },

        data_attr: function(str) {
            if (this.namespace.length > 0) {
                return this.namespace + '-' + str;
            }

            return str;
        },

        cache_offset: function(modal) {
            var offset = modal.show().height() + parseInt(modal.css('top'), 10) + modal.scrollY;

            modal.hide();

            return offset;
        },

        off: function() {
            $(this.scope).off('.fndtn.reveal');
        },

        reflow: function() {}
    };

    /*
   * getAnimationData('popAndFade') // {animate: true,  pop: true,  fade: true}
   * getAnimationData('fade')       // {animate: true,  pop: false, fade: true}
   * getAnimationData('pop')        // {animate: true,  pop: true,  fade: false}
   * getAnimationData('foo')        // {animate: false, pop: false, fade: false}
   * getAnimationData(null)         // {animate: false, pop: false, fade: false}
   */
    function getAnimationData(str) {
        var fade = /fade/i.test(str);
        var pop = /pop/i.test(str);
        return {
            animate: fade || pop,
            pop: pop,
            fade: fade
        };
    }
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.slider = {
        name: 'slider',

        version: '5.5.3',

        settings: {
            start: 0,
            end: 100,
            step: 1,
            precision: 2,
            initial: null,
            display_selector: '',
            vertical: false,
            trigger_input_change: false,
            on_change: function() {}
        },

        cache: {},

        init: function(scope, method, options) {
            Foundation.inherit(this, 'throttle');
            this.bindings(method, options);
            this.reflow();
        },

        events: function() {
            var self = this;
            $(this.scope).off('.slider').on('mousedown.fndtn.slider touchstart.fndtn.slider pointerdown.fndtn.slider', '[' + self.attr_name() + ']:not(.disabled, [disabled]) .range-slider-handle', function(e) {
                if (!self.cache.active) {
                    e.preventDefault();
                    self.set_active_slider($(e.target));
                }
            }).on('mousemove.fndtn.slider touchmove.fndtn.slider pointermove.fndtn.slider', function(e) {
                if (!!self.cache.active) {
                    e.preventDefault();
                    if ($.data(self.cache.active[0], 'settings').vertical) {
                        var scroll_offset = 0;
                        if (!e.pageY) {
                            scroll_offset = window.scrollY;
                        }
                        self.calculate_position(self.cache.active, self.get_cursor_position(e, 'y') + scroll_offset);
                    } else {
                        self.calculate_position(self.cache.active, self.get_cursor_position(e, 'x'));
                    }
                }
            }).on('mouseup.fndtn.slider touchend.fndtn.slider pointerup.fndtn.slider', function(e) {
                if (!self.cache.active) {
                    // if the user has just clicked into the slider without starting to drag the handle
                    var slider = $(e.target).attr('role') === 'slider' ? $(e.target) : $(e.target).closest('.range-slider').find("[role='slider']");

                    if (slider.length && (!slider.parent().hasClass('disabled') && !slider.parent().attr('disabled'))) {
                        self.set_active_slider(slider);
                        if ($.data(self.cache.active[0], 'settings').vertical) {
                            var scroll_offset = 0;
                            if (!e.pageY) {
                                scroll_offset = window.scrollY;
                            }
                            self.calculate_position(self.cache.active, self.get_cursor_position(e, 'y') + scroll_offset);
                        } else {
                            self.calculate_position(self.cache.active, self.get_cursor_position(e, 'x'));
                        }
                    }
                }
                self.remove_active_slider();
            }).on('change.fndtn.slider', function(e) {
                self.settings.on_change();
            });

            self.S(window).on('resize.fndtn.slider', self.throttle(function(e) {
                self.reflow();
            }, 300));

            // update slider value as users change input value
            this.S('[' + this.attr_name() + ']').each(function() {
                var slider = $(this)
                  , handle = slider.children('.range-slider-handle')[0]
                  , settings = self.initialize_settings(handle);

                if (settings.display_selector != '') {
                    $(settings.display_selector).each(function() {
                        if ($(this).attr('value')) {
                            $(this).off('change').on('change', function() {
                                slider.foundation("slider", "set_value", $(this).val());
                            });
                        }
                    });
                }
            });
        },

        get_cursor_position: function(e, xy) {
            var pageXY = 'page' + xy.toUpperCase(), clientXY = 'client' + xy.toUpperCase(), position;

            if (typeof e[pageXY] !== 'undefined') {
                position = e[pageXY];
            } else if (typeof e.originalEvent[clientXY] !== 'undefined') {
                position = e.originalEvent[clientXY];
            } else if (e.originalEvent.touches && e.originalEvent.touches[0] && typeof e.originalEvent.touches[0][clientXY] !== 'undefined') {
                position = e.originalEvent.touches[0][clientXY];
            } else if (e.currentPoint && typeof e.currentPoint[xy] !== 'undefined') {
                position = e.currentPoint[xy];
            }

            return position;
        },

        set_active_slider: function($handle) {
            this.cache.active = $handle;
        },

        remove_active_slider: function() {
            this.cache.active = null;
        },

        calculate_position: function($handle, cursor_x) {
            var self = this
              , settings = $.data($handle[0], 'settings')
              , handle_l = $.data($handle[0], 'handle_l')
              , handle_o = $.data($handle[0], 'handle_o')
              , bar_l = $.data($handle[0], 'bar_l')
              , bar_o = $.data($handle[0], 'bar_o');

            requestAnimationFrame(function() {
                var pct;

                if (Foundation.rtl && !settings.vertical) {
                    pct = self.limit_to(((bar_o + bar_l - cursor_x) / bar_l), 0, 1);
                } else {
                    pct = self.limit_to(((cursor_x - bar_o) / bar_l), 0, 1);
                }

                pct = settings.vertical ? 1 - pct : pct;

                var norm = self.normalized_value(pct, settings.start, settings.end, settings.step, settings.precision);

                self.set_ui($handle, norm);
            });
        },

        set_ui: function($handle, value) {
            var settings = $.data($handle[0], 'settings')
              , handle_l = $.data($handle[0], 'handle_l')
              , bar_l = $.data($handle[0], 'bar_l')
              , norm_pct = this.normalized_percentage(value, settings.start, settings.end)
              , handle_offset = norm_pct * (bar_l - handle_l) - 1
              , progress_bar_length = norm_pct * 100
              , $handle_parent = $handle.parent()
              , $hidden_inputs = $handle.parent().children('input[type=hidden]');

            if (Foundation.rtl && !settings.vertical) {
                handle_offset = -handle_offset;
            }

            handle_offset = settings.vertical ? -handle_offset + bar_l - handle_l + 1 : handle_offset;
            this.set_translate($handle, handle_offset, settings.vertical);

            if (settings.vertical) {
                $handle.siblings('.range-slider-active-segment').css('height', progress_bar_length + '%');
            } else {
                $handle.siblings('.range-slider-active-segment').css('width', progress_bar_length + '%');
            }

            $handle_parent.attr(this.attr_name(), value).trigger('change.fndtn.slider');

            $hidden_inputs.val(value);
            if (settings.trigger_input_change) {
                $hidden_inputs.trigger('change.fndtn.slider');
            }

            if (!$handle[0].hasAttribute('aria-valuemin')) {
                $handle.attr({
                    'aria-valuemin': settings.start,
                    'aria-valuemax': settings.end
                });
            }
            $handle.attr('aria-valuenow', value);

            if (settings.display_selector != '') {
                $(settings.display_selector).each(function() {
                    if (this.hasAttribute('value')) {
                        $(this).val(value);
                    } else {
                        $(this).text(value);
                    }
                });
            }

        },

        normalized_percentage: function(val, start, end) {
            return Math.min(1, (val - start) / (end - start));
        },

        normalized_value: function(val, start, end, step, precision) {
            var range = end - start
              , point = val * range
              , mod = (point - (point % step)) / step
              , rem = point % step
              , round = (rem >= step * 0.5 ? step : 0);
            return ((mod * step + round) + start).toFixed(precision);
        },

        set_translate: function(ele, offset, vertical) {
            if (vertical) {
                $(ele).css('-webkit-transform', 'translateY(' + offset + 'px)').css('-moz-transform', 'translateY(' + offset + 'px)').css('-ms-transform', 'translateY(' + offset + 'px)').css('-o-transform', 'translateY(' + offset + 'px)').css('transform', 'translateY(' + offset + 'px)');
            } else {
                $(ele).css('-webkit-transform', 'translateX(' + offset + 'px)').css('-moz-transform', 'translateX(' + offset + 'px)').css('-ms-transform', 'translateX(' + offset + 'px)').css('-o-transform', 'translateX(' + offset + 'px)').css('transform', 'translateX(' + offset + 'px)');
            }
        },

        limit_to: function(val, min, max) {
            return Math.min(Math.max(val, min), max);
        },

        initialize_settings: function(handle) {
            var settings = $.extend({}, this.settings, this.data_options($(handle).parent())), decimal_places_match_result;

            if (settings.precision === null) {
                decimal_places_match_result = ('' + settings.step).match(/\.([\d]*)/);
                settings.precision = decimal_places_match_result && decimal_places_match_result[1] ? decimal_places_match_result[1].length : 0;
            }

            if (settings.vertical) {
                $.data(handle, 'bar_o', $(handle).parent().offset().top);
                $.data(handle, 'bar_l', $(handle).parent().outerHeight());
                $.data(handle, 'handle_o', $(handle).offset().top);
                $.data(handle, 'handle_l', $(handle).outerHeight());
            } else {
                $.data(handle, 'bar_o', $(handle).parent().offset().left);
                $.data(handle, 'bar_l', $(handle).parent().outerWidth());
                $.data(handle, 'handle_o', $(handle).offset().left);
                $.data(handle, 'handle_l', $(handle).outerWidth());
            }

            $.data(handle, 'bar', $(handle).parent());
            return $.data(handle, 'settings', settings);
        },

        set_initial_position: function($ele) {
            var settings = $.data($ele.children('.range-slider-handle')[0], 'settings')
              , initial = ((typeof settings.initial == 'number' && !isNaN(settings.initial)) ? settings.initial : Math.floor((settings.end - settings.start) * 0.5 / settings.step) * settings.step + settings.start)
              , $handle = $ele.children('.range-slider-handle');
            this.set_ui($handle, initial);
        },

        set_value: function(value) {
            var self = this;
            $('[' + self.attr_name() + ']', this.scope).each(function() {
                $(this).attr(self.attr_name(), value);
            });
            if (!!$(this.scope).attr(self.attr_name())) {
                $(this.scope).attr(self.attr_name(), value);
            }
            self.reflow();
        },

        reflow: function() {
            var self = this;
            self.S('[' + this.attr_name() + ']').each(function() {
                var handle = $(this).children('.range-slider-handle')[0]
                  , val = $(this).attr(self.attr_name());
                self.initialize_settings(handle);

                if (val) {
                    self.set_ui($(handle), parseFloat(val));
                } else {
                    self.set_initial_position($(this));
                }
            });
        }
    };

}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.tab = {
        name: 'tab',

        version: '5.5.3',

        settings: {
            active_class: 'active',
            callback: function() {},
            deep_linking: false,
            scroll_to_content: true,
            is_hover: false
        },

        default_tab_hashes: [],

        init: function(scope, method, options) {
            var self = this
              , S = this.S;

            // Store the default active tabs which will be referenced when the
            // location hash is absent, as in the case of navigating the tabs and
            // returning to the first viewing via the browser Back button.
            S('[' + this.attr_name() + '] > .active > a', this.scope).each(function() {
                self.default_tab_hashes.push(this.hash);
            });

            this.bindings(method, options);
            this.handle_location_hash_change();
        },

        events: function() {
            var self = this
              , S = this.S;

            var usual_tab_behavior = function(e, target) {
                var settings = S(target).closest('[' + self.attr_name() + ']').data(self.attr_name(true) + '-init');
                if (!settings.is_hover || Modernizr.touch) {
                    // if user did not pressed tab key, prevent default action
                    var keyCode = e.keyCode || e.which;
                    if (keyCode !== 9) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                    self.toggle_active_tab(S(target).parent());

                }
            };

            S(this.scope).off('.tab')// Key event: focus/tab key
            .on('keydown.fndtn.tab', '[' + this.attr_name() + '] > * > a', function(e) {
                var keyCode = e.keyCode || e.which;
                // if user pressed tab key
                if (keyCode === 13 || keyCode === 32) {
                    // enter or space
                    var el = this;
                    usual_tab_behavior(e, el);
                }
            })// Click event: tab title
            .on('click.fndtn.tab', '[' + this.attr_name() + '] > * > a', function(e) {
                var el = this;
                usual_tab_behavior(e, el);
            })// Hover event: tab title
            .on('mouseenter.fndtn.tab', '[' + this.attr_name() + '] > * > a', function(e) {
                var settings = S(this).closest('[' + self.attr_name() + ']').data(self.attr_name(true) + '-init');
                if (settings.is_hover) {
                    self.toggle_active_tab(S(this).parent());
                }
            });

            // Location hash change event
            S(window).on('hashchange.fndtn.tab', function(e) {
                e.preventDefault();
                self.handle_location_hash_change();
            });
        },

        handle_location_hash_change: function() {

            var self = this
              , S = this.S;

            S('[' + this.attr_name() + ']', this.scope).each(function() {
                var settings = S(this).data(self.attr_name(true) + '-init');
                if (settings.deep_linking) {
                    // Match the location hash to a label
                    var hash;
                    if (settings.scroll_to_content) {
                        hash = self.scope.location.hash;
                    } else {
                        // prefix the hash to prevent anchor scrolling
                        hash = self.scope.location.hash.replace('fndtn-', '');
                    }
                    if (hash != '') {
                        // Check whether the location hash references a tab content div or
                        // another element on the page (inside or outside the tab content div)
                        var hash_element = S(hash);
                        if (hash_element.hasClass('content') && hash_element.parent().hasClass('tabs-content')) {
                            // Tab content div
                            self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=' + hash + ']').parent());
                        } else {
                            // Not the tab content div. If inside the tab content, find the
                            // containing tab and toggle it as active.
                            var hash_tab_container_id = hash_element.closest('.content').attr('id');
                            if (hash_tab_container_id != undefined) {
                                self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=#' + hash_tab_container_id + ']').parent(), hash);
                            }
                        }
                    } else {
                        // Reference the default tab hashes which were initialized in the init function
                        for (var ind = 0; ind < self.default_tab_hashes.length; ind++) {
                            self.toggle_active_tab($('[' + self.attr_name() + '] > * > a[href=' + self.default_tab_hashes[ind] + ']').parent());
                        }
                    }
                }
            });
        },

        toggle_active_tab: function(tab, location_hash) {
            var self = this
              , S = self.S
              , tabs = tab.closest('[' + this.attr_name() + ']')
              , tab_link = tab.find('a')
              , anchor = tab.children('a').first()
              , target_hash = '#' + anchor.attr('href').split('#')[1]
              , target = S(target_hash)
              , siblings = tab.siblings()
              , settings = tabs.data(this.attr_name(true) + '-init')
              , interpret_keyup_action = function(e) {
                // Light modification of Heydon Pickering's Practical ARIA Examples: http://heydonworks.com/practical_aria_examples/js/a11y.js

                // define current, previous and next (possible) tabs

                var $original = $(this);
                var $prev = $(this).parents('li').prev().children('[role="tab"]');
                var $next = $(this).parents('li').next().children('[role="tab"]');
                var $target;

                // find the direction (prev or next)

                switch (e.keyCode) {
                case 37:
                    $target = $prev;
                    break;
                case 39:
                    $target = $next;
                    break;
                default:
                    $target = false
                    break;
                }

                if ($target.length) {
                    $original.attr({
                        'tabindex': '-1',
                        'aria-selected': null
                    });
                    $target.attr({
                        'tabindex': '0',
                        'aria-selected': true
                    }).focus();
                }

                // Hide panels

                $('[role="tabpanel"]').attr('aria-hidden', 'true');

                // Show panel which corresponds to target

                $('#' + $(document.activeElement).attr('href').substring(1)).attr('aria-hidden', null);

            }
              , go_to_hash = function(hash) {
                // This function allows correct behaviour of the browser's back button when deep linking is enabled. Without it
                // the user would get continually redirected to the default hash.
                var default_hash = settings.scroll_to_content ? self.default_tab_hashes[0] : 'fndtn-' + self.default_tab_hashes[0].replace('#', '');

                if (hash !== default_hash || window.location.hash) {
                    window.location.hash = hash;
                }
            };

            // allow usage of data-tab-content attribute instead of href
            if (anchor.data('tab-content')) {
                target_hash = '#' + anchor.data('tab-content').split('#')[1];
                target = S(target_hash);
            }

            if (settings.deep_linking) {

                if (settings.scroll_to_content) {

                    // retain current hash to scroll to content
                    go_to_hash(location_hash || target_hash);

                    if (location_hash == undefined || location_hash == target_hash) {
                        tab.parent()[0].scrollIntoView();
                    } else {
                        S(target_hash)[0].scrollIntoView();
                    }
                } else {
                    // prefix the hashes so that the browser doesn't scroll down
                    if (location_hash != undefined) {
                        go_to_hash('fndtn-' + location_hash.replace('#', ''));
                    } else {
                        go_to_hash('fndtn-' + target_hash.replace('#', ''));
                    }
                }
            }

            // WARNING: The activation and deactivation of the tab content must
            // occur after the deep linking in order to properly refresh the browser
            // window (notably in Chrome).
            // Clean up multiple attr instances to done once
            tab.addClass(settings.active_class).triggerHandler('opened');
            tab_link.attr({
                'aria-selected': 'true',
                tabindex: 0
            });
            siblings.removeClass(settings.active_class)
            siblings.find('a').attr({
                'aria-selected': 'false'/*,  tabindex : -1*/
            });
            target.siblings().removeClass(settings.active_class).attr({
                'aria-hidden': 'true'/*,  tabindex : -1*/
            });
            target.addClass(settings.active_class).attr('aria-hidden', 'false').removeAttr('tabindex');
            settings.callback(tab);
            target.triggerHandler('toggled', [target]);
            tabs.triggerHandler('toggled', [tab]);

            tab_link.off('keydown').on('keydown', interpret_keyup_action);
        },

        data_attr: function(str) {
            if (this.namespace.length > 0) {
                return this.namespace + '-' + str;
            }

            return str;
        },

        off: function() {},

        reflow: function() {}
    };
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.tooltip = {
        name: 'tooltip',

        version: '5.5.3',

        settings: {
            additional_inheritable_classes: [],
            tooltip_class: '.tooltip',
            append_to: 'body',
            touch_close_text: 'Tap To Close',
            disable_for_touch: false,
            hover_delay: 200,
            fade_in_duration: 150,
            fade_out_duration: 150,
            show_on: 'all',
            tip_template: function(selector, content) {
                return '<span data-selector="' + selector + '" id="' + selector + '" class="' + Foundation.libs.tooltip.settings.tooltip_class.substring(1) + '" role="tooltip">' + content + '<span class="nub"></span></span>';
            }
        },

        cache: {},

        init: function(scope, method, options) {
            Foundation.inherit(this, 'random_str');
            this.bindings(method, options);
        },

        should_show: function(target, tip) {
            var settings = $.extend({}, this.settings, this.data_options(target));

            if (settings.show_on === 'all') {
                return true;
            } else if (this.small() && settings.show_on === 'small') {
                return true;
            } else if (this.medium() && settings.show_on === 'medium') {
                return true;
            } else if (this.large() && settings.show_on === 'large') {
                return true;
            }
            return false;
        },

        medium: function() {
            return matchMedia(Foundation.media_queries['medium']).matches;
        },

        large: function() {
            return matchMedia(Foundation.media_queries['large']).matches;
        },

        events: function(instance) {
            var self = this
              , S = self.S;

            self.create(this.S(instance));

            function _startShow(elt, $this, immediate) {
                if (elt.timer) {
                    return;
                }

                if (immediate) {
                    elt.timer = null;
                    self.showTip($this);
                } else {
                    elt.timer = setTimeout(function() {
                        elt.timer = null;
                        self.showTip($this);
                    }
                    .bind(elt), self.settings.hover_delay);
                }
            }

            function _startHide(elt, $this) {
                if (elt.timer) {
                    clearTimeout(elt.timer);
                    elt.timer = null;
                }

                self.hide($this);
            }

            $(this.scope).off('.tooltip').on('mouseenter.fndtn.tooltip mouseleave.fndtn.tooltip touchstart.fndtn.tooltip MSPointerDown.fndtn.tooltip', '[' + this.attr_name() + ']', function(e) {
                var $this = S(this)
                  , settings = $.extend({}, self.settings, self.data_options($this))
                  , is_touch = false;

                if (Modernizr.touch && /touchstart|MSPointerDown/i.test(e.type) && S(e.target).is('a')) {
                    return false;
                }

                if (/mouse/i.test(e.type) && self.ie_touch(e)) {
                    return false;
                }

                if ($this.hasClass('open')) {
                    if (Modernizr.touch && /touchstart|MSPointerDown/i.test(e.type)) {
                        e.preventDefault();
                    }
                    self.hide($this);
                } else {
                    if (settings.disable_for_touch && Modernizr.touch && /touchstart|MSPointerDown/i.test(e.type)) {
                        return;
                    } else if (!settings.disable_for_touch && Modernizr.touch && /touchstart|MSPointerDown/i.test(e.type)) {
                        e.preventDefault();
                        S(settings.tooltip_class + '.open').hide();
                        is_touch = true;
                        // close other open tooltips on touch
                        if ($('.open[' + self.attr_name() + ']').length > 0) {
                            var prevOpen = S($('.open[' + self.attr_name() + ']')[0]);
                            self.hide(prevOpen);
                        }
                    }

                    if (/enter|over/i.test(e.type)) {
                        _startShow(this, $this);

                    } else if (e.type === 'mouseout' || e.type === 'mouseleave') {
                        _startHide(this, $this);
                    } else {
                        _startShow(this, $this, true);
                    }
                }
            }).on('mouseleave.fndtn.tooltip touchstart.fndtn.tooltip MSPointerDown.fndtn.tooltip', '[' + this.attr_name() + '].open', function(e) {
                if (/mouse/i.test(e.type) && self.ie_touch(e)) {
                    return false;
                }

                if ($(this).data('tooltip-open-event-type') == 'touch' && e.type == 'mouseleave') {
                    return;
                } else if ($(this).data('tooltip-open-event-type') == 'mouse' && /MSPointerDown|touchstart/i.test(e.type)) {
                    self.convert_to_touch($(this));
                } else {
                    _startHide(this, $(this));
                }
            }).on('DOMNodeRemoved DOMAttrModified', '[' + this.attr_name() + ']:not(a)', function(e) {
                _startHide(this, S(this));
            });
        },

        ie_touch: function(e) {
            // How do I distinguish between IE11 and Windows Phone 8?????
            return false;
        },

        showTip: function($target) {
            var $tip = this.getTip($target);
            if (this.should_show($target, $tip)) {
                return this.show($target);
            }
            return;
        },

        getTip: function($target) {
            var selector = this.selector($target)
              , settings = $.extend({}, this.settings, this.data_options($target))
              , tip = null;

            if (selector) {
                tip = this.S('span[data-selector="' + selector + '"]' + settings.tooltip_class);
            }

            return (typeof tip === 'object') ? tip : false;
        },

        selector: function($target) {
            var dataSelector = $target.attr(this.attr_name()) || $target.attr('data-selector');

            if (typeof dataSelector != 'string') {
                dataSelector = this.random_str(6);
                $target.attr('data-selector', dataSelector).attr('aria-describedby', dataSelector);
            }

            return dataSelector;
        },

        create: function($target) {
            var self = this
              , settings = $.extend({}, this.settings, this.data_options($target))
              , tip_template = this.settings.tip_template;

            if (typeof settings.tip_template === 'string' && window.hasOwnProperty(settings.tip_template)) {
                tip_template = window[settings.tip_template];
            }

            var $tip = $(tip_template(this.selector($target), $('<div></div>').html($target.attr('title')).html()))
              , classes = this.inheritable_classes($target);

            $tip.addClass(classes).appendTo(settings.append_to);

            if (Modernizr.touch) {
                $tip.append('<span class="tap-to-close">' + settings.touch_close_text + '</span>');
                $tip.on('touchstart.fndtn.tooltip MSPointerDown.fndtn.tooltip', function(e) {
                    self.hide($target);
                });
            }

            $target.removeAttr('title').attr('title', '');
        },

        reposition: function(target, tip, classes) {
            var width, nub, nubHeight, nubWidth, objPos;

            tip.css('visibility', 'hidden').show();

            width = target.data('width');
            nub = tip.children('.nub');
            nubHeight = nub.outerHeight();
            nubWidth = nub.outerWidth();

            if (this.small()) {
                tip.css({
                    'width': '100%'
                });
            } else {
                tip.css({
                    'width': (width) ? width : 'auto'
                });
            }

            objPos = function(obj, top, right, bottom, left, width) {
                return obj.css({
                    'top': (top) ? top : 'auto',
                    'bottom': (bottom) ? bottom : 'auto',
                    'left': (left) ? left : 'auto',
                    'right': (right) ? right : 'auto'
                }).end();
            }
            ;

            var o_top = target.offset().top;
            var o_left = target.offset().left;
            var outerHeight = target.outerHeight();

            objPos(tip, (o_top + outerHeight + 10), 'auto', 'auto', o_left);

            if (this.small()) {
                objPos(tip, (o_top + outerHeight + 10), 'auto', 'auto', 12.5, $(this.scope).width());
                tip.addClass('tip-override');
                objPos(nub, -nubHeight, 'auto', 'auto', o_left);
            } else {

                if (Foundation.rtl) {
                    nub.addClass('rtl');
                    o_left = o_left + target.outerWidth() - tip.outerWidth();
                }

                objPos(tip, (o_top + outerHeight + 10), 'auto', 'auto', o_left);
                // reset nub from small styles, if they've been applied
                if (nub.attr('style')) {
                    nub.removeAttr('style');
                }

                tip.removeClass('tip-override');

                var tip_outerHeight = tip.outerHeight();

                if (classes && classes.indexOf('tip-top') > -1) {
                    if (Foundation.rtl) {
                        nub.addClass('rtl');
                    }
                    objPos(tip, (o_top - tip_outerHeight), 'auto', 'auto', o_left).removeClass('tip-override');
                } else if (classes && classes.indexOf('tip-left') > -1) {
                    objPos(tip, (o_top + (outerHeight / 2) - (tip_outerHeight / 2)), 'auto', 'auto', (o_left - tip.outerWidth() - nubHeight)).removeClass('tip-override');
                    nub.removeClass('rtl');
                } else if (classes && classes.indexOf('tip-right') > -1) {
                    objPos(tip, (o_top + (outerHeight / 2) - (tip_outerHeight / 2)), 'auto', 'auto', (o_left + target.outerWidth() + nubHeight)).removeClass('tip-override');
                    nub.removeClass('rtl');
                }
            }

            tip.css('visibility', 'visible').hide();
        },

        small: function() {
            return matchMedia(Foundation.media_queries.small).matches && !matchMedia(Foundation.media_queries.medium).matches;
        },

        inheritable_classes: function($target) {
            var settings = $.extend({}, this.settings, this.data_options($target))
              , inheritables = ['tip-top', 'tip-left', 'tip-bottom', 'tip-right', 'radius', 'round'].concat(settings.additional_inheritable_classes)
              , classes = $target.attr('class')
              , filtered = classes ? $.map(classes.split(' '), function(el, i) {
                if ($.inArray(el, inheritables) !== -1) {
                    return el;
                }
            }).join(' ') : '';

            return $.trim(filtered);
        },

        convert_to_touch: function($target) {
            var self = this
              , $tip = self.getTip($target)
              , settings = $.extend({}, self.settings, self.data_options($target));

            if ($tip.find('.tap-to-close').length === 0) {
                $tip.append('<span class="tap-to-close">' + settings.touch_close_text + '</span>');
                $tip.on('click.fndtn.tooltip.tapclose touchstart.fndtn.tooltip.tapclose MSPointerDown.fndtn.tooltip.tapclose', function(e) {
                    self.hide($target);
                });
            }

            $target.data('tooltip-open-event-type', 'touch');
        },

        show: function($target) {
            var $tip = this.getTip($target);
            if ($target.data('tooltip-open-event-type') == 'touch') {
                this.convert_to_touch($target);
            }

            this.reposition($target, $tip, $target.attr('class'));
            $target.addClass('open');
            $tip.fadeIn(this.settings.fade_in_duration);
        },

        hide: function($target) {
            var $tip = this.getTip($target);

            $tip.fadeOut(this.settings.fade_out_duration, function() {
                $tip.find('.tap-to-close').remove();
                $tip.off('click.fndtn.tooltip.tapclose MSPointerDown.fndtn.tapclose');
                $target.removeClass('open');
            });
        },

        off: function() {
            var self = this;
            this.S(this.scope).off('.fndtn.tooltip');
            this.S(this.settings.tooltip_class).each(function(i) {
                $('[' + self.attr_name() + ']').eq(i).attr('title', $(this).text());
            }).remove();
        },

        reflow: function() {}
    };
}(jQuery, window, window.document));

;(function($, window, document, undefined) {
    'use strict';

    Foundation.libs.topbar = {
        name: 'topbar',

        version: '5.5.3',

        settings: {
            index: 0,
            start_offset: 0,
            sticky_class: 'sticky',
            custom_back_text: true,
            back_text: 'Back',
            mobile_show_parent_link: true,
            is_hover: true,
            scrolltop: true,
            // jump to top when sticky nav menu toggle is clicked
            sticky_on: 'all',
            dropdown_autoclose: true
        },

        init: function(section, method, options) {
            Foundation.inherit(this, 'add_custom_rule register_media throttle');
            var self = this;

            self.register_media('topbar', 'foundation-mq-topbar');

            this.bindings(method, options);

            self.S('[' + this.attr_name() + ']', this.scope).each(function() {
                var topbar = $(this)
                  , settings = topbar.data(self.attr_name(true) + '-init')
                  , section = self.S('section, .top-bar-section', this);
                topbar.data('index', 0);
                var topbarContainer = topbar.parent();
                if (topbarContainer.hasClass('fixed') || self.is_sticky(topbar, topbarContainer, settings)) {
                    self.settings.sticky_class = settings.sticky_class;
                    self.settings.sticky_topbar = topbar;
                    topbar.data('height', topbarContainer.outerHeight());
                    topbar.data('stickyoffset', topbarContainer.offset().top);
                } else {
                    topbar.data('height', topbar.outerHeight());
                }

                if (!settings.assembled) {
                    self.assemble(topbar);
                }

                if (settings.is_hover) {
                    self.S('.has-dropdown', topbar).addClass('not-click');
                } else {
                    self.S('.has-dropdown', topbar).removeClass('not-click');
                }

                // Pad body when sticky (scrolled) or fixed.
                self.add_custom_rule('.f-topbar-fixed { padding-top: ' + topbar.data('height') + 'px }');

                if (topbarContainer.hasClass('fixed')) {
                    self.S('body').addClass('f-topbar-fixed');
                }
            });

        },

        is_sticky: function(topbar, topbarContainer, settings) {
            var sticky = topbarContainer.hasClass(settings.sticky_class);
            var smallMatch = matchMedia(Foundation.media_queries.small).matches;
            var medMatch = matchMedia(Foundation.media_queries.medium).matches;
            var lrgMatch = matchMedia(Foundation.media_queries.large).matches;

            if (sticky && settings.sticky_on === 'all') {
                return true;
            }
            if (sticky && this.small() && settings.sticky_on.indexOf('small') !== -1) {
                if (smallMatch && !medMatch && !lrgMatch) {
                    return true;
                }
            }
            if (sticky && this.medium() && settings.sticky_on.indexOf('medium') !== -1) {
                if (smallMatch && medMatch && !lrgMatch) {
                    return true;
                }
            }
            if (sticky && this.large() && settings.sticky_on.indexOf('large') !== -1) {
                if (smallMatch && medMatch && lrgMatch) {
                    return true;
                }
            }

            return false;
        },

        toggle: function(toggleEl) {
            var self = this, topbar;

            if (toggleEl) {
                topbar = self.S(toggleEl).closest('[' + this.attr_name() + ']');
            } else {
                topbar = self.S('[' + this.attr_name() + ']');
            }

            var settings = topbar.data(this.attr_name(true) + '-init');

            var section = self.S('section, .top-bar-section', topbar);

            if (self.breakpoint()) {
                if (!self.rtl) {
                    section.css({
                        left: '0%'
                    });
                    $('>.name', section).css({
                        left: '100%'
                    });
                } else {
                    section.css({
                        right: '0%'
                    });
                    $('>.name', section).css({
                        right: '100%'
                    });
                }

                self.S('li.moved', section).removeClass('moved');
                topbar.data('index', 0);

                topbar.toggleClass('expanded').css('height', '');
            }

            if (settings.scrolltop) {
                if (!topbar.hasClass('expanded')) {
                    if (topbar.hasClass('fixed')) {
                        topbar.parent().addClass('fixed');
                        topbar.removeClass('fixed');
                        self.S('body').addClass('f-topbar-fixed');
                    }
                } else if (topbar.parent().hasClass('fixed')) {
                    if (settings.scrolltop) {
                        topbar.parent().removeClass('fixed');
                        topbar.addClass('fixed');
                        self.S('body').removeClass('f-topbar-fixed');

                        window.scrollTo(0, 0);
                    } else {
                        topbar.parent().removeClass('expanded');
                    }
                }
            } else {
                if (self.is_sticky(topbar, topbar.parent(), settings)) {
                    topbar.parent().addClass('fixed');
                }

                if (topbar.parent().hasClass('fixed')) {
                    if (!topbar.hasClass('expanded')) {
                        topbar.removeClass('fixed');
                        topbar.parent().removeClass('expanded');
                        self.update_sticky_positioning();
                    } else {
                        topbar.addClass('fixed');
                        topbar.parent().addClass('expanded');
                        self.S('body').addClass('f-topbar-fixed');
                    }
                }
            }
        },

        timer: null,

        events: function(bar) {
            var self = this
              , S = this.S;

            S(this.scope).off('.topbar').on('click.fndtn.topbar', '[' + this.attr_name() + '] .toggle-topbar', function(e) {
                e.preventDefault();
                self.toggle(this);
            }).on('click.fndtn.topbar contextmenu.fndtn.topbar', '.top-bar .top-bar-section li a[href^="#"],[' + this.attr_name() + '] .top-bar-section li a[href^="#"]', function(e) {
                var li = $(this).closest('li')
                  , topbar = li.closest('[' + self.attr_name() + ']')
                  , settings = topbar.data(self.attr_name(true) + '-init');

                if (settings.dropdown_autoclose && settings.is_hover) {
                    var hoverLi = $(this).closest('.hover');
                    hoverLi.removeClass('hover');
                }
                if (self.breakpoint() && !li.hasClass('back') && !li.hasClass('has-dropdown')) {
                    self.toggle();
                }

            }).on('click.fndtn.topbar', '[' + this.attr_name() + '] li.has-dropdown', function(e) {
                var li = S(this)
                  , target = S(e.target)
                  , topbar = li.closest('[' + self.attr_name() + ']')
                  , settings = topbar.data(self.attr_name(true) + '-init');

                if (target.data('revealId')) {
                    self.toggle();
                    return;
                }

                if (self.breakpoint()) {
                    return;
                }

                if (settings.is_hover && !Modernizr.touch) {
                    return;
                }

                e.stopImmediatePropagation();

                if (li.hasClass('hover')) {
                    li.removeClass('hover').find('li').removeClass('hover');

                    li.parents('li.hover').removeClass('hover');
                } else {
                    li.addClass('hover');

                    $(li).siblings().removeClass('hover');

                    if (target[0].nodeName === 'A' && target.parent().hasClass('has-dropdown')) {
                        e.preventDefault();
                    }
                }
            }).on('click.fndtn.topbar', '[' + this.attr_name() + '] .has-dropdown>a', function(e) {
                if (self.breakpoint()) {

                    e.preventDefault();

                    var $this = S(this)
                      , topbar = $this.closest('[' + self.attr_name() + ']')
                      , section = topbar.find('section, .top-bar-section')
                      , dropdownHeight = $this.next('.dropdown').outerHeight()
                      , $selectedLi = $this.closest('li');

                    topbar.data('index', topbar.data('index') + 1);
                    $selectedLi.addClass('moved');

                    if (!self.rtl) {
                        section.css({
                            left: -(100 * topbar.data('index')) + '%'
                        });
                        section.find('>.name').css({
                            left: 100 * topbar.data('index') + '%'
                        });
                    } else {
                        section.css({
                            right: -(100 * topbar.data('index')) + '%'
                        });
                        section.find('>.name').css({
                            right: 100 * topbar.data('index') + '%'
                        });
                    }

                    topbar.css('height', $this.siblings('ul').outerHeight(true) + topbar.data('height'));
                }
            });

            S(window).off('.topbar').on('resize.fndtn.topbar', self.throttle(function() {
                self.resize.call(self);
            }, 50)).trigger('resize.fndtn.topbar').load(function() {
                // Ensure that the offset is calculated after all of the pages resources have loaded
                S(this).trigger('resize.fndtn.topbar');
            });

            S('body').off('.topbar').on('click.fndtn.topbar', function(e) {
                var parent = S(e.target).closest('li').closest('li.hover');

                if (parent.length > 0) {
                    return;
                }

                S('[' + self.attr_name() + '] li.hover').removeClass('hover');
            });

            // Go up a level on Click
            S(this.scope).on('click.fndtn.topbar', '[' + this.attr_name() + '] .has-dropdown .back', function(e) {
                e.preventDefault();

                var $this = S(this)
                  , topbar = $this.closest('[' + self.attr_name() + ']')
                  , section = topbar.find('section, .top-bar-section')
                  , settings = topbar.data(self.attr_name(true) + '-init')
                  , $movedLi = $this.closest('li.moved')
                  , $previousLevelUl = $movedLi.parent();

                topbar.data('index', topbar.data('index') - 1);

                if (!self.rtl) {
                    section.css({
                        left: -(100 * topbar.data('index')) + '%'
                    });
                    section.find('>.name').css({
                        left: 100 * topbar.data('index') + '%'
                    });
                } else {
                    section.css({
                        right: -(100 * topbar.data('index')) + '%'
                    });
                    section.find('>.name').css({
                        right: 100 * topbar.data('index') + '%'
                    });
                }

                if (topbar.data('index') === 0) {
                    topbar.css('height', '');
                } else {
                    topbar.css('height', $previousLevelUl.outerHeight(true) + topbar.data('height'));
                }

                setTimeout(function() {
                    $movedLi.removeClass('moved');
                }, 300);
            });

            // Show dropdown menus when their items are focused
            S(this.scope).find('.dropdown a').focus(function() {
                $(this).parents('.has-dropdown').addClass('hover');
            }).blur(function() {
                $(this).parents('.has-dropdown').removeClass('hover');
            });
        },

        resize: function() {
            var self = this;
            self.S('[' + this.attr_name() + ']').each(function() {
                var topbar = self.S(this)
                  , settings = topbar.data(self.attr_name(true) + '-init');

                var stickyContainer = topbar.parent('.' + self.settings.sticky_class);
                var stickyOffset;

                if (!self.breakpoint()) {
                    var doToggle = topbar.hasClass('expanded');
                    topbar.css('height', '').removeClass('expanded').find('li').removeClass('hover');

                    if (doToggle) {
                        self.toggle(topbar);
                    }
                }

                if (self.is_sticky(topbar, stickyContainer, settings)) {
                    if (stickyContainer.hasClass('fixed')) {
                        // Remove the fixed to allow for correct calculation of the offset.
                        stickyContainer.removeClass('fixed');

                        stickyOffset = stickyContainer.offset().top;
                        if (self.S(document.body).hasClass('f-topbar-fixed')) {
                            stickyOffset -= topbar.data('height');
                        }

                        topbar.data('stickyoffset', stickyOffset);
                        stickyContainer.addClass('fixed');
                    } else {
                        stickyOffset = stickyContainer.offset().top;
                        topbar.data('stickyoffset', stickyOffset);
                    }
                }

            });
        },

        breakpoint: function() {
            return !matchMedia(Foundation.media_queries['topbar']).matches;
        },

        small: function() {
            return matchMedia(Foundation.media_queries['small']).matches;
        },

        medium: function() {
            return matchMedia(Foundation.media_queries['medium']).matches;
        },

        large: function() {
            return matchMedia(Foundation.media_queries['large']).matches;
        },

        assemble: function(topbar) {
            var self = this
              , settings = topbar.data(this.attr_name(true) + '-init')
              , section = self.S('section, .top-bar-section', topbar);

            // Pull element out of the DOM for manipulation
            section.detach();

            self.S('.has-dropdown>a', section).each(function() {
                var $link = self.S(this), $dropdown = $link.siblings('.dropdown'), url = $link.attr('href'), $titleLi;

                if (!$dropdown.find('.title.back').length) {

                    if (settings.mobile_show_parent_link == true && url) {
                        $titleLi = $('<li class="title back js-generated"><h5><a href="javascript:void(0)"></a></h5></li><li class="parent-link hide-for-medium-up"><a class="parent-link js-generated" href="' + url + '">' + $link.html() + '</a></li>');
                    } else {
                        $titleLi = $('<li class="title back js-generated"><h5><a href="javascript:void(0)"></a></h5>');
                    }

                    // Copy link to subnav
                    if (settings.custom_back_text == true) {
                        $('h5>a', $titleLi).html(settings.back_text);
                    } else {
                        $('h5>a', $titleLi).html('&laquo; ' + $link.html());
                    }
                    $dropdown.prepend($titleLi);
                }
            });

            // Put element back in the DOM
            section.appendTo(topbar);

            // check for sticky
            this.sticky();

            this.assembled(topbar);
        },

        assembled: function(topbar) {
            topbar.data(this.attr_name(true), $.extend({}, topbar.data(this.attr_name(true)), {
                assembled: true
            }));
        },

        height: function(ul) {
            var total = 0
              , self = this;

            $('> li', ul).each(function() {
                total += self.S(this).outerHeight(true);
            });

            return total;
        },

        sticky: function() {
            var self = this;

            this.S(window).on('scroll', function() {
                self.update_sticky_positioning();
            });
        },

        update_sticky_positioning: function() {
            var klass = '.' + this.settings.sticky_class
              , $window = this.S(window)
              , self = this;

            if (self.settings.sticky_topbar && self.is_sticky(this.settings.sticky_topbar, this.settings.sticky_topbar.parent(), this.settings)) {
                var distance = this.settings.sticky_topbar.data('stickyoffset') + this.settings.start_offset;
                if (!self.S(klass).hasClass('expanded')) {
                    if ($window.scrollTop() > (distance)) {
                        if (!self.S(klass).hasClass('fixed')) {
                            self.S(klass).addClass('fixed');
                            self.S('body').addClass('f-topbar-fixed');
                        }
                    } else if ($window.scrollTop() <= distance) {
                        if (self.S(klass).hasClass('fixed')) {
                            self.S(klass).removeClass('fixed');
                            self.S('body').removeClass('f-topbar-fixed');
                        }
                    }
                }
            }
        },

        off: function() {
            this.S(this.scope).off('.fndtn.topbar');
            this.S(window).off('.fndtn.topbar');
        },

        reflow: function() {}
    };
}(jQuery, window, window.document));

/*!
 * Modernizr v2.8.3
 * www.modernizr.com
 *
 * Copyright (c) Faruk Ates, Paul Irish, Alex Sexton
 * Available under the BSD and MIT licenses: www.modernizr.com/license/
 */

/*
 * Modernizr tests which native CSS3 and HTML5 features are available in
 * the current UA and makes the results available to you in two ways:
 * as properties on a global Modernizr object, and as classes on the
 * <html> element. This information allows you to progressively enhance
 * your pages with a granular level of control over the experience.
 *
 * Modernizr has an optional (not included) conditional resource loader
 * called Modernizr.load(), based on Yepnope.js (yepnopejs.com).
 * To get a build that includes Modernizr.load(), as well as choosing
 * which tests to include, go to www.modernizr.com/download/
 *
 * Authors        Faruk Ates, Paul Irish, Alex Sexton
 * Contributors   Ryan Seddon, Ben Alman
 */

window.Modernizr = (function(window, document, undefined) {

    var version = '2.8.3',
    Modernizr = {},
    /*>>cssclasses*/
    // option for enabling the HTML classes to be added
    enableClasses = true, /*>>cssclasses*/

    docElement = document.documentElement,
    /**
     * Create our "modernizr" element that we do most feature tests on.
     */
    mod = 'modernizr', modElem = document.createElement(mod), mStyle = modElem.style,
    /**
     * Create the input element for various Web Forms feature tests.
     */
    inputElem /*>>inputelem*/
    = document.createElement('input')/*>>inputelem*/
    ,
    /*>>smile*/
    smile = ':)', /*>>smile*/

    toString = {}.toString,
    // TODO :: make the prefixes more granular
    /*>>prefixes*/
    // List of property values to set for css tests. See ticket #21
    prefixes = ' -webkit- -moz- -o- -ms- '.split(' '), /*>>prefixes*/

    /*>>domprefixes*/
    // Following spec is to expose vendor-specific style properties as:
    //   elem.style.WebkitBorderRadius
    // and the following would be incorrect:
    //   elem.style.webkitBorderRadius

    // Webkit ghosts their properties in lowercase but Opera & Moz do not.
    // Microsoft uses a lowercase `ms` instead of the correct `Ms` in IE8+
    //   erik.eae.net/archives/2008/03/10/21.48.10/

    // More here: github.com/Modernizr/Modernizr/issues/issue/21
    omPrefixes = 'Webkit Moz O ms',
    cssomPrefixes = omPrefixes.split(' '),
    domPrefixes = omPrefixes.toLowerCase().split(' '), /*>>domprefixes*/

    /*>>ns*/
    ns = {
        'svg': 'http://www.w3.org/2000/svg'
    }, /*>>ns*/

    tests = {}, inputs = {}, attrs = {},
    classes = [],
    slice = classes.slice,
    featureName, // used in testing loop

    /*>>teststyles*/
    // Inject element with style element and some CSS rules
    injectElementWithStyles = function(rule, callback, nodes, testnames) {

        var style, ret, node, docOverflow, div = document.createElement('div'), // After page load injecting a fake body doesn't work so check if body exists
        body = document.body, // IE6 and 7 won't return offsetWidth or offsetHeight unless it's in the body element, so we fake it.
        fakeBody = body || document.createElement('body');

        if (parseInt(nodes, 10)) {
            // In order not to give false positives we create a node for each test
            // This also allows the method to scale for unspecified uses
            while (nodes--) {
                node = document.createElement('div');
                node.id = testnames ? testnames[nodes] : mod + (nodes + 1);
                div.appendChild(node);
            }
        }

        // <style> elements in IE6-9 are considered 'NoScope' elements and therefore will be removed
        // when injected with innerHTML. To get around this you need to prepend the 'NoScope' element
        // with a 'scoped' element, in our case the soft-hyphen entity as it won't mess with our measurements.
        // msdn.microsoft.com/en-us/library/ms533897%28VS.85%29.aspx
        // Documents served as xml will throw if using &shy; so use xml friendly encoded version. See issue #277
        style = ['&#173;', '<style id="s', mod, '">', rule, '</style>'].join('');
        div.id = mod;
        // IE6 will false positive on some tests due to the style element inside the test div somehow interfering offsetHeight, so insert it into body or fakebody.
        // Opera will act all quirky when injecting elements in documentElement when page is served as xml, needs fakebody too. #270
        (body ? div : fakeBody).innerHTML += style;
        fakeBody.appendChild(div);
        if (!body) {
            //avoid crashing IE8, if background image is used
            fakeBody.style.background = '';
            //Safari 5.13/5.1.4 OSX stops loading if ::-webkit-scrollbar is used and scrollbars are visible
            fakeBody.style.overflow = 'hidden';
            docOverflow = docElement.style.overflow;
            docElement.style.overflow = 'hidden';
            docElement.appendChild(fakeBody);
        }

        ret = callback(div, rule);
        // If this is done after page load we don't want to remove the body so check if body exists
        if (!body) {
            fakeBody.parentNode.removeChild(fakeBody);
            docElement.style.overflow = docOverflow;
        } else {
            div.parentNode.removeChild(div);
        }

        return !!ret;

    }, /*>>teststyles*/

    /*>>mq*/
    // adapted from matchMedia polyfill
    // by Scott Jehl and Paul Irish
    // gist.github.com/786768
    testMediaQuery = function(mq) {

        var matchMedia = window.matchMedia || window.msMatchMedia;
        if (matchMedia) {
            return matchMedia(mq) && matchMedia(mq).matches || false;
        }

        var bool;

        injectElementWithStyles('@media ' + mq + ' { #' + mod + ' { position: absolute; } }', function(node) {
            bool = (window.getComputedStyle ? getComputedStyle(node, null) : node.currentStyle)['position'] == 'absolute';
        });

        return bool;

    }, /*>>mq*/

    /*>>hasevent*/
    //
    // isEventSupported determines if a given element supports the given event
    // kangax.github.com/iseventsupported/
    //
    // The following results are known incorrects:
    //   Modernizr.hasEvent("webkitTransitionEnd", elem) // false negative
    //   Modernizr.hasEvent("textInput") // in Webkit. github.com/Modernizr/Modernizr/issues/333
    //   ...
    isEventSupported = (function() {

        var TAGNAMES = {
            'select': 'input',
            'change': 'input',
            'submit': 'form',
            'reset': 'form',
            'error': 'img',
            'load': 'img',
            'abort': 'img'
        };

        function isEventSupported(eventName, element) {

            element = element || document.createElement(TAGNAMES[eventName] || 'div');
            eventName = 'on' + eventName;

            // When using `setAttribute`, IE skips "unload", WebKit skips "unload" and "resize", whereas `in` "catches" those
            var isSupported = eventName in element;

            if (!isSupported) {
                // If it has no `setAttribute` (i.e. doesn't implement Node interface), try generic element
                if (!element.setAttribute) {
                    element = document.createElement('div');
                }
                if (element.setAttribute && element.removeAttribute) {
                    element.setAttribute(eventName, '');
                    isSupported = is(element[eventName], 'function');

                    // If property was created, "remove it" (by setting value to `undefined`)
                    if (!is(element[eventName], 'undefined')) {
                        element[eventName] = undefined;
                    }
                    element.removeAttribute(eventName);
                }
            }

            element = null;
            return isSupported;
        }
        return isEventSupported;
    }
    )(), /*>>hasevent*/

    // TODO :: Add flag for hasownprop ? didn't last time

    // hasOwnProperty shim by kangax needed for Safari 2.0 support
    _hasOwnProperty = ({}).hasOwnProperty, hasOwnProp;

    if (!is(_hasOwnProperty, 'undefined') && !is(_hasOwnProperty.call, 'undefined')) {
        hasOwnProp = function(object, property) {
            return _hasOwnProperty.call(object, property);
        }
        ;
    } else {
        hasOwnProp = function(object, property) {
            /* yes, this can give false positives/negatives, but most of the time we don't care about those */
            return ((property in object) && is(object.constructor.prototype[property], 'undefined'));
        }
        ;
    }

    // Adapted from ES5-shim https://github.com/kriskowal/es5-shim/blob/master/es5-shim.js
    // es5.github.com/#x15.3.4.5

    if (!Function.prototype.bind) {
        Function.prototype.bind = function bind(that) {

            var target = this;

            if (typeof target != "function") {
                throw new TypeError();
            }

            var args = slice.call(arguments, 1)
              , bound = function() {

                if (this instanceof bound) {

                    var F = function() {};
                    F.prototype = target.prototype;
                    var self = new F();

                    var result = target.apply(self, args.concat(slice.call(arguments)));
                    if (Object(result) === result) {
                        return result;
                    }
                    return self;

                } else {

                    return target.apply(that, args.concat(slice.call(arguments)));

                }

            };

            return bound;
        }
        ;
    }

    /**
     * setCss applies given styles to the Modernizr DOM node.
     */
    function setCss(str) {
        mStyle.cssText = str;
    }

    /**
     * setCssAll extrapolates all vendor-specific css strings.
     */
    function setCssAll(str1, str2) {
        return setCss(prefixes.join(str1 + ';') + (str2 || ''));
    }

    /**
     * is returns a boolean for if typeof obj is exactly type.
     */
    function is(obj, type) {
        return typeof obj === type;
    }

    /**
     * contains returns a boolean for if substr is found within str.
     */
    function contains(str, substr) {
        return !!~('' + str).indexOf(substr);
    }

    /*>>testprop*/

    // testProps is a generic CSS / DOM property test.

    // In testing support for a given CSS property, it's legit to test:
    //    `elem.style[styleName] !== undefined`
    // If the property is supported it will return an empty string,
    // if unsupported it will return undefined.

    // We'll take advantage of this quick test and skip setting a style
    // on our modernizr element, but instead just testing undefined vs
    // empty string.

    // Because the testing of the CSS property names (with "-", as
    // opposed to the camelCase DOM properties) is non-portable and
    // non-standard but works in WebKit and IE (but not Gecko or Opera),
    // we explicitly reject properties with dashes so that authors
    // developing in WebKit or IE first don't end up with
    // browser-specific content by accident.

    function testProps(props, prefixed) {
        for (var i in props) {
            var prop = props[i];
            if (!contains(prop, "-") && mStyle[prop] !== undefined) {
                return prefixed == 'pfx' ? prop : true;
            }
        }
        return false;
    }
    /*>>testprop*/

    // TODO :: add testDOMProps
    /**
     * testDOMProps is a generic DOM property test; if a browser supports
     *   a certain property, it won't return undefined for it.
     */
    function testDOMProps(props, obj, elem) {
        for (var i in props) {
            var item = obj[props[i]];
            if (item !== undefined) {

                // return the property name as a string
                if (elem === false)
                    return props[i];

                // let's bind a function
                if (is(item, 'function')) {
                    // default to autobind unless override
                    return item.bind(elem || obj);
                }

                // return the unbound function or obj or value
                return item;
            }
        }
        return false;
    }

    /*>>testallprops*/
    /**
     * testPropsAll tests a list of DOM properties we want to check against.
     *   We specify literally ALL possible (known and/or likely) properties on
     *   the element including the non-vendor prefixed one, for forward-
     *   compatibility.
     */
    function testPropsAll(prop, prefixed, elem) {

        var ucProp = prop.charAt(0).toUpperCase() + prop.slice(1)
          , props = (prop + ' ' + cssomPrefixes.join(ucProp + ' ') + ucProp).split(' ');

        // did they call .prefixed('boxSizing') or are we just testing a prop?
        if (is(prefixed, "string") || is(prefixed, "undefined")) {
            return testProps(props, prefixed);

            // otherwise, they called .prefixed('requestAnimationFrame', window[, elem])
        } else {
            props = (prop + ' ' + (domPrefixes).join(ucProp + ' ') + ucProp).split(' ');
            return testDOMProps(props, prefixed, elem);
        }
    }
    /*>>testallprops*/

    /**
     * Tests
     * -----
     */

    // The *new* flexbox
    // dev.w3.org/csswg/css3-flexbox

    tests['flexbox'] = function() {
        return testPropsAll('flexWrap');
    }
    ;

    // The *old* flexbox
    // www.w3.org/TR/2009/WD-css3-flexbox-20090723/

    tests['flexboxlegacy'] = function() {
        return testPropsAll('boxDirection');
    }
    ;

    // On the S60 and BB Storm, getContext exists, but always returns undefined
    // so we actually have to call getContext() to verify
    // github.com/Modernizr/Modernizr/issues/issue/97/

    tests['canvas'] = function() {
        var elem = document.createElement('canvas');
        return !!(elem.getContext && elem.getContext('2d'));
    }
    ;

    tests['canvastext'] = function() {
        return !!(Modernizr['canvas'] && is(document.createElement('canvas').getContext('2d').fillText, 'function'));
    }
    ;

    // webk.it/70117 is tracking a legit WebGL feature detect proposal

    // We do a soft detect which may false positive in order to avoid
    // an expensive context creation: bugzil.la/732441

    tests['webgl'] = function() {
        return !!window.WebGLRenderingContext;
    }
    ;

    /*
     * The Modernizr.touch test only indicates if the browser supports
     *    touch events, which does not necessarily reflect a touchscreen
     *    device, as evidenced by tablets running Windows 7 or, alas,
     *    the Palm Pre / WebOS (touch) phones.
     *
     * Additionally, Chrome (desktop) used to lie about its support on this,
     *    but that has since been rectified: crbug.com/36415
     *
     * We also test for Firefox 4 Multitouch Support.
     *
     * For more info, see: modernizr.github.com/Modernizr/touch.html
     */

    tests['touch'] = function() {
        var bool;

        if (('ontouchstart'in window) || window.DocumentTouch && document instanceof DocumentTouch) {
            bool = true;
        } else {
            injectElementWithStyles(['@media (', prefixes.join('touch-enabled),('), mod, ')', '{#modernizr{top:9px;position:absolute}}'].join(''), function(node) {
                bool = node.offsetTop === 9;
            });
        }

        return bool;
    }
    ;

    // geolocation is often considered a trivial feature detect...
    // Turns out, it's quite tricky to get right:
    //
    // Using !!navigator.geolocation does two things we don't want. It:
    //   1. Leaks memory in IE9: github.com/Modernizr/Modernizr/issues/513
    //   2. Disables page caching in WebKit: webk.it/43956
    //
    // Meanwhile, in Firefox < 8, an about:config setting could expose
    // a false positive that would throw an exception: bugzil.la/688158

    tests['geolocation'] = function() {
        return 'geolocation'in navigator;
    }
    ;

    tests['postmessage'] = function() {
        return !!window.postMessage;
    }
    ;

    // Chrome incognito mode used to throw an exception when using openDatabase
    // It doesn't anymore.
    tests['websqldatabase'] = function() {
        return !!window.openDatabase;
    }
    ;

    // Vendors had inconsistent prefixing with the experimental Indexed DB:
    // - Webkit's implementation is accessible through webkitIndexedDB
    // - Firefox shipped moz_indexedDB before FF4b9, but since then has been mozIndexedDB
    // For speed, we don't test the legacy (and beta-only) indexedDB
    tests['indexedDB'] = function() {
        return !!testPropsAll("indexedDB", window);
    }
    ;

    // documentMode logic from YUI to filter out IE8 Compat Mode
    //   which false positives.
    tests['hashchange'] = function() {
        return isEventSupported('hashchange', window) && (document.documentMode === undefined || document.documentMode > 7);
    }
    ;

    // Per 1.6:
    // This used to be Modernizr.historymanagement but the longer
    // name has been deprecated in favor of a shorter and property-matching one.
    // The old API is still available in 1.6, but as of 2.0 will throw a warning,
    // and in the first release thereafter disappear entirely.
    tests['history'] = function() {
        return !!(window.history && history.pushState);
    }
    ;

    tests['draganddrop'] = function() {
        var div = document.createElement('div');
        return ('draggable'in div) || ('ondragstart'in div && 'ondrop'in div);
    }
    ;

    // FF3.6 was EOL'ed on 4/24/12, but the ESR version of FF10
    // will be supported until FF19 (2/12/13), at which time, ESR becomes FF17.
    // FF10 still uses prefixes, so check for it until then.
    // for more ESR info, see: mozilla.org/en-US/firefox/organizations/faq/
    tests['websockets'] = function() {
        return 'WebSocket'in window || 'MozWebSocket'in window;
    }
    ;

    // css-tricks.com/rgba-browser-support/
    tests['rgba'] = function() {
        // Set an rgba() color and check the returned value

        setCss('background-color:rgba(150,255,150,.5)');

        return contains(mStyle.backgroundColor, 'rgba');
    }
    ;

    tests['hsla'] = function() {
        // Same as rgba(), in fact, browsers re-map hsla() to rgba() internally,
        //   except IE9 who retains it as hsla

        setCss('background-color:hsla(120,40%,100%,.5)');

        return contains(mStyle.backgroundColor, 'rgba') || contains(mStyle.backgroundColor, 'hsla');
    }
    ;

    tests['multiplebgs'] = function() {
        // Setting multiple images AND a color on the background shorthand property
        //  and then querying the style.background property value for the number of
        //  occurrences of "url(" is a reliable method for detecting ACTUAL support for this!

        setCss('background:url(https://),url(https://),red url(https://)');

        // If the UA supports multiple backgrounds, there should be three occurrences
        //   of the string "url(" in the return value for elemStyle.background

        return (/(url\s*\(.*?){3}/).test(mStyle.background);
    }
    ;

    // this will false positive in Opera Mini
    //   github.com/Modernizr/Modernizr/issues/396

    tests['backgroundsize'] = function() {
        return testPropsAll('backgroundSize');
    }
    ;

    tests['borderimage'] = function() {
        return testPropsAll('borderImage');
    }
    ;

    // Super comprehensive table about all the unique implementations of
    // border-radius: muddledramblings.com/table-of-css3-border-radius-compliance

    tests['borderradius'] = function() {
        return testPropsAll('borderRadius');
    }
    ;

    // WebOS unfortunately false positives on this test.
    tests['boxshadow'] = function() {
        return testPropsAll('boxShadow');
    }
    ;

    // FF3.0 will false positive on this test
    tests['textshadow'] = function() {
        return document.createElement('div').style.textShadow === '';
    }
    ;

    tests['opacity'] = function() {
        // Browsers that actually have CSS Opacity implemented have done so
        //  according to spec, which means their return values are within the
        //  range of [0.0,1.0] - including the leading zero.

        setCssAll('opacity:.55');

        // The non-literal . in this regex is intentional:
        //   German Chrome returns this value as 0,55
        // github.com/Modernizr/Modernizr/issues/#issue/59/comment/516632
        return (/^0.55$/).test(mStyle.opacity);
    }
    ;

    // Note, Android < 4 will pass this test, but can only animate
    //   a single property at a time
    //   goo.gl/v3V4Gp
    tests['cssanimations'] = function() {
        return testPropsAll('animationName');
    }
    ;

    tests['csscolumns'] = function() {
        return testPropsAll('columnCount');
    }
    ;

    tests['cssgradients'] = function() {
        /**
         * For CSS Gradients syntax, please see:
         * webkit.org/blog/175/introducing-css-gradients/
         * developer.mozilla.org/en/CSS/-moz-linear-gradient
         * developer.mozilla.org/en/CSS/-moz-radial-gradient
         * dev.w3.org/csswg/css3-images/#gradients-
         */

        var str1 = 'background-image:'
          , str2 = 'gradient(linear,left top,right bottom,from(#9f9),to(white));'
          , str3 = 'linear-gradient(left top,#9f9, white);';

        setCss(// legacy webkit syntax (FIXME: remove when syntax not in use anymore)
        (str1 + '-webkit- '.split(' ').join(str2 + str1) + // standard syntax             // trailing 'background-image:'
        prefixes.join(str3 + str1)).slice(0, -str1.length));

        return contains(mStyle.backgroundImage, 'gradient');
    }
    ;

    tests['cssreflections'] = function() {
        return testPropsAll('boxReflect');
    }
    ;

    tests['csstransforms'] = function() {
        return !!testPropsAll('transform');
    }
    ;

    tests['csstransforms3d'] = function() {

        var ret = !!testPropsAll('perspective');

        // Webkit's 3D transforms are passed off to the browser's own graphics renderer.
        //   It works fine in Safari on Leopard and Snow Leopard, but not in Chrome in
        //   some conditions. As a result, Webkit typically recognizes the syntax but
        //   will sometimes throw a false positive, thus we must do a more thorough check:
        if (ret && 'webkitPerspective'in docElement.style) {

            // Webkit allows this media query to succeed only if the feature is enabled.
            // `@media (transform-3d),(-webkit-transform-3d){ ... }`
            injectElementWithStyles('@media (transform-3d),(-webkit-transform-3d){#modernizr{left:9px;position:absolute;height:3px;}}', function(node, rule) {
                ret = node.offsetLeft === 9 && node.offsetHeight === 3;
            });
        }
        return ret;
    }
    ;

    tests['csstransitions'] = function() {
        return testPropsAll('transition');
    }
    ;

    /*>>fontface*/
    // @font-face detection routine by Diego Perini
    // javascript.nwbox.com/CSSSupport/

    // false positives:
    //   WebOS github.com/Modernizr/Modernizr/issues/342
    //   WP7   github.com/Modernizr/Modernizr/issues/538
    tests['fontface'] = function() {
        var bool;

        injectElementWithStyles('@font-face {font-family:"font";src:url("https://")}', function(node, rule) {
            var style = document.getElementById('smodernizr')
              , sheet = style.sheet || style.styleSheet
              , cssText = sheet ? (sheet.cssRules && sheet.cssRules[0] ? sheet.cssRules[0].cssText : sheet.cssText || '') : '';

            bool = /src/i.test(cssText) && cssText.indexOf(rule.split(' ')[0]) === 0;
        });

        return bool;
    }
    ;
    /*>>fontface*/

    // CSS generated content detection
    tests['generatedcontent'] = function() {
        var bool;

        injectElementWithStyles(['#', mod, '{font:0/0 a}#', mod, ':after{content:"', smile, '";visibility:hidden;font:3px/1 a}'].join(''), function(node) {
            bool = node.offsetHeight >= 3;
        });

        return bool;
    }
    ;

    // These tests evaluate support of the video/audio elements, as well as
    // testing what types of content they support.
    //
    // We're using the Boolean constructor here, so that we can extend the value
    // e.g.  Modernizr.video     // true
    //       Modernizr.video.ogg // 'probably'
    //
    // Codec values from : github.com/NielsLeenheer/html5test/blob/9106a8/index.html#L845
    //                     thx to NielsLeenheer and zcorpan

    // Note: in some older browsers, "no" was a return value instead of empty string.
    //   It was live in FF3.5.0 and 3.5.1, but fixed in 3.5.2
    //   It was also live in Safari 4.0.0 - 4.0.4, but fixed in 4.0.5

    tests['video'] = function() {
        var elem = document.createElement('video')
          , bool = false;

        // IE9 Running on Windows Server SKU can cause an exception to be thrown, bug #224
        try {
            if (bool = !!elem.canPlayType) {
                bool = new Boolean(bool);
                bool.ogg = elem.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, '');

                // Without QuickTime, this value will be `undefined`. github.com/Modernizr/Modernizr/issues/546
                bool.h264 = elem.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, '');

                bool.webm = elem.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, '');
            }

        } catch (e) {}

        return bool;
    }
    ;

    tests['audio'] = function() {
        var elem = document.createElement('audio')
          , bool = false;

        try {
            if (bool = !!elem.canPlayType) {
                bool = new Boolean(bool);
                bool.ogg = elem.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '');
                bool.mp3 = elem.canPlayType('audio/mpeg;').replace(/^no$/, '');

                // Mimetypes accepted:
                //   developer.mozilla.org/En/Media_formats_supported_by_the_audio_and_video_elements
                //   bit.ly/iphoneoscodecs
                bool.wav = elem.canPlayType('audio/wav; codecs="1"').replace(/^no$/, '');
                bool.m4a = (elem.canPlayType('audio/x-m4a;') || elem.canPlayType('audio/aac;')).replace(/^no$/, '');
            }
        } catch (e) {}

        return bool;
    }
    ;

    // In FF4, if disabled, window.localStorage should === null.

    // Normally, we could not test that directly and need to do a
    //   `('localStorage' in window) && ` test first because otherwise Firefox will
    //   throw bugzil.la/365772 if cookies are disabled

    // Also in iOS5 Private Browsing mode, attempting to use localStorage.setItem
    // will throw the exception:
    //   QUOTA_EXCEEDED_ERRROR DOM Exception 22.
    // Peculiarly, getItem and removeItem calls do not throw.

    // Because we are forced to try/catch this, we'll go aggressive.

    // Just FWIW: IE8 Compat mode supports these features completely:
    //   www.quirksmode.org/dom/html5.html
    // But IE8 doesn't support either with local files

    tests['localstorage'] = function() {
        try {
            localStorage.setItem(mod, mod);
            localStorage.removeItem(mod);
            return true;
        } catch (e) {
            return false;
        }
    }
    ;

    tests['sessionstorage'] = function() {
        try {
            sessionStorage.setItem(mod, mod);
            sessionStorage.removeItem(mod);
            return true;
        } catch (e) {
            return false;
        }
    }
    ;

    tests['webworkers'] = function() {
        return !!window.Worker;
    }
    ;

    tests['applicationcache'] = function() {
        return !!window.applicationCache;
    }
    ;

    // Thanks to Erik Dahlstrom
    tests['svg'] = function() {
        return !!document.createElementNS && !!document.createElementNS(ns.svg, 'svg').createSVGRect;
    }
    ;

    // specifically for SVG inline in HTML, not within XHTML
    // test page: paulirish.com/demo/inline-svg
    tests['inlinesvg'] = function() {
        var div = document.createElement('div');
        div.innerHTML = '<svg/>';
        return (div.firstChild && div.firstChild.namespaceURI) == ns.svg;
    }
    ;

    // SVG SMIL animation
    tests['smil'] = function() {
        return !!document.createElementNS && /SVGAnimate/.test(toString.call(document.createElementNS(ns.svg, 'animate')));
    }
    ;

    // This test is only for clip paths in SVG proper, not clip paths on HTML content
    // demo: srufaculty.sru.edu/david.dailey/svg/newstuff/clipPath4.svg

    // However read the comments to dig into applying SVG clippaths to HTML content here:
    //   github.com/Modernizr/Modernizr/issues/213#issuecomment-1149491
    tests['svgclippaths'] = function() {
        return !!document.createElementNS && /SVGClipPath/.test(toString.call(document.createElementNS(ns.svg, 'clipPath')));
    }
    ;

    /*>>webforms*/
    // input features and input types go directly onto the ret object, bypassing the tests loop.
    // Hold this guy to execute in a moment.
    function webforms() {
        /*>>input*/
        // Run through HTML5's new input attributes to see if the UA understands any.
        // We're using f which is the <input> element created early on
        // Mike Taylr has created a comprehensive resource for testing these attributes
        //   when applied to all input types:
        //   miketaylr.com/code/input-type-attr.html
        // spec: www.whatwg.org/specs/web-apps/current-work/multipage/the-input-element.html#input-type-attr-summary

        // Only input placeholder is tested while textarea's placeholder is not.
        // Currently Safari 4 and Opera 11 have support only for the input placeholder
        // Both tests are available in feature-detects/forms-placeholder.js
        Modernizr['input'] = (function(props) {
            for (var i = 0, len = props.length; i < len; i++) {
                attrs[props[i]] = !!(props[i]in inputElem);
            }
            if (attrs.list) {
                // safari false positive's on datalist: webk.it/74252
                // see also github.com/Modernizr/Modernizr/issues/146
                attrs.list = !!(document.createElement('datalist') && window.HTMLDataListElement);
            }
            return attrs;
        }
        )('autocomplete autofocus list placeholder max min multiple pattern required step'.split(' '));
        /*>>input*/

        /*>>inputtypes*/
        // Run through HTML5's new input types to see if the UA understands any.
        //   This is put behind the tests runloop because it doesn't return a
        //   true/false like all the other tests; instead, it returns an object
        //   containing each input type with its corresponding true/false value

        // Big thanks to @miketaylr for the html5 forms expertise. miketaylr.com/
        Modernizr['inputtypes'] = (function(props) {

            for (var i = 0, bool, inputElemType, defaultView, len = props.length; i < len; i++) {

                inputElem.setAttribute('type', inputElemType = props[i]);
                bool = inputElem.type !== 'text';

                // We first check to see if the type we give it sticks..
                // If the type does, we feed it a textual value, which shouldn't be valid.
                // If the value doesn't stick, we know there's input sanitization which infers a custom UI
                if (bool) {

                    inputElem.value = smile;
                    inputElem.style.cssText = 'position:absolute;visibility:hidden;';

                    if (/^range$/.test(inputElemType) && inputElem.style.WebkitAppearance !== undefined) {

                        docElement.appendChild(inputElem);
                        defaultView = document.defaultView;

                        // Safari 2-4 allows the smiley as a value, despite making a slider
                        bool = defaultView.getComputedStyle && defaultView.getComputedStyle(inputElem, null).WebkitAppearance !== 'textfield' && // Mobile android web browser has false positive, so must
                        // check the height to see if the widget is actually there.
                        (inputElem.offsetHeight !== 0);

                        docElement.removeChild(inputElem);

                    } else if (/^(search|tel)$/.test(inputElemType)) {// Spec doesn't define any special parsing or detectable UI
                    //   behaviors so we pass these through as true

                    // Interestingly, opera fails the earlier test, so it doesn't
                    //  even make it here.

                    } else if (/^(url|email)$/.test(inputElemType)) {
                        // Real url and email support comes with prebaked validation.
                        bool = inputElem.checkValidity && inputElem.checkValidity() === false;

                    } else {
                        // If the upgraded input compontent rejects the :) text, we got a winner
                        bool = inputElem.value != smile;
                    }
                }

                inputs[props[i]] = !!bool;
            }
            return inputs;
        }
        )('search tel url email datetime date month week time datetime-local number range color'.split(' '));
        /*>>inputtypes*/
    }
    /*>>webforms*/

    // End of test definitions
    // -----------------------

    // Run through all tests and detect their support in the current UA.
    // todo: hypothetically we could be doing an array of tests and use a basic loop here.
    for (var feature in tests) {
        if (hasOwnProp(tests, feature)) {
            // run the test, throw the return value into the Modernizr,
            //   then based on that boolean, define an appropriate className
            //   and push it into an array of classes we'll join later.
            featureName = feature.toLowerCase();
            Modernizr[featureName] = tests[feature]();

            classes.push((Modernizr[featureName] ? '' : 'no-') + featureName);
        }
    }

    /*>>webforms*/
    // input tests need to run.
    Modernizr.input || webforms();
    /*>>webforms*/

    /**
     * addTest allows the user to define their own feature tests
     * the result will be added onto the Modernizr object,
     * as well as an appropriate className set on the html element
     *
     * @param feature - String naming the feature
     * @param test - Function returning true if feature is supported, false if not
     */
    Modernizr.addTest = function(feature, test) {
        if (typeof feature == 'object') {
            for (var key in feature) {
                if (hasOwnProp(feature, key)) {
                    Modernizr.addTest(key, feature[key]);
                }
            }
        } else {

            feature = feature.toLowerCase();

            if (Modernizr[feature] !== undefined) {
                // we're going to quit if you're trying to overwrite an existing test
                // if we were to allow it, we'd do this:
                //   var re = new RegExp("\\b(no-)?" + feature + "\\b");
                //   docElement.className = docElement.className.replace( re, '' );
                // but, no rly, stuff 'em.
                return Modernizr;
            }

            test = typeof test == 'function' ? test() : test;

            if (typeof enableClasses !== "undefined" && enableClasses) {
                docElement.className += ' ' + (test ? '' : 'no-') + feature;
            }
            Modernizr[feature] = test;

        }

        return Modernizr;
        // allow chaining.
    }
    ;

    // Reset modElem.cssText to nothing to reduce memory footprint.
    setCss('');
    modElem = inputElem = null;

    /*>>shiv*/
    /**
     * @preserve HTML5 Shiv prev3.7.1 | @afarkas @jdalton @jon_neal @rem | MIT/GPL2 Licensed
     */
    ;(function(window, document) {
        /*jshint evil:true */
        /** version */
        var version = '3.7.0';

        /** Preset options */
        var options = window.html5 || {};

        /** Used to skip problem elements */
        var reSkip = /^<|^(?:button|map|select|textarea|object|iframe|option|optgroup)$/i;

        /** Not all elements can be cloned in IE **/
        var saveClones = /^(?:a|b|code|div|fieldset|h1|h2|h3|h4|h5|h6|i|label|li|ol|p|q|span|strong|style|table|tbody|td|th|tr|ul)$/i;

        /** Detect whether the browser supports default html5 styles */
        var supportsHtml5Styles;

        /** Name of the expando, to work with multiple documents or to re-shiv one document */
        var expando = '_html5shiv';

        /** The id for the the documents expando */
        var expanID = 0;

        /** Cached data for each document */
        var expandoData = {};

        /** Detect whether the browser supports unknown elements */
        var supportsUnknownElements;

        (function() {
            try {
                var a = document.createElement('a');
                a.innerHTML = '<xyz></xyz>';
                //if the hidden property is implemented we can assume, that the browser supports basic HTML5 Styles
                supportsHtml5Styles = ('hidden'in a);

                supportsUnknownElements = a.childNodes.length == 1 || (function() {
                    // assign a false positive if unable to shiv
                    (document.createElement)('a');
                    var frag = document.createDocumentFragment();
                    return (typeof frag.cloneNode == 'undefined' || typeof frag.createDocumentFragment == 'undefined' || typeof frag.createElement == 'undefined');
                }());
            } catch (e) {
                // assign a false positive if detection fails => unable to shiv
                supportsHtml5Styles = true;
                supportsUnknownElements = true;
            }

        }());

        /*--------------------------------------------------------------------------*/

        /**
         * Creates a style sheet with the given CSS text and adds it to the document.
         * @private
         * @param {Document} ownerDocument The document.
         * @param {String} cssText The CSS text.
         * @returns {StyleSheet} The style element.
         */
        function addStyleSheet(ownerDocument, cssText) {
            var p = ownerDocument.createElement('p')
              , parent = ownerDocument.getElementsByTagName('head')[0] || ownerDocument.documentElement;

            p.innerHTML = 'x<style>' + cssText + '</style>';
            return parent.insertBefore(p.lastChild, parent.firstChild);
        }

        /**
         * Returns the value of `html5.elements` as an array.
         * @private
         * @returns {Array} An array of shived element node names.
         */
        function getElements() {
            var elements = html5.elements;
            return typeof elements == 'string' ? elements.split(' ') : elements;
        }

        /**
         * Returns the data associated to the given document
         * @private
         * @param {Document} ownerDocument The document.
         * @returns {Object} An object of data.
         */
        function getExpandoData(ownerDocument) {
            var data = expandoData[ownerDocument[expando]];
            if (!data) {
                data = {};
                expanID++;
                ownerDocument[expando] = expanID;
                expandoData[expanID] = data;
            }
            return data;
        }

        /**
         * returns a shived element for the given nodeName and document
         * @memberOf html5
         * @param {String} nodeName name of the element
         * @param {Document} ownerDocument The context document.
         * @returns {Object} The shived element.
         */
        function createElement(nodeName, ownerDocument, data) {
            if (!ownerDocument) {
                ownerDocument = document;
            }
            if (supportsUnknownElements) {
                return ownerDocument.createElement(nodeName);
            }
            if (!data) {
                data = getExpandoData(ownerDocument);
            }
            var node;

            if (data.cache[nodeName]) {
                node = data.cache[nodeName].cloneNode();
            } else if (saveClones.test(nodeName)) {
                node = (data.cache[nodeName] = data.createElem(nodeName)).cloneNode();
            } else {
                node = data.createElem(nodeName);
            }

            // Avoid adding some elements to fragments in IE < 9 because
            // * Attributes like `name` or `type` cannot be set/changed once an element
            //   is inserted into a document/fragment
            // * Link elements with `src` attributes that are inaccessible, as with
            //   a 403 response, will cause the tab/window to crash
            // * Script elements appended to fragments will execute when their `src`
            //   or `text` property is set
            return node.canHaveChildren && !reSkip.test(nodeName) && !node.tagUrn ? data.frag.appendChild(node) : node;
        }

        /**
         * returns a shived DocumentFragment for the given document
         * @memberOf html5
         * @param {Document} ownerDocument The context document.
         * @returns {Object} The shived DocumentFragment.
         */
        function createDocumentFragment(ownerDocument, data) {
            if (!ownerDocument) {
                ownerDocument = document;
            }
            if (supportsUnknownElements) {
                return ownerDocument.createDocumentFragment();
            }
            data = data || getExpandoData(ownerDocument);
            var clone = data.frag.cloneNode()
              , i = 0
              , elems = getElements()
              , l = elems.length;
            for (; i < l; i++) {
                clone.createElement(elems[i]);
            }
            return clone;
        }

        /**
         * Shivs the `createElement` and `createDocumentFragment` methods of the document.
         * @private
         * @param {Document|DocumentFragment} ownerDocument The document.
         * @param {Object} data of the document.
         */
        function shivMethods(ownerDocument, data) {
            if (!data.cache) {
                data.cache = {};
                data.createElem = ownerDocument.createElement;
                data.createFrag = ownerDocument.createDocumentFragment;
                data.frag = data.createFrag();
            }

            ownerDocument.createElement = function(nodeName) {
                //abort shiv
                if (!html5.shivMethods) {
                    return data.createElem(nodeName);
                }
                return createElement(nodeName, ownerDocument, data);
            }
            ;

            ownerDocument.createDocumentFragment = Function('h,f', 'return function(){' + 'var n=f.cloneNode(),c=n.createElement;' + 'h.shivMethods&&(' + // unroll the `createElement` calls
            getElements().join().replace(/[\w\-]+/g, function(nodeName) {
                data.createElem(nodeName);
                data.frag.createElement(nodeName);
                return 'c("' + nodeName + '")';
            }) + ');return n}')(html5, data.frag);
        }

        /*--------------------------------------------------------------------------*/

        /**
         * Shivs the given document.
         * @memberOf html5
         * @param {Document} ownerDocument The document to shiv.
         * @returns {Document} The shived document.
         */
        function shivDocument(ownerDocument) {
            if (!ownerDocument) {
                ownerDocument = document;
            }
            var data = getExpandoData(ownerDocument);

            if (html5.shivCSS && !supportsHtml5Styles && !data.hasCSS) {
                data.hasCSS = !!addStyleSheet(ownerDocument, // corrects block display not defined in IE6/7/8/9
                'article,aside,dialog,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}' + // adds styling not present in IE6/7/8/9
                'mark{background:#FF0;color:#000}' + // hides non-rendered elements
                'template{display:none}');
            }
            if (!supportsUnknownElements) {
                shivMethods(ownerDocument, data);
            }
            return ownerDocument;
        }

        /*--------------------------------------------------------------------------*/

        /**
         * The `html5` object is exposed so that more elements can be shived and
         * existing shiving can be detected on iframes.
         * @type Object
         * @example
         *
         * // options can be changed before the script is included
         * html5 = { 'elements': 'mark section', 'shivCSS': false, 'shivMethods': false };
         */
        var html5 = {

            /**
           * An array or space separated string of node names of the elements to shiv.
           * @memberOf html5
           * @type Array|String
           */
            'elements': options.elements || 'abbr article aside audio bdi canvas data datalist details dialog figcaption figure footer header hgroup main mark meter nav output progress section summary template time video',

            /**
           * current version of html5shiv
           */
            'version': version,

            /**
           * A flag to indicate that the HTML5 style sheet should be inserted.
           * @memberOf html5
           * @type Boolean
           */
            'shivCSS': (options.shivCSS !== false),

            /**
           * Is equal to true if a browser supports creating unknown/HTML5 elements
           * @memberOf html5
           * @type boolean
           */
            'supportsUnknownElements': supportsUnknownElements,

            /**
           * A flag to indicate that the document's `createElement` and `createDocumentFragment`
           * methods should be overwritten.
           * @memberOf html5
           * @type Boolean
           */
            'shivMethods': (options.shivMethods !== false),

            /**
           * A string to describe the type of `html5` object ("default" or "default print").
           * @memberOf html5
           * @type String
           */
            'type': 'default',

            // shivs the document according to the specified `html5` object options
            'shivDocument': shivDocument,

            //creates a shived element
            createElement: createElement,

            //creates a shived documentFragment
            createDocumentFragment: createDocumentFragment
        };

        /*--------------------------------------------------------------------------*/

        // expose html5
        window.html5 = html5;

        // shiv the document
        shivDocument(document);

    }(this, document));
    /*>>shiv*/

    // Assign private properties to the return object with prefix
    Modernizr._version = version;

    // expose these for the plugin API. Look in the source for how to join() them against your input
    /*>>prefixes*/
    Modernizr._prefixes = prefixes;
    /*>>prefixes*/
    /*>>domprefixes*/
    Modernizr._domPrefixes = domPrefixes;
    Modernizr._cssomPrefixes = cssomPrefixes;
    /*>>domprefixes*/

    /*>>mq*/
    // Modernizr.mq tests a given media query, live against the current state of the window
    // A few important notes:
    //   * If a browser does not support media queries at all (eg. oldIE) the mq() will always return false
    //   * A max-width or orientation query will be evaluated against the current state, which may change later.
    //   * You must specify values. Eg. If you are testing support for the min-width media query use:
    //       Modernizr.mq('(min-width:0)')
    // usage:
    // Modernizr.mq('only screen and (max-width:768)')
    Modernizr.mq = testMediaQuery;
    /*>>mq*/

    /*>>hasevent*/
    // Modernizr.hasEvent() detects support for a given event, with an optional element to test on
    // Modernizr.hasEvent('gesturestart', elem)
    Modernizr.hasEvent = isEventSupported;
    /*>>hasevent*/

    /*>>testprop*/
    // Modernizr.testProp() investigates whether a given style property is recognized
    // Note that the property names must be provided in the camelCase variant.
    // Modernizr.testProp('pointerEvents')
    Modernizr.testProp = function(prop) {
        return testProps([prop]);
    }
    ;
    /*>>testprop*/

    /*>>testallprops*/
    // Modernizr.testAllProps() investigates whether a given style property,
    //   or any of its vendor-prefixed variants, is recognized
    // Note that the property names must be provided in the camelCase variant.
    // Modernizr.testAllProps('boxSizing')
    Modernizr.testAllProps = testPropsAll;
    /*>>testallprops*/

    /*>>teststyles*/
    // Modernizr.testStyles() allows you to add custom styles to the document and test an element afterwards
    // Modernizr.testStyles('#modernizr { position:absolute }', function(elem, rule){ ... })
    Modernizr.testStyles = injectElementWithStyles;
    /*>>teststyles*/

    /*>>prefixed*/
    // Modernizr.prefixed() returns the prefixed or nonprefixed property name variant of your input
    // Modernizr.prefixed('boxSizing') // 'MozBoxSizing'

    // Properties must be passed as dom-style camelcase, rather than `box-sizing` hypentated style.
    // Return values will also be the camelCase variant, if you need to translate that to hypenated style use:
    //
    //     str.replace(/([A-Z])/g, function(str,m1){ return '-' + m1.toLowerCase(); }).replace(/^ms-/,'-ms-');

    // If you're trying to ascertain which transition end event to bind to, you might do something like...
    //
    //     var transEndEventNames = {
    //       'WebkitTransition' : 'webkitTransitionEnd',
    //       'MozTransition'    : 'transitionend',
    //       'OTransition'      : 'oTransitionEnd',
    //       'msTransition'     : 'MSTransitionEnd',
    //       'transition'       : 'transitionend'
    //     },
    //     transEndEventName = transEndEventNames[ Modernizr.prefixed('transition') ];

    Modernizr.prefixed = function(prop, obj, elem) {
        if (!obj) {
            return testPropsAll(prop, 'pfx');
        } else {
            // Testing DOM property e.g. Modernizr.prefixed('requestAnimationFrame', window) // 'mozRequestAnimationFrame'
            return testPropsAll(prop, obj, elem);
        }
    }
    ;
    /*>>prefixed*/

    /*>>cssclasses*/
    // Remove "no-js" class from <html> element, if it exists:
    docElement.className = docElement.className.replace(/(^|\s)no-js(\s|$)/, '$1$2') +
    // Add the new classes to the <html> element.
    (enableClasses ? ' js ' + classes.join(' ') : '');
    /*>>cssclasses*/

    return Modernizr;

}
)(this, this.document);

/*!
  hey, [be]Lazy.js - v1.6.4 - 2016.10.08
  A fast, small and dependency free lazy load script (https://github.com/dinbror/blazy)
  (c) Bjoern Klinggaard - @bklinggaard - http://dinbror.dk/blazy
*/
;(function(root, blazy) {
    if (typeof define === 'function' && define.amd) {
        // AMD. Register bLazy as an anonymous module
        define(blazy);
    } else if (typeof exports === 'object') {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = blazy();
    } else {
        // Browser globals. Register bLazy on window
        root.Blazy = blazy();
    }
}
)(this, function() {
    'use strict';

    //private vars
    var _source, _viewport, _isRetina, _attrSrc = 'src', _attrSrcset = 'srcset';

    // constructor
    return function Blazy(options) {
        //IE7- fallback for missing querySelectorAll support
        if (!document.querySelectorAll) {
            var s = document.createStyleSheet();
            document.querySelectorAll = function(r, c, i, j, a) {
                a = document.all,
                c = [],
                r = r.replace(/\[for\b/gi, '[htmlFor').split(',');
                for (i = r.length; i--; ) {
                    s.addRule(r[i], 'k:v');
                    for (j = a.length; j--; )
                        a[j].currentStyle.k && c.push(a[j]);
                    s.removeRule(0);
                }
                return c;
            }
            ;
        }

        //options and helper vars
        var scope = this;
        var util = scope._util = {};
        util.elements = [];
        util.destroyed = true;
        scope.options = options || {};
        scope.options.error = scope.options.error || false;
        scope.options.offset = scope.options.offset || 100;
        scope.options.root = scope.options.root || document;
        scope.options.success = scope.options.success || false;
        scope.options.selector = scope.options.selector || '.b-lazy';
        scope.options.separator = scope.options.separator || '|';
        scope.options.container = scope.options.container ? document.querySelectorAll(scope.options.container) : false;
        scope.options.errorClass = scope.options.errorClass || 'b-error';
        scope.options.breakpoints = scope.options.breakpoints || false;
        // obsolete
        scope.options.loadInvisible = scope.options.loadInvisible || false;
        scope.options.successClass = scope.options.successClass || 'b-loaded';
        scope.options.validateDelay = scope.options.validateDelay || 25;
        scope.options.saveViewportOffsetDelay = scope.options.saveViewportOffsetDelay || 50;
        scope.options.srcset = scope.options.srcset || 'data-srcset';
        scope.options.src = _source = scope.options.src || 'data-src';
        _isRetina = window.devicePixelRatio > 1;
        _viewport = {};
        _viewport.top = 0 - scope.options.offset;
        _viewport.left = 0 - scope.options.offset;

        /* public functions
         ************************************/
        scope.revalidate = function() {
            initialize(this);
        }
        ;
        scope.load = function(elements, force) {
            var opt = this.options;
            if (elements.length === undefined) {
                loadElement(elements, force, opt);
            } else {
                each(elements, function(element) {
                    loadElement(element, force, opt);
                });
            }
        }
        ;
        scope.destroy = function() {
            var self = this;
            var util = self._util;
            if (self.options.container) {
                each(self.options.container, function(object) {
                    unbindEvent(object, 'scroll', util.validateT);
                });
            }
            unbindEvent(window, 'scroll', util.validateT);
            unbindEvent(window, 'resize', util.validateT);
            unbindEvent(window, 'resize', util.saveViewportOffsetT);
            util.count = 0;
            util.elements.length = 0;
            util.destroyed = true;
        }
        ;

        //throttle, ensures that we don't call the functions too often
        util.validateT = throttle(function() {
            validate(scope);
        }, scope.options.validateDelay, scope);
        util.saveViewportOffsetT = throttle(function() {
            saveViewportOffset(scope.options.offset);
        }, scope.options.saveViewportOffsetDelay, scope);
        saveViewportOffset(scope.options.offset);

        //handle multi-served image src (obsolete)
        each(scope.options.breakpoints, function(object) {
            if (object.width >= window.screen.width) {
                _source = object.src;
                return false;
            }
        });

        // start lazy load
        setTimeout(function() {
            initialize(scope);
        });
        // "dom ready" fix

    }
    ;

    /* Private helper functions
     ************************************/
    function initialize(self) {
        var util = self._util;
        // First we create an array of elements to lazy load
        util.elements = toArray(self.options);
        util.count = util.elements.length;
        // Then we bind resize and scroll events if not already binded
        if (util.destroyed) {
            util.destroyed = false;
            if (self.options.container) {
                each(self.options.container, function(object) {
                    bindEvent(object, 'scroll', util.validateT);
                });
            }
            bindEvent(window, 'resize', util.saveViewportOffsetT);
            bindEvent(window, 'resize', util.validateT);
            bindEvent(window, 'scroll', util.validateT);
        }
        // And finally, we start to lazy load.
        validate(self);
    }

    function validate(self) {
        var util = self._util;
        for (var i = 0; i < util.count; i++) {
            var element = util.elements[i];
            if (elementInView(element) || hasClass(element, self.options.successClass)) {
                self.load(element);
                util.elements.splice(i, 1);
                util.count--;
                i--;
            }
        }
        if (util.count === 0) {
            self.destroy();
        }
    }

    function elementInView(ele) {
        var rect = ele.getBoundingClientRect();
        return (// Intersection
        rect.right >= _viewport.left && rect.bottom >= _viewport.top && rect.left <= _viewport.right && rect.top <= _viewport.bottom);
    }

    function loadElement(ele, force, options) {
        // if element is visible, not loaded or forced
        if (!hasClass(ele, options.successClass) && (force || options.loadInvisible || (ele.offsetWidth > 0 && ele.offsetHeight > 0))) {
            var dataSrc = ele.getAttribute(_source) || ele.getAttribute(options.src);
            // fallback to default 'data-src'
            if (dataSrc) {
                var dataSrcSplitted = dataSrc.split(options.separator);
                var src = dataSrcSplitted[_isRetina && dataSrcSplitted.length > 1 ? 1 : 0];
                var isImage = equal(ele, 'img');
                // Image or background image
                if (isImage || ele.src === undefined) {
                    var img = new Image();
                    // using EventListener instead of onerror and onload
                    // due to bug introduced in chrome v50 
                    // (https://productforums.google.com/forum/#!topic/chrome/p51Lk7vnP2o)
                    var onErrorHandler = function() {
                        if (options.error)
                            options.error(ele, "invalid");
                        addClass(ele, options.errorClass);
                        unbindEvent(img, 'error', onErrorHandler);
                        unbindEvent(img, 'load', onLoadHandler);
                    };
                    var onLoadHandler = function() {
                        // Is element an image
                        if (isImage) {
                            handleSource(ele, _attrSrcset, options.srcset);
                            //srcset
                            //picture element
                            var parent = ele.parentNode;
                            if (parent && equal(parent, 'picture')) {
                                each(parent.getElementsByTagName('source'), function(source) {
                                    handleSource(source, _attrSrcset, options.srcset);
                                });
                            }
                            setSrc(ele, src);
                            //src
                            // or background-image
                        } else {
                            ele.style.backgroundImage = 'url("' + src + '")';
                        }
                        itemLoaded(ele, options);
                        unbindEvent(img, 'load', onLoadHandler);
                        unbindEvent(img, 'error', onErrorHandler);
                    };
                    bindEvent(img, 'error', onErrorHandler);
                    bindEvent(img, 'load', onLoadHandler);

                    // preloading srcset
                    var dataSrc = ele.getAttribute(options.srcset);
                    if (dataSrc) {
                        img[_attrSrcset] = dataSrc;
                    }
                    setSrc(img, src);
                    //preload
                } else {
                    // An item with src like iframe, unity, simpelvideo etc
                    setSrc(ele, src);
                    itemLoaded(ele, options);
                }
            } else {
                // video with child source
                if (equal(ele, 'video')) {
                    each(ele.getElementsByTagName('source'), function(source) {
                        handleSource(source, _attrSrc, options.src);
                    });
                    ele.load();
                    itemLoaded(ele, options);
                } else {
                    if (options.error)
                        options.error(ele, "missing");
                    addClass(ele, options.errorClass);
                }
            }
        }
    }

    function itemLoaded(ele, options) {
        addClass(ele, options.successClass);
        if (options.success)
            options.success(ele);
        // cleanup markup, remove data source attributes
        ele.removeAttribute(options.src);
        each(options.breakpoints, function(object) {
            ele.removeAttribute(object.src);
        });
    }

    function setSrc(ele, src) {
        ele[_attrSrc] = src;
    }

    function handleSource(ele, attr, dataAttr) {
        var dataSrc = ele.getAttribute(dataAttr);
        if (dataSrc) {
            ele[attr] = dataSrc;
            ele.removeAttribute(dataAttr);
        }
    }

    function equal(ele, str) {
        return ele.nodeName.toLowerCase() === str;
    }

    function hasClass(ele, className) {
        return (' ' + ele.className + ' ').indexOf(' ' + className + ' ') !== -1;
    }

    function addClass(ele, className) {
        if (!hasClass(ele, className)) {
            ele.className += ' ' + className;
        }
    }

    function toArray(options) {
        var array = [];
        var nodelist = (options.root).querySelectorAll(options.selector);
        for (var i = nodelist.length; i--; array.unshift(nodelist[i])) {}
        return array;
    }

    function saveViewportOffset(offset) {
        _viewport.bottom = (window.innerHeight || document.documentElement.clientHeight) + offset;
        _viewport.right = (window.innerWidth || document.documentElement.clientWidth) + offset;
    }

    function bindEvent(ele, type, fn) {
        if (ele.attachEvent) {
            ele.attachEvent && ele.attachEvent('on' + type, fn);
        } else {
            ele.addEventListener(type, fn, {
                capture: false,
                passive: true
            });
        }
    }

    function unbindEvent(ele, type, fn) {
        if (ele.detachEvent) {
            ele.detachEvent && ele.detachEvent('on' + type, fn);
        } else {
            ele.removeEventListener(type, fn, {
                capture: false,
                passive: true
            });
        }
    }

    function each(object, fn) {
        if (object && fn) {
            var l = object.length;
            for (var i = 0; i < l && fn(object[i], i) !== false; i++) {}
        }
    }

    function throttle(fn, minDelay, scope) {
        var lastCall = 0;
        return function() {
            var now = +new Date();
            if (now - lastCall < minDelay) {
                return;
            }
            lastCall = now;
            fn.apply(scope, arguments);
        }
        ;
    }
});
// Generated by CoffeeScript 1.8.0

/*
jQuery Credit Card Validator 1.0

Copyright 2012-2015 Pawel Decowski

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software
is furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included
in all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
IN THE SOFTWARE.
 */

(function() {
    var $, __indexOf = [].indexOf || function(item) {
        for (var i = 0, l = this.length; i < l; i++) {
            if (i in this && this[i] === item)
                return i;
        }
        return -1;
    }
    ;

    $ = jQuery;

    $.fn.validateCreditCard = function(callback, options) {
        var bind, card, card_type, card_types, get_card_type, is_valid_length, is_valid_luhn, normalize, validate, validate_number, _i, _len, _ref;
        card_types = [{
            name: 'amex',
            pattern: /^3[47]/,
            valid_length: [15]
        }, {
            name: 'diners_club_carte_blanche',
            pattern: /^30[0-5]/,
            valid_length: [14]
        }, {
            name: 'diners_club_international',
            pattern: /^36/,
            valid_length: [14]
        }, {
            name: 'jcb',
            pattern: /^35(2[89]|[3-8][0-9])/,
            valid_length: [16]
        }, {
            name: 'laser',
            pattern: /^(6304|670[69]|6771)/,
            valid_length: [16, 17, 18, 19]
        }, {
            name: 'visa_electron',
            pattern: /^(4026|417500|4508|4844|491(3|7))/,
            valid_length: [16]
        }, {
            name: 'visa',
            pattern: /^4/,
            valid_length: [16]
        }, {
            name: 'mastercard',
            pattern: /^5[1-5]/,
            valid_length: [16]
        }, {
            name: 'maestro',
            pattern: /^(5018|5020|5038|6304|6759|676[1-3])/,
            valid_length: [12, 13, 14, 15, 16, 17, 18, 19]
        }, {
            name: 'discover',
            pattern: /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/,
            valid_length: [16]
        }];
        bind = false;
        if (callback) {
            if (typeof callback === 'object') {
                options = callback;
                bind = false;
                callback = null;
            } else if (typeof callback === 'function') {
                bind = true;
            }
        }
        if (options == null) {
            options = {};
        }
        if (options.accept == null) {
            options.accept = (function() {
                var _i, _len, _results;
                _results = [];
                for (_i = 0,
                _len = card_types.length; _i < _len; _i++) {
                    card = card_types[_i];
                    _results.push(card.name);
                }
                return _results;
            }
            )();
        }
        _ref = options.accept;
        for (_i = 0,
        _len = _ref.length; _i < _len; _i++) {
            card_type = _ref[_i];
            if (__indexOf.call((function() {
                var _j, _len1, _results;
                _results = [];
                for (_j = 0,
                _len1 = card_types.length; _j < _len1; _j++) {
                    card = card_types[_j];
                    _results.push(card.name);
                }
                return _results;
            }
            )(), card_type) < 0) {
                throw "Credit card type '" + card_type + "' is not supported";
            }
        }
        get_card_type = function(number) {
            var _j, _len1, _ref1;
            _ref1 = (function() {
                var _k, _len1, _ref1, _results;
                _results = [];
                for (_k = 0,
                _len1 = card_types.length; _k < _len1; _k++) {
                    card = card_types[_k];
                    if (_ref1 = card.name,
                    __indexOf.call(options.accept, _ref1) >= 0) {
                        _results.push(card);
                    }
                }
                return _results;
            }
            )();
            for (_j = 0,
            _len1 = _ref1.length; _j < _len1; _j++) {
                card_type = _ref1[_j];
                if (number.match(card_type.pattern)) {
                    return card_type;
                }
            }
            return null;
        }
        ;
        is_valid_luhn = function(number) {
            var digit, n, sum, _j, _len1, _ref1;
            sum = 0;
            _ref1 = number.split('').reverse();
            for (n = _j = 0,
            _len1 = _ref1.length; _j < _len1; n = ++_j) {
                digit = _ref1[n];
                digit = +digit;
                if (n % 2) {
                    digit *= 2;
                    if (digit < 10) {
                        sum += digit;
                    } else {
                        sum += digit - 9;
                    }
                } else {
                    sum += digit;
                }
            }
            return sum % 10 === 0;
        }
        ;
        is_valid_length = function(number, card_type) {
            var _ref1;
            return _ref1 = number.length,
            __indexOf.call(card_type.valid_length, _ref1) >= 0;
        }
        ;
        validate_number = (function(_this) {
            return function(number) {
                var length_valid, luhn_valid;
                card_type = get_card_type(number);
                luhn_valid = false;
                length_valid = false;
                if (card_type != null) {
                    luhn_valid = is_valid_luhn(number);
                    length_valid = is_valid_length(number, card_type);
                }
                return {
                    card_type: card_type,
                    valid: luhn_valid && length_valid,
                    luhn_valid: luhn_valid,
                    length_valid: length_valid
                };
            }
            ;
        }
        )(this);
        validate = (function(_this) {
            return function() {
                var number;
                number = normalize($(_this).val());
                return validate_number(number);
            }
            ;
        }
        )(this);
        normalize = function(number) {
            return number.replace(/[ -]/g, '');
        }
        ;
        if (!bind) {
            return validate();
        }
        this.on('input.jccv', (function(_this) {
            return function() {
                $(_this).off('keyup.jccv');
                return callback.call(_this, validate());
            }
            ;
        }
        )(this));
        this.on('keyup.jccv', (function(_this) {
            return function() {
                return callback.call(_this, validate());
            }
            ;
        }
        )(this));
        callback.call(this, validate());
        return this;
    }
    ;

}
).call(this);

/*!
 * jQuery.scrollTo
 * Copyright (c) 2007-2015 Ariel Flesler - aflesler<a>gmail<d>com | http://flesler.blogspot.com
 * Licensed under MIT
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 * @projectDescription Lightweight, cross-browser and highly customizable animated scrolling with jQuery
 * @author Ariel Flesler
 * @version 2.1.2
 */
;(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof module !== 'undefined' && module.exports) {
        // CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Global
        factory(jQuery);
    }
}
)(function($) {
    'use strict';

    var $scrollTo = $.scrollTo = function(target, duration, settings) {
        return $(window).scrollTo(target, duration, settings);
    }
    ;

    $scrollTo.defaults = {
        axis: 'xy',
        duration: 0,
        limit: true
    };

    function isWin(elem) {
        return !elem.nodeName || $.inArray(elem.nodeName.toLowerCase(), ['iframe', '#document', 'html', 'body']) !== -1;
    }

    $.fn.scrollTo = function(target, duration, settings) {
        if (typeof duration === 'object') {
            settings = duration;
            duration = 0;
        }
        if (typeof settings === 'function') {
            settings = {
                onAfter: settings
            };
        }
        if (target === 'max') {
            target = 9e9;
        }

        settings = $.extend({}, $scrollTo.defaults, settings);
        // Speed is still recognized for backwards compatibility
        duration = duration || settings.duration;
        // Make sure the settings are given right
        var queue = settings.queue && settings.axis.length > 1;
        if (queue) {
            // Let's keep the overall duration
            duration /= 2;
        }
        settings.offset = both(settings.offset);
        settings.over = both(settings.over);

        return this.each(function() {
            // Null target yields nothing, just like jQuery does
            if (target === null)
                return;

            var win = isWin(this), elem = win ? this.contentWindow || window : this, $elem = $(elem), targ = target, attr = {}, toff;

            switch (typeof targ) {
                // A number will pass the regex
            case 'number':
            case 'string':
                if (/^([+-]=?)?\d+(\.\d+)?(px|%)?$/.test(targ)) {
                    targ = both(targ);
                    // We are done
                    break;
                }
                // Relative/Absolute selector
                targ = win ? $(targ) : $(targ, elem);
                /* falls through */
            case 'object':
                if (targ.length === 0)
                    return;
                // DOMElement / jQuery
                if (targ.is || targ.style) {
                    // Get the real position of the target
                    toff = (targ = $(targ)).offset();
                }
            }

            var offset = $.isFunction(settings.offset) && settings.offset(elem, targ) || settings.offset;

            $.each(settings.axis.split(''), function(i, axis) {
                var Pos = axis === 'x' ? 'Left' : 'Top'
                  , pos = Pos.toLowerCase()
                  , key = 'scroll' + Pos
                  , prev = $elem[key]()
                  , max = $scrollTo.max(elem, axis);

                if (toff) {
                    // jQuery / DOMElement
                    attr[key] = toff[pos] + (win ? 0 : prev - $elem.offset()[pos]);

                    // If it's a dom element, reduce the margin
                    if (settings.margin) {
                        attr[key] -= parseInt(targ.css('margin' + Pos), 10) || 0;
                        attr[key] -= parseInt(targ.css('border' + Pos + 'Width'), 10) || 0;
                    }

                    attr[key] += offset[pos] || 0;

                    if (settings.over[pos]) {
                        // Scroll to a fraction of its width/height
                        attr[key] += targ[axis === 'x' ? 'width' : 'height']() * settings.over[pos];
                    }
                } else {
                    var val = targ[pos];
                    // Handle percentage values
                    attr[key] = val.slice && val.slice(-1) === '%' ? parseFloat(val) / 100 * max : val;
                }

                // Number or 'number'
                if (settings.limit && /^\d+$/.test(attr[key])) {
                    // Check the limits
                    attr[key] = attr[key] <= 0 ? 0 : Math.min(attr[key], max);
                }

                // Don't waste time animating, if there's no need.
                if (!i && settings.axis.length > 1) {
                    if (prev === attr[key]) {
                        // No animation needed
                        attr = {};
                    } else if (queue) {
                        // Intermediate animation
                        animate(settings.onAfterFirst);
                        // Don't animate this axis again in the next iteration.
                        attr = {};
                    }
                }
            });

            animate(settings.onAfter);

            function animate(callback) {
                var opts = $.extend({}, settings, {
                    // The queue setting conflicts with animate()
                    // Force it to always be true
                    queue: true,
                    duration: duration,
                    complete: callback && function() {
                        callback.call(elem, targ, settings);
                    }
                });
                $elem.animate(attr, opts);
            }
        });
    }
    ;

    // Max scrolling position, works on quirks mode
    // It only fails (not too badly) on IE, quirks mode.
    $scrollTo.max = function(elem, axis) {
        var Dim = axis === 'x' ? 'Width' : 'Height'
          , scroll = 'scroll' + Dim;

        if (!isWin(elem))
            return elem[scroll] - $(elem)[Dim.toLowerCase()]();

        var size = 'client' + Dim
          , doc = elem.ownerDocument || elem.document
          , html = doc.documentElement
          , body = doc.body;

        return Math.max(html[scroll], body[scroll]) - Math.min(html[size], body[size]);
    }
    ;

    function both(val) {
        return $.isFunction(val) || $.isPlainObject(val) ? val : {
            top: val,
            left: val
        };
    }

    // Add special hooks so that window scroll properties can be animated
    $.Tween.propHooks.scrollLeft = $.Tween.propHooks.scrollTop = {
        get: function(t) {
            return $(t.elem)[t.prop]();
        },
        set: function(t) {
            var curr = this.get(t);
            // If interrupt is true and user scrolled, stop animating
            if (t.options.interrupt && t._last && t._last !== curr) {
                return $(t.elem).stop();
            }
            var next = Math.round(t.now);
            // Don't waste CPU
            // Browsers don't render floating point scroll
            if (curr !== next) {
                $(t.elem)[t.prop](next);
                t._last = this.get(t);
            }
        }
    };

    // AMD requirement
    return $scrollTo;
});

/**
 * Owl Carousel v2.1.6
 * Copyright 2013-2016 David Deutsch
 * Licensed under MIT (https://github.com/OwlCarousel2/OwlCarousel2/blob/master/LICENSE)
 */
/**
 * Owl carousel
 * @version 2.1.6
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 * @todo Lazy Load Icon
 * @todo prevent animationend bubling
 * @todo itemsScaleUp
 * @todo Test Zepto
 * @todo stagePadding calculate wrong active classes
 */
;(function($, window, document, undefined) {

    /**
	 * Creates a carousel.
	 * @class The Owl Carousel.
	 * @public
	 * @param {HTMLElement|jQuery} element - The element to create the carousel for.
	 * @param {Object} [options] - The options
	 */
    function Owl(element, options) {

        /**
		 * Current settings for the carousel.
		 * @public
		 */
        this.settings = null;

        /**
		 * Current options set by the caller including defaults.
		 * @public
		 */
        this.options = $.extend({}, Owl.Defaults, options);

        /**
		 * Plugin element.
		 * @public
		 */
        this.$element = $(element);

        /**
		 * Proxied event handlers.
		 * @protected
		 */
        this._handlers = {};

        /**
		 * References to the running plugins of this carousel.
		 * @protected
		 */
        this._plugins = {};

        /**
		 * Currently suppressed events to prevent them from beeing retriggered.
		 * @protected
		 */
        this._supress = {};

        /**
		 * Absolute current position.
		 * @protected
		 */
        this._current = null;

        /**
		 * Animation speed in milliseconds.
		 * @protected
		 */
        this._speed = null;

        /**
		 * Coordinates of all items in pixel.
		 * @todo The name of this member is missleading.
		 * @protected
		 */
        this._coordinates = [];

        /**
		 * Current breakpoint.
		 * @todo Real media queries would be nice.
		 * @protected
		 */
        this._breakpoint = null;

        /**
		 * Current width of the plugin element.
		 */
        this._width = null;

        /**
		 * All real items.
		 * @protected
		 */
        this._items = [];

        /**
		 * All cloned items.
		 * @protected
		 */
        this._clones = [];

        /**
		 * Merge values of all items.
		 * @todo Maybe this could be part of a plugin.
		 * @protected
		 */
        this._mergers = [];

        /**
		 * Widths of all items.
		 */
        this._widths = [];

        /**
		 * Invalidated parts within the update process.
		 * @protected
		 */
        this._invalidated = {};

        /**
		 * Ordered list of workers for the update process.
		 * @protected
		 */
        this._pipe = [];

        /**
		 * Current state information for the drag operation.
		 * @todo #261
		 * @protected
		 */
        this._drag = {
            time: null,
            target: null,
            pointer: null,
            stage: {
                start: null,
                current: null
            },
            direction: null
        };

        /**
		 * Current state information and their tags.
		 * @type {Object}
		 * @protected
		 */
        this._states = {
            current: {},
            tags: {
                'initializing': ['busy'],
                'animating': ['busy'],
                'dragging': ['interacting']
            }
        };

        $.each(['onResize', 'onThrottledResize'], $.proxy(function(i, handler) {
            this._handlers[handler] = $.proxy(this[handler], this);
        }, this));

        $.each(Owl.Plugins, $.proxy(function(key, plugin) {
            this._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin(this);
        }, this));

        $.each(Owl.Workers, $.proxy(function(priority, worker) {
            this._pipe.push({
                'filter': worker.filter,
                'run': $.proxy(worker.run, this)
            });
        }, this));

        this.setup();
        this.initialize();
    }

    /**
	 * Default options for the carousel.
	 * @public
	 */
    Owl.Defaults = {
        items: 3,
        loop: false,
        center: false,
        rewind: false,

        mouseDrag: true,
        touchDrag: true,
        pullDrag: true,
        freeDrag: false,

        margin: 0,
        stagePadding: 0,

        merge: false,
        mergeFit: true,
        autoWidth: false,

        startPosition: 0,
        rtl: false,

        smartSpeed: 250,
        fluidSpeed: false,
        dragEndSpeed: false,

        responsive: {},
        responsiveRefreshRate: 200,
        responsiveBaseElement: window,

        fallbackEasing: 'swing',

        info: false,

        nestedItemSelector: false,
        itemElement: 'div',
        stageElement: 'div',

        refreshClass: 'owl-refresh',
        loadedClass: 'owl-loaded',
        loadingClass: 'owl-loading',
        rtlClass: 'owl-rtl',
        responsiveClass: 'owl-responsive',
        dragClass: 'owl-drag',
        itemClass: 'owl-item',
        stageClass: 'owl-stage',
        stageOuterClass: 'owl-stage-outer',
        grabClass: 'owl-grab'
    };

    /**
	 * Enumeration for width.
	 * @public
	 * @readonly
	 * @enum {String}
	 */
    Owl.Width = {
        Default: 'default',
        Inner: 'inner',
        Outer: 'outer'
    };

    /**
	 * Enumeration for types.
	 * @public
	 * @readonly
	 * @enum {String}
	 */
    Owl.Type = {
        Event: 'event',
        State: 'state'
    };

    /**
	 * Contains all registered plugins.
	 * @public
	 */
    Owl.Plugins = {};

    /**
	 * List of workers involved in the update process.
	 */
    Owl.Workers = [{
        filter: ['width', 'settings'],
        run: function() {
            this._width = this.$element.width();
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function(cache) {
            cache.current = this._items && this._items[this.relative(this._current)];
        }
    }, {
        filter: ['items', 'settings'],
        run: function() {
            this.$stage.children('.cloned').remove();
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function(cache) {
            var margin = this.settings.margin || ''
              , grid = !this.settings.autoWidth
              , rtl = this.settings.rtl
              , css = {
                'width': 'auto',
                'margin-left': rtl ? margin : '',
                'margin-right': rtl ? '' : margin
            };

            !grid && this.$stage.children().css(css);

            cache.css = css;
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function(cache) {
            var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin
              , merge = null
              , iterator = this._items.length
              , grid = !this.settings.autoWidth
              , widths = [];

            cache.items = {
                merge: false,
                width: width
            };

            while (iterator--) {
                merge = this._mergers[iterator];
                merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge;

                cache.items.merge = merge > 1 || cache.items.merge;

                widths[iterator] = !grid ? this._items[iterator].width() : width * merge;
            }

            this._widths = widths;
        }
    }, {
        filter: ['items', 'settings'],
        run: function() {
            var clones = []
              , items = this._items
              , settings = this.settings
              , view = Math.max(settings.items * 2, 4)
              , size = Math.ceil(items.length / 2) * 2
              , repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0
              , append = ''
              , prepend = '';

            repeat /= 2;

            while (repeat--) {
                clones.push(this.normalize(clones.length / 2, true));
                append = append + items[clones[clones.length - 1]][0].outerHTML;
                clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, true));
                prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
            }

            this._clones = clones;

            $(append).addClass('cloned').appendTo(this.$stage);
            $(prepend).addClass('cloned').prependTo(this.$stage);
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function() {
            var rtl = this.settings.rtl ? 1 : -1
              , size = this._clones.length + this._items.length
              , iterator = -1
              , previous = 0
              , current = 0
              , coordinates = [];

            while (++iterator < size) {
                previous = coordinates[iterator - 1] || 0;
                current = this._widths[this.relative(iterator)] + this.settings.margin;
                coordinates.push(previous + current * rtl);
            }

            this._coordinates = coordinates;
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function() {
            var padding = this.settings.stagePadding
              , coordinates = this._coordinates
              , css = {
                'width': Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + padding * 2,
                'padding-left': padding || '',
                'padding-right': padding || ''
            };

            this.$stage.css(css);
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function(cache) {
            var iterator = this._coordinates.length
              , grid = !this.settings.autoWidth
              , items = this.$stage.children();

            if (grid && cache.items.merge) {
                while (iterator--) {
                    cache.css.width = this._widths[this.relative(iterator)];
                    items.eq(iterator).css(cache.css);
                }
            } else if (grid) {
                cache.css.width = cache.items.width;
                items.css(cache.css);
            }
        }
    }, {
        filter: ['items'],
        run: function() {
            this._coordinates.length < 1 && this.$stage.removeAttr('style');
        }
    }, {
        filter: ['width', 'items', 'settings'],
        run: function(cache) {
            cache.current = cache.current ? this.$stage.children().index(cache.current) : 0;
            cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current));
            this.reset(cache.current);
        }
    }, {
        filter: ['position'],
        run: function() {
            this.animate(this.coordinates(this._current));
        }
    }, {
        filter: ['width', 'position', 'items', 'settings'],
        run: function() {
            var rtl = this.settings.rtl ? 1 : -1, padding = this.settings.stagePadding * 2, begin = this.coordinates(this.current()) + padding, end = begin + this.width() * rtl, inner, outer, matches = [], i, n;

            for (i = 0,
            n = this._coordinates.length; i < n; i++) {
                inner = this._coordinates[i - 1] || 0;
                outer = Math.abs(this._coordinates[i]) + padding * rtl;

                if ((this.op(inner, '<=', begin) && (this.op(inner, '>', end))) || (this.op(outer, '<', begin) && this.op(outer, '>', end))) {
                    matches.push(i);
                }
            }

            this.$stage.children('.active').removeClass('active');
            this.$stage.children(':eq(' + matches.join('), :eq(') + ')').addClass('active');

            if (this.settings.center) {
                this.$stage.children('.center').removeClass('center');
                this.$stage.children().eq(this.current()).addClass('center');
            }
        }
    }];

    /**
	 * Initializes the carousel.
	 * @protected
	 */
    Owl.prototype.initialize = function() {
        this.enter('initializing');
        this.trigger('initialize');

        this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl);

        if (this.settings.autoWidth && !this.is('pre-loading')) {
            var imgs, nestedSelector, width;
            imgs = this.$element.find('img');
            nestedSelector = this.settings.nestedItemSelector ? '.' + this.settings.nestedItemSelector : undefined;
            width = this.$element.children(nestedSelector).width();

            if (imgs.length && width <= 0) {
                this.preloadAutoWidthImages(imgs);
            }
        }

        this.$element.addClass(this.options.loadingClass);

        // create stage
        this.$stage = $('<' + this.settings.stageElement + ' class="' + this.settings.stageClass + '"/>').wrap('<div class="' + this.settings.stageOuterClass + '"/>');

        // append stage
        this.$element.append(this.$stage.parent());

        // append content
        this.replace(this.$element.children().not(this.$stage.parent()));

        // check visibility
        if (this.$element.is(':visible')) {
            // update view
            this.refresh();
        } else {
            // invalidate width
            this.invalidate('width');
        }

        this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass);

        // register event handlers
        this.registerEventHandlers();

        this.leave('initializing');
        this.trigger('initialized');
    }
    ;

    /**
	 * Setups the current settings.
	 * @todo Remove responsive classes. Why should adaptive designs be brought into IE8?
	 * @todo Support for media queries by using `matchMedia` would be nice.
	 * @public
	 */
    Owl.prototype.setup = function() {
        var viewport = this.viewport()
          , overwrites = this.options.responsive
          , match = -1
          , settings = null;

        if (!overwrites) {
            settings = $.extend({}, this.options);
        } else {
            $.each(overwrites, function(breakpoint) {
                if (breakpoint <= viewport && breakpoint > match) {
                    match = Number(breakpoint);
                }
            });

            settings = $.extend({}, this.options, overwrites[match]);
            if (typeof settings.stagePadding === 'function') {
                settings.stagePadding = settings.stagePadding();
            }
            delete settings.responsive;

            // responsive class
            if (settings.responsiveClass) {
                this.$element.attr('class', this.$element.attr('class').replace(new RegExp('(' + this.options.responsiveClass + '-)\\S+\\s','g'), '$1' + match));
            }
        }

        this.trigger('change', {
            property: {
                name: 'settings',
                value: settings
            }
        });
        this._breakpoint = match;
        this.settings = settings;
        this.invalidate('settings');
        this.trigger('changed', {
            property: {
                name: 'settings',
                value: this.settings
            }
        });
    }
    ;

    /**
	 * Updates option logic if necessery.
	 * @protected
	 */
    Owl.prototype.optionsLogic = function() {
        if (this.settings.autoWidth) {
            this.settings.stagePadding = false;
            this.settings.merge = false;
        }
    }
    ;

    /**
	 * Prepares an item before add.
	 * @todo Rename event parameter `content` to `item`.
	 * @protected
	 * @returns {jQuery|HTMLElement} - The item container.
	 */
    Owl.prototype.prepare = function(item) {
        var event = this.trigger('prepare', {
            content: item
        });

        if (!event.data) {
            event.data = $('<' + this.settings.itemElement + '/>').addClass(this.options.itemClass).append(item)
        }

        this.trigger('prepared', {
            content: event.data
        });

        return event.data;
    }
    ;

    /**
	 * Updates the view.
	 * @public
	 */
    Owl.prototype.update = function() {
        var i = 0
          , n = this._pipe.length
          , filter = $.proxy(function(p) {
            return this[p]
        }, this._invalidated)
          , cache = {};

        while (i < n) {
            if (this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) {
                this._pipe[i].run(cache);
            }
            i++;
        }

        this._invalidated = {};

        !this.is('valid') && this.enter('valid');
    }
    ;

    /**
	 * Gets the width of the view.
	 * @public
	 * @param {Owl.Width} [dimension=Owl.Width.Default] - The dimension to return.
	 * @returns {Number} - The width of the view in pixel.
	 */
    Owl.prototype.width = function(dimension) {
        dimension = dimension || Owl.Width.Default;
        switch (dimension) {
        case Owl.Width.Inner:
        case Owl.Width.Outer:
            return this._width;
        default:
            return this._width - this.settings.stagePadding * 2 + this.settings.margin;
        }
    }
    ;

    /**
	 * Refreshes the carousel primarily for adaptive purposes.
	 * @public
	 */
    Owl.prototype.refresh = function() {
        this.enter('refreshing');
        this.trigger('refresh');

        this.setup();

        this.optionsLogic();

        this.$element.addClass(this.options.refreshClass);

        this.update();

        this.$element.removeClass(this.options.refreshClass);

        this.leave('refreshing');
        this.trigger('refreshed');
    }
    ;

    /**
	 * Checks window `resize` event.
	 * @protected
	 */
    Owl.prototype.onThrottledResize = function() {
        window.clearTimeout(this.resizeTimer);
        this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate);
    }
    ;

    /**
	 * Checks window `resize` event.
	 * @protected
	 */
    Owl.prototype.onResize = function() {
        if (!this._items.length) {
            return false;
        }

        if (this._width === this.$element.width()) {
            return false;
        }

        if (!this.$element.is(':visible')) {
            return false;
        }

        this.enter('resizing');

        if (this.trigger('resize').isDefaultPrevented()) {
            this.leave('resizing');
            return false;
        }

        this.invalidate('width');

        this.refresh();

        this.leave('resizing');
        this.trigger('resized');
    }
    ;

    /**
	 * Registers event handlers.
	 * @todo Check `msPointerEnabled`
	 * @todo #261
	 * @protected
	 */
    Owl.prototype.registerEventHandlers = function() {
        if ($.support.transition) {
            this.$stage.on($.support.transition.end + '.owl.core', $.proxy(this.onTransitionEnd, this));
        }

        if (this.settings.responsive !== false) {
            this.on(window, 'resize', this._handlers.onThrottledResize);
        }

        if (this.settings.mouseDrag) {
            this.$element.addClass(this.options.dragClass);
            this.$stage.on('mousedown.owl.core', $.proxy(this.onDragStart, this));
            this.$stage.on('dragstart.owl.core selectstart.owl.core', function() {
                return false
            });
        }

        if (this.settings.touchDrag) {
            this.$stage.on('touchstart.owl.core', $.proxy(this.onDragStart, this));
            this.$stage.on('touchcancel.owl.core', $.proxy(this.onDragEnd, this));
        }
    }
    ;

    /**
	 * Handles `touchstart` and `mousedown` events.
	 * @todo Horizontal swipe threshold as option
	 * @todo #261
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
    Owl.prototype.onDragStart = function(event) {
        var stage = null;

        if (event.which === 3) {
            return;
        }

        if ($.support.transform) {
            stage = this.$stage.css('transform').replace(/.*\(|\)| /g, '').split(',');
            stage = {
                x: stage[stage.length === 16 ? 12 : 4],
                y: stage[stage.length === 16 ? 13 : 5]
            };
        } else {
            stage = this.$stage.position();
            stage = {
                x: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,
                y: stage.top
            };
        }

        if (this.is('animating')) {
            $.support.transform ? this.animate(stage.x) : this.$stage.stop()
            this.invalidate('position');
        }

        this.$element.toggleClass(this.options.grabClass, event.type === 'mousedown');

        this.speed(0);

        this._drag.time = new Date().getTime();
        this._drag.target = $(event.target);
        this._drag.stage.start = stage;
        this._drag.stage.current = stage;
        this._drag.pointer = this.pointer(event);

        $(document).on('mouseup.owl.core touchend.owl.core', $.proxy(this.onDragEnd, this));

        $(document).one('mousemove.owl.core touchmove.owl.core', $.proxy(function(event) {
            var delta = this.difference(this._drag.pointer, this.pointer(event));

            $(document).on('mousemove.owl.core touchmove.owl.core', $.proxy(this.onDragMove, this));

            if (Math.abs(delta.x) < Math.abs(delta.y) && this.is('valid')) {
                return;
            }

            event.preventDefault();

            this.enter('dragging');
            this.trigger('drag');
        }, this));
    }
    ;

    /**
	 * Handles the `touchmove` and `mousemove` events.
	 * @todo #261
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
    Owl.prototype.onDragMove = function(event) {
        var minimum = null
          , maximum = null
          , pull = null
          , delta = this.difference(this._drag.pointer, this.pointer(event))
          , stage = this.difference(this._drag.stage.start, delta);

        if (!this.is('dragging')) {
            return;
        }

        event.preventDefault();

        if (this.settings.loop) {
            minimum = this.coordinates(this.minimum());
            maximum = this.coordinates(this.maximum() + 1) - minimum;
            stage.x = (((stage.x - minimum) % maximum + maximum) % maximum) + minimum;
        } else {
            minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum());
            maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum());
            pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0;
            stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull);
        }

        this._drag.stage.current = stage;

        this.animate(stage.x);
    }
    ;

    /**
	 * Handles the `touchend` and `mouseup` events.
	 * @todo #261
	 * @todo Threshold for click event
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
    Owl.prototype.onDragEnd = function(event) {
        var delta = this.difference(this._drag.pointer, this.pointer(event))
          , stage = this._drag.stage.current
          , direction = delta.x > 0 ^ this.settings.rtl ? 'left' : 'right';

        $(document).off('.owl.core');

        this.$element.removeClass(this.options.grabClass);

        if (delta.x !== 0 && this.is('dragging') || !this.is('valid')) {
            this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed);
            this.current(this.closest(stage.x, delta.x !== 0 ? direction : this._drag.direction));
            this.invalidate('position');
            this.update();

            this._drag.direction = direction;

            if (Math.abs(delta.x) > 3 || new Date().getTime() - this._drag.time > 300) {
                this._drag.target.one('click.owl.core', function() {
                    return false;
                });
            }
        }

        if (!this.is('dragging')) {
            return;
        }

        this.leave('dragging');
        this.trigger('dragged');
    }
    ;

    /**
	 * Gets absolute position of the closest item for a coordinate.
	 * @todo Setting `freeDrag` makes `closest` not reusable. See #165.
	 * @protected
	 * @param {Number} coordinate - The coordinate in pixel.
	 * @param {String} direction - The direction to check for the closest item. Ether `left` or `right`.
	 * @return {Number} - The absolute position of the closest item.
	 */
    Owl.prototype.closest = function(coordinate, direction) {
        var position = -1
          , pull = 30
          , width = this.width()
          , coordinates = this.coordinates();

        if (!this.settings.freeDrag) {
            // check closest item
            $.each(coordinates, $.proxy(function(index, value) {
                // on a left pull, check on current index
                if (direction === 'left' && coordinate > value - pull && coordinate < value + pull) {
                    position = index;
                    // on a right pull, check on previous index
                    // to do so, subtract width from value and set position = index + 1
                } else if (direction === 'right' && coordinate > value - width - pull && coordinate < value - width + pull) {
                    position = index + 1;
                } else if (this.op(coordinate, '<', value) && this.op(coordinate, '>', coordinates[index + 1] || value - width)) {
                    position = direction === 'left' ? index + 1 : index;
                }
                return position === -1;
            }, this));
        }

        if (!this.settings.loop) {
            // non loop boundries
            if (this.op(coordinate, '>', coordinates[this.minimum()])) {
                position = coordinate = this.minimum();
            } else if (this.op(coordinate, '<', coordinates[this.maximum()])) {
                position = coordinate = this.maximum();
            }
        }

        return position;
    }
    ;

    /**
	 * Animates the stage.
	 * @todo #270
	 * @public
	 * @param {Number} coordinate - The coordinate in pixels.
	 */
    Owl.prototype.animate = function(coordinate) {
        var animate = this.speed() > 0;

        this.is('animating') && this.onTransitionEnd();

        if (animate) {
            this.enter('animating');
            this.trigger('translate');
        }

        if ($.support.transform3d && $.support.transition) {
            this.$stage.css({
                transform: 'translate3d(' + coordinate + 'px,0px,0px)',
                transition: (this.speed() / 1000) + 's'
            });
        } else if (animate) {
            this.$stage.animate({
                left: coordinate + 'px'
            }, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this));
        } else {
            this.$stage.css({
                left: coordinate + 'px'
            });
        }
    }
    ;

    /**
	 * Checks whether the carousel is in a specific state or not.
	 * @param {String} state - The state to check.
	 * @returns {Boolean} - The flag which indicates if the carousel is busy.
	 */
    Owl.prototype.is = function(state) {
        return this._states.current[state] && this._states.current[state] > 0;
    }
    ;

    /**
	 * Sets the absolute position of the current item.
	 * @public
	 * @param {Number} [position] - The new absolute position or nothing to leave it unchanged.
	 * @returns {Number} - The absolute position of the current item.
	 */
    Owl.prototype.current = function(position) {
        if (position === undefined) {
            return this._current;
        }

        if (this._items.length === 0) {
            return undefined;
        }

        position = this.normalize(position);

        if (this._current !== position) {
            var event = this.trigger('change', {
                property: {
                    name: 'position',
                    value: position
                }
            });

            if (event.data !== undefined) {
                position = this.normalize(event.data);
            }

            this._current = position;

            this.invalidate('position');

            this.trigger('changed', {
                property: {
                    name: 'position',
                    value: this._current
                }
            });
        }

        return this._current;
    }
    ;

    /**
	 * Invalidates the given part of the update routine.
	 * @param {String} [part] - The part to invalidate.
	 * @returns {Array.<String>} - The invalidated parts.
	 */
    Owl.prototype.invalidate = function(part) {
        if ($.type(part) === 'string') {
            this._invalidated[part] = true;
            this.is('valid') && this.leave('valid');
        }
        return $.map(this._invalidated, function(v, i) {
            return i
        });
    }
    ;

    /**
	 * Resets the absolute position of the current item.
	 * @public
	 * @param {Number} position - The absolute position of the new item.
	 */
    Owl.prototype.reset = function(position) {
        position = this.normalize(position);

        if (position === undefined) {
            return;
        }

        this._speed = 0;
        this._current = position;

        this.suppress(['translate', 'translated']);

        this.animate(this.coordinates(position));

        this.release(['translate', 'translated']);
    }
    ;

    /**
	 * Normalizes an absolute or a relative position of an item.
	 * @public
	 * @param {Number} position - The absolute or relative position to normalize.
	 * @param {Boolean} [relative=false] - Whether the given position is relative or not.
	 * @returns {Number} - The normalized position.
	 */
    Owl.prototype.normalize = function(position, relative) {
        var n = this._items.length
          , m = relative ? 0 : this._clones.length;

        if (!this.isNumeric(position) || n < 1) {
            position = undefined;
        } else if (position < 0 || position >= n + m) {
            position = ((position - m / 2) % n + n) % n + m / 2;
        }

        return position;
    }
    ;

    /**
	 * Converts an absolute position of an item into a relative one.
	 * @public
	 * @param {Number} position - The absolute position to convert.
	 * @returns {Number} - The converted position.
	 */
    Owl.prototype.relative = function(position) {
        position -= this._clones.length / 2;
        return this.normalize(position, true);
    }
    ;

    /**
	 * Gets the maximum position for the current item.
	 * @public
	 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
	 * @returns {Number}
	 */
    Owl.prototype.maximum = function(relative) {
        var settings = this.settings, maximum = this._coordinates.length, iterator, reciprocalItemsWidth, elementWidth;

        if (settings.loop) {
            maximum = this._clones.length / 2 + this._items.length - 1;
        } else if (settings.autoWidth || settings.merge) {
            iterator = this._items.length;
            reciprocalItemsWidth = this._items[--iterator].width();
            elementWidth = this.$element.width();
            while (iterator--) {
                reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin;
                if (reciprocalItemsWidth > elementWidth) {
                    break;
                }
            }
            maximum = iterator + 1;
        } else if (settings.center) {
            maximum = this._items.length - 1;
        } else {
            maximum = this._items.length - settings.items;
        }

        if (relative) {
            maximum -= this._clones.length / 2;
        }

        return Math.max(maximum, 0);
    }
    ;

    /**
	 * Gets the minimum position for the current item.
	 * @public
	 * @param {Boolean} [relative=false] - Whether to return an absolute position or a relative position.
	 * @returns {Number}
	 */
    Owl.prototype.minimum = function(relative) {
        return relative ? 0 : this._clones.length / 2;
    }
    ;

    /**
	 * Gets an item at the specified relative position.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
	 */
    Owl.prototype.items = function(position) {
        if (position === undefined) {
            return this._items.slice();
        }

        position = this.normalize(position, true);
        return this._items[position];
    }
    ;

    /**
	 * Gets an item at the specified relative position.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @return {jQuery|Array.<jQuery>} - The item at the given position or all items if no position was given.
	 */
    Owl.prototype.mergers = function(position) {
        if (position === undefined) {
            return this._mergers.slice();
        }

        position = this.normalize(position, true);
        return this._mergers[position];
    }
    ;

    /**
	 * Gets the absolute positions of clones for an item.
	 * @public
	 * @param {Number} [position] - The relative position of the item.
	 * @returns {Array.<Number>} - The absolute positions of clones for the item or all if no position was given.
	 */
    Owl.prototype.clones = function(position) {
        var odd = this._clones.length / 2
          , even = odd + this._items.length
          , map = function(index) {
            return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2
        };

        if (position === undefined) {
            return $.map(this._clones, function(v, i) {
                return map(i)
            });
        }

        return $.map(this._clones, function(v, i) {
            return v === position ? map(i) : null
        });
    }
    ;

    /**
	 * Sets the current animation speed.
	 * @public
	 * @param {Number} [speed] - The animation speed in milliseconds or nothing to leave it unchanged.
	 * @returns {Number} - The current animation speed in milliseconds.
	 */
    Owl.prototype.speed = function(speed) {
        if (speed !== undefined) {
            this._speed = speed;
        }

        return this._speed;
    }
    ;

    /**
	 * Gets the coordinate of an item.
	 * @todo The name of this method is missleanding.
	 * @public
	 * @param {Number} position - The absolute position of the item within `minimum()` and `maximum()`.
	 * @returns {Number|Array.<Number>} - The coordinate of the item in pixel or all coordinates.
	 */
    Owl.prototype.coordinates = function(position) {
        var multiplier = 1, newPosition = position - 1, coordinate;

        if (position === undefined) {
            return $.map(this._coordinates, $.proxy(function(coordinate, index) {
                return this.coordinates(index);
            }, this));
        }

        if (this.settings.center) {
            if (this.settings.rtl) {
                multiplier = -1;
                newPosition = position + 1;
            }

            coordinate = this._coordinates[position];
            coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier;
        } else {
            coordinate = this._coordinates[newPosition] || 0;
        }

        coordinate = Math.ceil(coordinate);

        return coordinate;
    }
    ;

    /**
	 * Calculates the speed for a translation.
	 * @protected
	 * @param {Number} from - The absolute position of the start item.
	 * @param {Number} to - The absolute position of the target item.
	 * @param {Number} [factor=undefined] - The time factor in milliseconds.
	 * @returns {Number} - The time in milliseconds for the translation.
	 */
    Owl.prototype.duration = function(from, to, factor) {
        if (factor === 0) {
            return 0;
        }

        return Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs((factor || this.settings.smartSpeed));
    }
    ;

    /**
	 * Slides to the specified item.
	 * @public
	 * @param {Number} position - The position of the item.
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
    Owl.prototype.to = function(position, speed) {
        var current = this.current()
          , revert = null
          , distance = position - this.relative(current)
          , direction = (distance > 0) - (distance < 0)
          , items = this._items.length
          , minimum = this.minimum()
          , maximum = this.maximum();

        if (this.settings.loop) {
            if (!this.settings.rewind && Math.abs(distance) > items / 2) {
                distance += direction * -1 * items;
            }

            position = current + distance;
            revert = ((position - minimum) % items + items) % items + minimum;

            if (revert !== position && revert - distance <= maximum && revert - distance > 0) {
                current = revert - distance;
                position = revert;
                this.reset(current);
            }
        } else if (this.settings.rewind) {
            maximum += 1;
            position = (position % maximum + maximum) % maximum;
        } else {
            position = Math.max(minimum, Math.min(maximum, position));
        }

        this.speed(this.duration(current, position, speed));
        this.current(position);

        if (this.$element.is(':visible')) {
            this.update();
        }
    }
    ;

    /**
	 * Slides to the next item.
	 * @public
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
    Owl.prototype.next = function(speed) {
        speed = speed || false;
        this.to(this.relative(this.current()) + 1, speed);
    }
    ;

    /**
	 * Slides to the previous item.
	 * @public
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 */
    Owl.prototype.prev = function(speed) {
        speed = speed || false;
        this.to(this.relative(this.current()) - 1, speed);
    }
    ;

    /**
	 * Handles the end of an animation.
	 * @protected
	 * @param {Event} event - The event arguments.
	 */
    Owl.prototype.onTransitionEnd = function(event) {

        // if css2 animation then event object is undefined
        if (event !== undefined) {
            event.stopPropagation();

            // Catch only owl-stage transitionEnd event
            if ((event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) {
                return false;
            }
        }

        this.leave('animating');
        this.trigger('translated');
    }
    ;

    /**
	 * Gets viewport width.
	 * @protected
	 * @return {Number} - The width in pixel.
	 */
    Owl.prototype.viewport = function() {
        var width;
        if (this.options.responsiveBaseElement !== window) {
            width = $(this.options.responsiveBaseElement).width();
        } else if (window.innerWidth) {
            width = window.innerWidth;
        } else if (document.documentElement && document.documentElement.clientWidth) {
            width = document.documentElement.clientWidth;
        } else {
            throw 'Can not detect viewport width.';
        }
        return width;
    }
    ;

    /**
	 * Replaces the current content.
	 * @public
	 * @param {HTMLElement|jQuery|String} content - The new content.
	 */
    Owl.prototype.replace = function(content) {
        this.$stage.empty();
        this._items = [];

        if (content) {
            content = (content instanceof jQuery) ? content : $(content);
        }

        if (this.settings.nestedItemSelector) {
            content = content.find('.' + this.settings.nestedItemSelector);
        }

        content.filter(function() {
            return this.nodeType === 1;
        }).each($.proxy(function(index, item) {
            item = this.prepare(item);
            this.$stage.append(item);
            this._items.push(item);
            this._mergers.push(item.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
        }, this));

        this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0);

        this.invalidate('items');
    }
    ;

    /**
	 * Adds an item.
	 * @todo Use `item` instead of `content` for the event arguments.
	 * @public
	 * @param {HTMLElement|jQuery|String} content - The item content to add.
	 * @param {Number} [position] - The relative position at which to insert the item otherwise the item will be added to the end.
	 */
    Owl.prototype.add = function(content, position) {
        var current = this.relative(this._current);

        position = position === undefined ? this._items.length : this.normalize(position, true);
        content = content instanceof jQuery ? content : $(content);

        this.trigger('add', {
            content: content,
            position: position
        });

        content = this.prepare(content);

        if (this._items.length === 0 || position === this._items.length) {
            this._items.length === 0 && this.$stage.append(content);
            this._items.length !== 0 && this._items[position - 1].after(content);
            this._items.push(content);
            this._mergers.push(content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
        } else {
            this._items[position].before(content);
            this._items.splice(position, 0, content);
            this._mergers.splice(position, 0, content.find('[data-merge]').addBack('[data-merge]').attr('data-merge') * 1 || 1);
        }

        this._items[current] && this.reset(this._items[current].index());

        this.invalidate('items');

        this.trigger('added', {
            content: content,
            position: position
        });
    }
    ;

    /**
	 * Removes an item by its position.
	 * @todo Use `item` instead of `content` for the event arguments.
	 * @public
	 * @param {Number} position - The relative position of the item to remove.
	 */
    Owl.prototype.remove = function(position) {
        position = this.normalize(position, true);

        if (position === undefined) {
            return;
        }

        this.trigger('remove', {
            content: this._items[position],
            position: position
        });

        this._items[position].remove();
        this._items.splice(position, 1);
        this._mergers.splice(position, 1);

        this.invalidate('items');

        this.trigger('removed', {
            content: null,
            position: position
        });
    }
    ;

    /**
	 * Preloads images with auto width.
	 * @todo Replace by a more generic approach
	 * @protected
	 */
    Owl.prototype.preloadAutoWidthImages = function(images) {
        images.each($.proxy(function(i, element) {
            this.enter('pre-loading');
            element = $(element);
            $(new Image()).one('load', $.proxy(function(e) {
                element.attr('src', e.target.src);
                element.css('opacity', 1);
                this.leave('pre-loading');
                !this.is('pre-loading') && !this.is('initializing') && this.refresh();
            }, this)).attr('src', element.attr('src') || element.attr('data-src') || element.attr('data-src-retina'));
        }, this));
    }
    ;

    /**
	 * Destroys the carousel.
	 * @public
	 */
    Owl.prototype.destroy = function() {

        this.$element.off('.owl.core');
        this.$stage.off('.owl.core');
        $(document).off('.owl.core');

        if (this.settings.responsive !== false) {
            window.clearTimeout(this.resizeTimer);
            this.off(window, 'resize', this._handlers.onThrottledResize);
        }

        for (var i in this._plugins) {
            this._plugins[i].destroy();
        }

        this.$stage.children('.cloned').remove();

        this.$stage.unwrap();
        this.$stage.children().contents().unwrap();
        this.$stage.children().unwrap();

        this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr('class', this.$element.attr('class').replace(new RegExp(this.options.responsiveClass + '-\\S+\\s','g'), '')).removeData('owl.carousel');
    }
    ;

    /**
	 * Operators to calculate right-to-left and left-to-right.
	 * @protected
	 * @param {Number} [a] - The left side operand.
	 * @param {String} [o] - The operator.
	 * @param {Number} [b] - The right side operand.
	 */
    Owl.prototype.op = function(a, o, b) {
        var rtl = this.settings.rtl;
        switch (o) {
        case '<':
            return rtl ? a > b : a < b;
        case '>':
            return rtl ? a < b : a > b;
        case '>=':
            return rtl ? a <= b : a >= b;
        case '<=':
            return rtl ? a >= b : a <= b;
        default:
            break;
        }
    }
    ;

    /**
	 * Attaches to an internal event.
	 * @protected
	 * @param {HTMLElement} element - The event source.
	 * @param {String} event - The event name.
	 * @param {Function} listener - The event handler to attach.
	 * @param {Boolean} capture - Wether the event should be handled at the capturing phase or not.
	 */
    Owl.prototype.on = function(element, event, listener, capture) {
        if (element.addEventListener) {
            element.addEventListener(event, listener, capture);
        } else if (element.attachEvent) {
            element.attachEvent('on' + event, listener);
        }
    }
    ;

    /**
	 * Detaches from an internal event.
	 * @protected
	 * @param {HTMLElement} element - The event source.
	 * @param {String} event - The event name.
	 * @param {Function} listener - The attached event handler to detach.
	 * @param {Boolean} capture - Wether the attached event handler was registered as a capturing listener or not.
	 */
    Owl.prototype.off = function(element, event, listener, capture) {
        if (element.removeEventListener) {
            element.removeEventListener(event, listener, capture);
        } else if (element.detachEvent) {
            element.detachEvent('on' + event, listener);
        }
    }
    ;

    /**
	 * Triggers a public event.
	 * @todo Remove `status`, `relatedTarget` should be used instead.
	 * @protected
	 * @param {String} name - The event name.
	 * @param {*} [data=null] - The event data.
	 * @param {String} [namespace=carousel] - The event namespace.
	 * @param {String} [state] - The state which is associated with the event.
	 * @param {Boolean} [enter=false] - Indicates if the call enters the specified state or not.
	 * @returns {Event} - The event arguments.
	 */
    Owl.prototype.trigger = function(name, data, namespace, state, enter) {
        var status = {
            item: {
                count: this._items.length,
                index: this.current()
            }
        }
          , handler = $.camelCase($.grep(['on', name, namespace], function(v) {
            return v
        }).join('-').toLowerCase())
          , event = $.Event([name, 'owl', namespace || 'carousel'].join('.').toLowerCase(), $.extend({
            relatedTarget: this
        }, status, data));

        if (!this._supress[name]) {
            $.each(this._plugins, function(name, plugin) {
                if (plugin.onTrigger) {
                    plugin.onTrigger(event);
                }
            });

            this.register({
                type: Owl.Type.Event,
                name: name
            });
            this.$element.trigger(event);

            if (this.settings && typeof this.settings[handler] === 'function') {
                this.settings[handler].call(this, event);
            }
        }

        return event;
    }
    ;

    /**
	 * Enters a state.
	 * @param name - The state name.
	 */
    Owl.prototype.enter = function(name) {
        $.each([name].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
            if (this._states.current[name] === undefined) {
                this._states.current[name] = 0;
            }

            this._states.current[name]++;
        }, this));
    }
    ;

    /**
	 * Leaves a state.
	 * @param name - The state name.
	 */
    Owl.prototype.leave = function(name) {
        $.each([name].concat(this._states.tags[name] || []), $.proxy(function(i, name) {
            this._states.current[name]--;
        }, this));
    }
    ;

    /**
	 * Registers an event or state.
	 * @public
	 * @param {Object} object - The event or state to register.
	 */
    Owl.prototype.register = function(object) {
        if (object.type === Owl.Type.Event) {
            if (!$.event.special[object.name]) {
                $.event.special[object.name] = {};
            }

            if (!$.event.special[object.name].owl) {
                var _default = $.event.special[object.name]._default;
                $.event.special[object.name]._default = function(e) {
                    if (_default && _default.apply && (!e.namespace || e.namespace.indexOf('owl') === -1)) {
                        return _default.apply(this, arguments);
                    }
                    return e.namespace && e.namespace.indexOf('owl') > -1;
                }
                ;
                $.event.special[object.name].owl = true;
            }
        } else if (object.type === Owl.Type.State) {
            if (!this._states.tags[object.name]) {
                this._states.tags[object.name] = object.tags;
            } else {
                this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags);
            }

            this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function(tag, i) {
                return $.inArray(tag, this._states.tags[object.name]) === i;
            }, this));
        }
    }
    ;

    /**
	 * Suppresses events.
	 * @protected
	 * @param {Array.<String>} events - The events to suppress.
	 */
    Owl.prototype.suppress = function(events) {
        $.each(events, $.proxy(function(index, event) {
            this._supress[event] = true;
        }, this));
    }
    ;

    /**
	 * Releases suppressed events.
	 * @protected
	 * @param {Array.<String>} events - The events to release.
	 */
    Owl.prototype.release = function(events) {
        $.each(events, $.proxy(function(index, event) {
            delete this._supress[event];
        }, this));
    }
    ;

    /**
	 * Gets unified pointer coordinates from event.
	 * @todo #261
	 * @protected
	 * @param {Event} - The `mousedown` or `touchstart` event.
	 * @returns {Object} - Contains `x` and `y` coordinates of current pointer position.
	 */
    Owl.prototype.pointer = function(event) {
        var result = {
            x: null,
            y: null
        };

        event = event.originalEvent || event || window.event;

        event = event.touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event;

        if (event.pageX) {
            result.x = event.pageX;
            result.y = event.pageY;
        } else {
            result.x = event.clientX;
            result.y = event.clientY;
        }

        return result;
    }
    ;

    /**
	 * Determines if the input is a Number or something that can be coerced to a Number
	 * @protected
	 * @param {Number|String|Object|Array|Boolean|RegExp|Function|Symbol} - The input to be tested
	 * @returns {Boolean} - An indication if the input is a Number or can be coerced to a Number
	 */
    Owl.prototype.isNumeric = function(number) {
        return !isNaN(parseFloat(number));
    }
    ;

    /**
	 * Gets the difference of two vectors.
	 * @todo #261
	 * @protected
	 * @param {Object} - The first vector.
	 * @param {Object} - The second vector.
	 * @returns {Object} - The difference.
	 */
    Owl.prototype.difference = function(first, second) {
        return {
            x: first.x - second.x,
            y: first.y - second.y
        };
    }
    ;

    /**
	 * The jQuery Plugin for the Owl Carousel
	 * @todo Navigation plugin `next` and `prev`
	 * @public
	 */
    $.fn.owlCarousel = function(option) {
        var args = Array.prototype.slice.call(arguments, 1);

        return this.each(function() {
            var $this = $(this)
              , data = $this.data('owl.carousel');

            if (!data) {
                data = new Owl(this,typeof option == 'object' && option);
                $this.data('owl.carousel', data);

                $.each(['next', 'prev', 'to', 'destroy', 'refresh', 'replace', 'add', 'remove'], function(i, event) {
                    data.register({
                        type: Owl.Type.Event,
                        name: event
                    });
                    data.$element.on(event + '.owl.carousel.core', $.proxy(function(e) {
                        if (e.namespace && e.relatedTarget !== this) {
                            this.suppress([event]);
                            data[event].apply(this, [].slice.call(arguments, 1));
                            this.release([event]);
                        }
                    }, data));
                });
            }

            if (typeof option == 'string' && option.charAt(0) !== '_') {
                data[option].apply(data, args);
            }
        });
    }
    ;

    /**
	 * The constructor for the jQuery Plugin
	 * @public
	 */
    $.fn.owlCarousel.Constructor = Owl;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * AutoRefresh Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

    /**
	 * Creates the auto refresh plugin.
	 * @class The Auto Refresh Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
    var AutoRefresh = function(carousel) {
        /**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
        this._core = carousel;

        /**
		 * Refresh interval.
		 * @protected
		 * @type {number}
		 */
        this._interval = null;

        /**
		 * Whether the element is currently visible or not.
		 * @protected
		 * @type {Boolean}
		 */
        this._visible = null;

        /**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
        this._handlers = {
            'initialized.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.autoRefresh) {
                    this.watch();
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options);

        // register event handlers
        this._core.$element.on(this._handlers);
    };

    /**
	 * Default options.
	 * @public
	 */
    AutoRefresh.Defaults = {
        autoRefresh: true,
        autoRefreshInterval: 500
    };

    /**
	 * Watches the element.
	 */
    AutoRefresh.prototype.watch = function() {
        if (this._interval) {
            return;
        }

        this._visible = this._core.$element.is(':visible');
        this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval);
    }
    ;

    /**
	 * Refreshes the element.
	 */
    AutoRefresh.prototype.refresh = function() {
        if (this._core.$element.is(':visible') === this._visible) {
            return;
        }

        this._visible = !this._visible;

        this._core.$element.toggleClass('owl-hidden', !this._visible);

        this._visible && (this._core.invalidate('width') && this._core.refresh());
    }
    ;

    /**
	 * Destroys the plugin.
	 */
    AutoRefresh.prototype.destroy = function() {
        var handler, property;

        window.clearInterval(this._interval);

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    }
    ;

    $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * Lazy Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

    /**
	 * Creates the lazy plugin.
	 * @class The Lazy Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
    var Lazy = function(carousel) {

        /**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
        this._core = carousel;

        /**
		 * Already loaded items.
		 * @protected
		 * @type {Array.<jQuery>}
		 */
        this._loaded = [];

        /**
		 * Event handlers.
		 * @protected
		 * @type {Object}
		 */
        this._handlers = {
            'initialized.owl.carousel change.owl.carousel resized.owl.carousel': $.proxy(function(e) {
                if (!e.namespace) {
                    return;
                }

                if (!this._core.settings || !this._core.settings.lazyLoad) {
                    return;
                }

                if ((e.property && e.property.name == 'position') || e.type == 'initialized') {
                    var settings = this._core.settings
                      , n = (settings.center && Math.ceil(settings.items / 2) || settings.items)
                      , i = ((settings.center && n * -1) || 0)
                      , position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i
                      , clones = this._core.clones().length
                      , load = $.proxy(function(i, v) {
                        this.load(v)
                    }, this);

                    while (i++ < n) {
                        this.load(clones / 2 + this._core.relative(position));
                        clones && $.each(this._core.clones(this._core.relative(position)), load);
                        position++;
                    }
                }
            }, this)
        };

        // set the default options
        this._core.options = $.extend({}, Lazy.Defaults, this._core.options);

        // register event handler
        this._core.$element.on(this._handlers);
    };

    /**
	 * Default options.
	 * @public
	 */
    Lazy.Defaults = {
        lazyLoad: false
    };

    /**
	 * Loads all resources of an item at the specified position.
	 * @param {Number} position - The absolute position of the item.
	 * @protected
	 */
    Lazy.prototype.load = function(position) {
        var $item = this._core.$stage.children().eq(position)
          , $elements = $item && $item.find('.owl-lazy');

        if (!$elements || $.inArray($item.get(0), this._loaded) > -1) {
            return;
        }

        $elements.each($.proxy(function(index, element) {
            var $element = $(element), image, url = (window.devicePixelRatio > 1 && $element.attr('data-src-retina')) || $element.attr('data-src');

            this._core.trigger('load', {
                element: $element,
                url: url
            }, 'lazy');

            if ($element.is('img')) {
                $element.one('load.owl.lazy', $.proxy(function() {
                    $element.css('opacity', 1);
                    this._core.trigger('loaded', {
                        element: $element,
                        url: url
                    }, 'lazy');
                }, this)).attr('src', url);
            } else {
                image = new Image();
                image.onload = $.proxy(function() {
                    $element.css({
                        'background-image': 'url(' + url + ')',
                        'opacity': '1'
                    });
                    this._core.trigger('loaded', {
                        element: $element,
                        url: url
                    }, 'lazy');
                }, this);
                image.src = url;
            }
        }, this));

        this._loaded.push($item.get(0));
    }
    ;

    /**
	 * Destroys the plugin.
	 * @public
	 */
    Lazy.prototype.destroy = function() {
        var handler, property;

        for (handler in this.handlers) {
            this._core.$element.off(handler, this.handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    }
    ;

    $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * AutoHeight Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

    /**
	 * Creates the auto height plugin.
	 * @class The Auto Height Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
    var AutoHeight = function(carousel) {
        /**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
        this._core = carousel;

        /**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
        this._handlers = {
            'initialized.owl.carousel refreshed.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.autoHeight) {
                    this.update();
                }
            }, this),
            'changed.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.autoHeight && e.property.name == 'position') {
                    this.update();
                }
            }, this),
            'loaded.owl.lazy': $.proxy(function(e) {
                if (e.namespace && this._core.settings.autoHeight && e.element.closest('.' + this._core.settings.itemClass).index() === this._core.current()) {
                    this.update();
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options);

        // register event handlers
        this._core.$element.on(this._handlers);
    };

    /**
	 * Default options.
	 * @public
	 */
    AutoHeight.Defaults = {
        autoHeight: false,
        autoHeightClass: 'owl-height'
    };

    /**
	 * Updates the view.
	 */
    AutoHeight.prototype.update = function() {
        var start = this._core._current
          , end = start + this._core.settings.items
          , visible = this._core.$stage.children().toArray().slice(start, end)
          , heights = []
          , maxheight = 0;

        $.each(visible, function(index, item) {
            heights.push($(item).height());
        });

        maxheight = Math.max.apply(null, heights);

        this._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass);
    }
    ;

    AutoHeight.prototype.destroy = function() {
        var handler, property;

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    }
    ;

    $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * Video Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

    /**
	 * Creates the video plugin.
	 * @class The Video Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
    var Video = function(carousel) {
        /**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
        this._core = carousel;

        /**
		 * Cache all video URLs.
		 * @protected
		 * @type {Object}
		 */
        this._videos = {};

        /**
		 * Current playing item.
		 * @protected
		 * @type {jQuery}
		 */
        this._playing = null;

        /**
		 * All event handlers.
		 * @todo The cloned content removale is too late
		 * @protected
		 * @type {Object}
		 */
        this._handlers = {
            'initialized.owl.carousel': $.proxy(function(e) {
                if (e.namespace) {
                    this._core.register({
                        type: 'state',
                        name: 'playing',
                        tags: ['interacting']
                    });
                }
            }, this),
            'resize.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.video && this.isInFullScreen()) {
                    e.preventDefault();
                }
            }, this),
            'refreshed.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.is('resizing')) {
                    this._core.$stage.find('.cloned .owl-video-frame').remove();
                }
            }, this),
            'changed.owl.carousel': $.proxy(function(e) {
                if (e.namespace && e.property.name === 'position' && this._playing) {
                    this.stop();
                }
            }, this),
            'prepared.owl.carousel': $.proxy(function(e) {
                if (!e.namespace) {
                    return;
                }

                var $element = $(e.content).find('.owl-video');

                if ($element.length) {
                    $element.css('display', 'none');
                    this.fetch($element, $(e.content));
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, Video.Defaults, this._core.options);

        // register event handlers
        this._core.$element.on(this._handlers);

        this._core.$element.on('click.owl.video', '.owl-video-play-icon', $.proxy(function(e) {
            this.play(e);
        }, this));
    };

    /**
	 * Default options.
	 * @public
	 */
    Video.Defaults = {
        video: false,
        videoHeight: false,
        videoWidth: false
    };

    /**
	 * Gets the video ID and the type (YouTube/Vimeo/vzaar only).
	 * @protected
	 * @param {jQuery} target - The target containing the video data.
	 * @param {jQuery} item - The item containing the video.
	 */
    Video.prototype.fetch = function(target, item) {
        var type = (function() {
            if (target.attr('data-vimeo-id')) {
                return 'vimeo';
            } else if (target.attr('data-vzaar-id')) {
                return 'vzaar'
            } else {
                return 'youtube';
            }
        }
        )()
          , id = target.attr('data-vimeo-id') || target.attr('data-youtube-id') || target.attr('data-vzaar-id')
          , width = target.attr('data-width') || this._core.settings.videoWidth
          , height = target.attr('data-height') || this._core.settings.videoHeight
          , url = target.attr('href');

        if (url) {

            /*
					Parses the id's out of the following urls (and probably more):
					https://www.youtube.com/watch?v=:id
					https://youtu.be/:id
					https://vimeo.com/:id
					https://vimeo.com/channels/:channel/:id
					https://vimeo.com/groups/:group/videos/:id
					https://app.vzaar.com/videos/:id

					Visual example: https://regexper.com/#(http%3A%7Chttps%3A%7C)%5C%2F%5C%2F(player.%7Cwww.%7Capp.)%3F(vimeo%5C.com%7Cyoutu(be%5C.com%7C%5C.be%7Cbe%5C.googleapis%5C.com)%7Cvzaar%5C.com)%5C%2F(video%5C%2F%7Cvideos%5C%2F%7Cembed%5C%2F%7Cchannels%5C%2F.%2B%5C%2F%7Cgroups%5C%2F.%2B%5C%2F%7Cwatch%5C%3Fv%3D%7Cv%5C%2F)%3F(%5BA-Za-z0-9._%25-%5D*)(%5C%26%5CS%2B)%3F
			*/

            id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/);

            if (id[3].indexOf('youtu') > -1) {
                type = 'youtube';
            } else if (id[3].indexOf('vimeo') > -1) {
                type = 'vimeo';
            } else if (id[3].indexOf('vzaar') > -1) {
                type = 'vzaar';
            } else {
                throw new Error('Video URL not supported.');
            }
            id = id[6];
        } else {
            throw new Error('Missing video URL.');
        }

        this._videos[url] = {
            type: type,
            id: id,
            width: width,
            height: height
        };

        item.attr('data-video', url);

        this.thumbnail(target, this._videos[url]);
    }
    ;

    /**
	 * Creates video thumbnail.
	 * @protected
	 * @param {jQuery} target - The target containing the video data.
	 * @param {Object} info - The video info object.
	 * @see `fetch`
	 */
    Video.prototype.thumbnail = function(target, video) {
        var tnLink, icon, path, dimensions = video.width && video.height ? 'style="width:' + video.width + 'px;height:' + video.height + 'px;"' : '', customTn = target.find('img'), srcType = 'src', lazyClass = '', settings = this._core.settings, create = function(path) {
            icon = '<div class="owl-video-play-icon"></div>';

            if (settings.lazyLoad) {
                tnLink = '<div class="owl-video-tn ' + lazyClass + '" ' + srcType + '="' + path + '"></div>';
            } else {
                tnLink = '<div class="owl-video-tn" style="opacity:1;background-image:url(' + path + ')"></div>';
            }
            target.after(tnLink);
            target.after(icon);
        };

        // wrap video content into owl-video-wrapper div
        target.wrap('<div class="owl-video-wrapper"' + dimensions + '></div>');

        if (this._core.settings.lazyLoad) {
            srcType = 'data-src';
            lazyClass = 'owl-lazy';
        }

        // custom thumbnail
        if (customTn.length) {
            create(customTn.attr(srcType));
            customTn.remove();
            return false;
        }

        if (video.type === 'youtube') {
            path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg";
            create(path);
        } else if (video.type === 'vimeo') {
            $.ajax({
                type: 'GET',
                url: '//vimeo.com/api/v2/video/' + video.id + '.json',
                jsonp: 'callback',
                dataType: 'jsonp',
                success: function(data) {
                    path = data[0].thumbnail_large;
                    create(path);
                }
            });
        } else if (video.type === 'vzaar') {
            $.ajax({
                type: 'GET',
                url: '//vzaar.com/api/videos/' + video.id + '.json',
                jsonp: 'callback',
                dataType: 'jsonp',
                success: function(data) {
                    path = data.framegrab_url;
                    create(path);
                }
            });
        }
    }
    ;

    /**
	 * Stops the current video.
	 * @public
	 */
    Video.prototype.stop = function() {
        this._core.trigger('stop', null, 'video');
        this._playing.find('.owl-video-frame').remove();
        this._playing.removeClass('owl-video-playing');
        this._playing = null;
        this._core.leave('playing');
        this._core.trigger('stopped', null, 'video');
    }
    ;

    /**
	 * Starts the current video.
	 * @public
	 * @param {Event} event - The event arguments.
	 */
    Video.prototype.play = function(event) {
        var target = $(event.target), item = target.closest('.' + this._core.settings.itemClass), video = this._videos[item.attr('data-video')], width = video.width || '100%', height = video.height || this._core.$stage.height(), html;

        if (this._playing) {
            return;
        }

        this._core.enter('playing');
        this._core.trigger('play', null, 'video');

        item = this._core.items(this._core.relative(item.index()));

        this._core.reset(item.index());

        if (video.type === 'youtube') {
            html = '<iframe width="' + width + '" height="' + height + '" src="//www.youtube.com/embed/' + video.id + '?autoplay=1&v=' + video.id + '" frameborder="0" allowfullscreen></iframe>';
        } else if (video.type === 'vimeo') {
            html = '<iframe src="//player.vimeo.com/video/' + video.id + '?autoplay=1" width="' + width + '" height="' + height + '" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
        } else if (video.type === 'vzaar') {
            html = '<iframe frameborder="0"' + 'height="' + height + '"' + 'width="' + width + '" allowfullscreen mozallowfullscreen webkitAllowFullScreen ' + 'src="//view.vzaar.com/' + video.id + '/player?autoplay=true"></iframe>';
        }

        $('<div class="owl-video-frame">' + html + '</div>').insertAfter(item.find('.owl-video'));

        this._playing = item.addClass('owl-video-playing');
    }
    ;

    /**
	 * Checks whether an video is currently in full screen mode or not.
	 * @todo Bad style because looks like a readonly method but changes members.
	 * @protected
	 * @returns {Boolean}
	 */
    Video.prototype.isInFullScreen = function() {
        var element = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;

        return element && $(element).parent().hasClass('owl-video-frame');
    }
    ;

    /**
	 * Destroys the plugin.
	 */
    Video.prototype.destroy = function() {
        var handler, property;

        this._core.$element.off('click.owl.video');

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    }
    ;

    $.fn.owlCarousel.Constructor.Plugins.Video = Video;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * Animate Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

    /**
	 * Creates the animate plugin.
	 * @class The Navigation Plugin
	 * @param {Owl} scope - The Owl Carousel
	 */
    var Animate = function(scope) {
        this.core = scope;
        this.core.options = $.extend({}, Animate.Defaults, this.core.options);
        this.swapping = true;
        this.previous = undefined;
        this.next = undefined;

        this.handlers = {
            'change.owl.carousel': $.proxy(function(e) {
                if (e.namespace && e.property.name == 'position') {
                    this.previous = this.core.current();
                    this.next = e.property.value;
                }
            }, this),
            'drag.owl.carousel dragged.owl.carousel translated.owl.carousel': $.proxy(function(e) {
                if (e.namespace) {
                    this.swapping = e.type == 'translated';
                }
            }, this),
            'translate.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn)) {
                    this.swap();
                }
            }, this)
        };

        this.core.$element.on(this.handlers);
    };

    /**
	 * Default options.
	 * @public
	 */
    Animate.Defaults = {
        animateOut: false,
        animateIn: false
    };

    /**
	 * Toggles the animation classes whenever an translations starts.
	 * @protected
	 * @returns {Boolean|undefined}
	 */
    Animate.prototype.swap = function() {

        if (this.core.settings.items !== 1) {
            return;
        }

        if (!$.support.animation || !$.support.transition) {
            return;
        }

        this.core.speed(0);

        var left, clear = $.proxy(this.clear, this), previous = this.core.$stage.children().eq(this.previous), next = this.core.$stage.children().eq(this.next), incoming = this.core.settings.animateIn, outgoing = this.core.settings.animateOut;

        if (this.core.current() === this.previous) {
            return;
        }

        if (outgoing) {
            left = this.core.coordinates(this.previous) - this.core.coordinates(this.next);
            previous.one($.support.animation.end, clear).css({
                'left': left + 'px'
            }).addClass('animated owl-animated-out').addClass(outgoing);
        }

        if (incoming) {
            next.one($.support.animation.end, clear).addClass('animated owl-animated-in').addClass(incoming);
        }
    }
    ;

    Animate.prototype.clear = function(e) {
        $(e.target).css({
            'left': ''
        }).removeClass('animated owl-animated-out owl-animated-in').removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut);
        this.core.onTransitionEnd();
    }
    ;

    /**
	 * Destroys the plugin.
	 * @public
	 */
    Animate.prototype.destroy = function() {
        var handler, property;

        for (handler in this.handlers) {
            this.core.$element.off(handler, this.handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    }
    ;

    $.fn.owlCarousel.Constructor.Plugins.Animate = Animate;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * Autoplay Plugin
 * @version 2.1.0
 * @author Bartosz Wojciechowski
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

    /**
	 * Creates the autoplay plugin.
	 * @class The Autoplay Plugin
	 * @param {Owl} scope - The Owl Carousel
	 */
    var Autoplay = function(carousel) {
        /**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
        this._core = carousel;

        /**
		 * The autoplay timeout.
		 * @type {Timeout}
		 */
        this._timeout = null;

        /**
		 * Indicates whenever the autoplay is paused.
		 * @type {Boolean}
		 */
        this._paused = false;

        /**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
        this._handlers = {
            'changed.owl.carousel': $.proxy(function(e) {
                if (e.namespace && e.property.name === 'settings') {
                    if (this._core.settings.autoplay) {
                        this.play();
                    } else {
                        this.stop();
                    }
                } else if (e.namespace && e.property.name === 'position') {
                    //console.log('play?', e);
                    if (this._core.settings.autoplay) {
                        this._setAutoPlayInterval();
                    }
                }
            }, this),
            'initialized.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.autoplay) {
                    this.play();
                }
            }, this),
            'play.owl.autoplay': $.proxy(function(e, t, s) {
                if (e.namespace) {
                    this.play(t, s);
                }
            }, this),
            'stop.owl.autoplay': $.proxy(function(e) {
                if (e.namespace) {
                    this.stop();
                }
            }, this),
            'mouseover.owl.autoplay': $.proxy(function() {
                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                    this.pause();
                }
            }, this),
            'mouseleave.owl.autoplay': $.proxy(function() {
                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                    this.play();
                }
            }, this),
            'touchstart.owl.core': $.proxy(function() {
                if (this._core.settings.autoplayHoverPause && this._core.is('rotating')) {
                    this.pause();
                }
            }, this),
            'touchend.owl.core': $.proxy(function() {
                if (this._core.settings.autoplayHoverPause) {
                    this.play();
                }
            }, this)
        };

        // register event handlers
        this._core.$element.on(this._handlers);

        // set default options
        this._core.options = $.extend({}, Autoplay.Defaults, this._core.options);
    };

    /**
	 * Default options.
	 * @public
	 */
    Autoplay.Defaults = {
        autoplay: false,
        autoplayTimeout: 5000,
        autoplayHoverPause: false,
        autoplaySpeed: false
    };

    /**
	 * Starts the autoplay.
	 * @public
	 * @param {Number} [timeout] - The interval before the next animation starts.
	 * @param {Number} [speed] - The animation speed for the animations.
	 */
    Autoplay.prototype.play = function(timeout, speed) {
        this._paused = false;

        if (this._core.is('rotating')) {
            return;
        }

        this._core.enter('rotating');

        this._setAutoPlayInterval();
    }
    ;

    /**
	 * Gets a new timeout
	 * @private
	 * @param {Number} [timeout] - The interval before the next animation starts.
	 * @param {Number} [speed] - The animation speed for the animations.
	 * @return {Timeout}
	 */
    Autoplay.prototype._getNextTimeout = function(timeout, speed) {
        if (this._timeout) {
            window.clearTimeout(this._timeout);
        }
        return window.setTimeout($.proxy(function() {
            if (this._paused || this._core.is('busy') || this._core.is('interacting') || document.hidden) {
                return;
            }
            this._core.next(speed || this._core.settings.autoplaySpeed);
        }, this), timeout || this._core.settings.autoplayTimeout);
    }
    ;

    /**
	 * Sets autoplay in motion.
	 * @private
	 */
    Autoplay.prototype._setAutoPlayInterval = function() {
        this._timeout = this._getNextTimeout();
    }
    ;

    /**
	 * Stops the autoplay.
	 * @public
	 */
    Autoplay.prototype.stop = function() {
        if (!this._core.is('rotating')) {
            return;
        }

        window.clearTimeout(this._timeout);
        this._core.leave('rotating');
    }
    ;

    /**
	 * Stops the autoplay.
	 * @public
	 */
    Autoplay.prototype.pause = function() {
        if (!this._core.is('rotating')) {
            return;
        }

        this._paused = true;
    }
    ;

    /**
	 * Destroys the plugin.
	 */
    Autoplay.prototype.destroy = function() {
        var handler, property;

        this.stop();

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    }
    ;

    $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * Navigation Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
    'use strict';

    /**
	 * Creates the navigation plugin.
	 * @class The Navigation Plugin
	 * @param {Owl} carousel - The Owl Carousel.
	 */
    var Navigation = function(carousel) {
        /**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
        this._core = carousel;

        /**
		 * Indicates whether the plugin is initialized or not.
		 * @protected
		 * @type {Boolean}
		 */
        this._initialized = false;

        /**
		 * The current paging indexes.
		 * @protected
		 * @type {Array}
		 */
        this._pages = [];

        /**
		 * All DOM elements of the user interface.
		 * @protected
		 * @type {Object}
		 */
        this._controls = {};

        /**
		 * Markup for an indicator.
		 * @protected
		 * @type {Array.<String>}
		 */
        this._templates = [];

        /**
		 * The carousel element.
		 * @type {jQuery}
		 */
        this.$element = this._core.$element;

        /**
		 * Overridden methods of the carousel.
		 * @protected
		 * @type {Object}
		 */
        this._overrides = {
            next: this._core.next,
            prev: this._core.prev,
            to: this._core.to
        };

        /**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
        this._handlers = {
            'prepared.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.dotsData) {
                    this._templates.push('<div class="' + this._core.settings.dotClass + '">' + $(e.content).find('[data-dot]').addBack('[data-dot]').attr('data-dot') + '</div>');
                }
            }, this),
            'added.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.dotsData) {
                    this._templates.splice(e.position, 0, this._templates.pop());
                }
            }, this),
            'remove.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.dotsData) {
                    this._templates.splice(e.position, 1);
                }
            }, this),
            'changed.owl.carousel': $.proxy(function(e) {
                if (e.namespace && e.property.name == 'position') {
                    this.draw();
                }
            }, this),
            'initialized.owl.carousel': $.proxy(function(e) {
                if (e.namespace && !this._initialized) {
                    this._core.trigger('initialize', null, 'navigation');
                    this.initialize();
                    this.update();
                    this.draw();
                    this._initialized = true;
                    this._core.trigger('initialized', null, 'navigation');
                }
            }, this),
            'refreshed.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._initialized) {
                    this._core.trigger('refresh', null, 'navigation');
                    this.update();
                    this.draw();
                    this._core.trigger('refreshed', null, 'navigation');
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, Navigation.Defaults, this._core.options);

        // register event handlers
        this.$element.on(this._handlers);
    };

    /**
	 * Default options.
	 * @public
	 * @todo Rename `slideBy` to `navBy`
	 */
    Navigation.Defaults = {
        nav: false,
        navText: ['prev', 'next'],
        navSpeed: false,
        navElement: 'div',
        navContainer: false,
        navContainerClass: 'owl-nav',
        navClass: ['owl-prev', 'owl-next'],
        slideBy: 1,
        dotClass: 'owl-dot',
        dotsClass: 'owl-dots',
        dots: true,
        dotsEach: false,
        dotsData: false,
        dotsSpeed: false,
        dotsContainer: false
    };

    /**
	 * Initializes the layout of the plugin and extends the carousel.
	 * @protected
	 */
    Navigation.prototype.initialize = function() {
        var override, settings = this._core.settings;

        // create DOM structure for relative navigation
        this._controls.$relative = (settings.navContainer ? $(settings.navContainer) : $('<div>').addClass(settings.navContainerClass).appendTo(this.$element)).addClass('disabled');

        this._controls.$previous = $('<' + settings.navElement + '>').addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on('click', $.proxy(function(e) {
            this.prev(settings.navSpeed);
        }, this));
        this._controls.$next = $('<' + settings.navElement + '>').addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on('click', $.proxy(function(e) {
            this.next(settings.navSpeed);
        }, this));

        // create DOM structure for absolute navigation
        if (!settings.dotsData) {
            this._templates = [$('<div>').addClass(settings.dotClass).append($('<span>')).prop('outerHTML')];
        }

        this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer) : $('<div>').addClass(settings.dotsClass).appendTo(this.$element)).addClass('disabled');

        this._controls.$absolute.on('click', 'div', $.proxy(function(e) {
            var index = $(e.target).parent().is(this._controls.$absolute) ? $(e.target).index() : $(e.target).parent().index();

            e.preventDefault();

            this.to(index, settings.dotsSpeed);
        }, this));

        // override public methods of the carousel
        for (override in this._overrides) {
            this._core[override] = $.proxy(this[override], this);
        }
    }
    ;

    /**
	 * Destroys the plugin.
	 * @protected
	 */
    Navigation.prototype.destroy = function() {
        var handler, control, property, override;

        for (handler in this._handlers) {
            this.$element.off(handler, this._handlers[handler]);
        }
        for (control in this._controls) {
            this._controls[control].remove();
        }
        for (override in this.overides) {
            this._core[override] = this._overrides[override];
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    }
    ;

    /**
	 * Updates the internal state.
	 * @protected
	 */
    Navigation.prototype.update = function() {
        var i, j, k, lower = this._core.clones().length / 2, upper = lower + this._core.items().length, maximum = this._core.maximum(true), settings = this._core.settings, size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;

        if (settings.slideBy !== 'page') {
            settings.slideBy = Math.min(settings.slideBy, settings.items);
        }

        if (settings.dots || settings.slideBy == 'page') {
            this._pages = [];

            for (i = lower,
            j = 0,
            k = 0; i < upper; i++) {
                if (j >= size || j === 0) {
                    this._pages.push({
                        start: Math.min(maximum, i - lower),
                        end: i - lower + size - 1
                    });
                    if (Math.min(maximum, i - lower) === maximum) {
                        break;
                    }
                    j = 0,
                    ++k;
                }
                j += this._core.mergers(this._core.relative(i));
            }
        }
    }
    ;

    /**
	 * Draws the user interface.
	 * @todo The option `dotsData` wont work.
	 * @protected
	 */
    Navigation.prototype.draw = function() {
        var difference, settings = this._core.settings, disabled = this._core.items().length <= settings.items, index = this._core.relative(this._core.current()), loop = settings.loop || settings.rewind;

        this._controls.$relative.toggleClass('disabled', !settings.nav || disabled);

        if (settings.nav) {
            this._controls.$previous.toggleClass('disabled', !loop && index <= this._core.minimum(true));
            this._controls.$next.toggleClass('disabled', !loop && index >= this._core.maximum(true));
        }

        this._controls.$absolute.toggleClass('disabled', !settings.dots || disabled);

        if (settings.dots) {
            difference = this._pages.length - this._controls.$absolute.children().length;

            if (settings.dotsData && difference !== 0) {
                this._controls.$absolute.html(this._templates.join(''));
            } else if (difference > 0) {
                this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0]));
            } else if (difference < 0) {
                this._controls.$absolute.children().slice(difference).remove();
            }

            this._controls.$absolute.find('.active').removeClass('active');
            this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass('active');
        }
    }
    ;

    /**
	 * Extends event data.
	 * @protected
	 * @param {Event} event - The event object which gets thrown.
	 */
    Navigation.prototype.onTrigger = function(event) {
        var settings = this._core.settings;

        event.page = {
            index: $.inArray(this.current(), this._pages),
            count: this._pages.length,
            size: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)
        };
    }
    ;

    /**
	 * Gets the current page position of the carousel.
	 * @protected
	 * @returns {Number}
	 */
    Navigation.prototype.current = function() {
        var current = this._core.relative(this._core.current());
        return $.grep(this._pages, $.proxy(function(page, index) {
            return page.start <= current && page.end >= current;
        }, this)).pop();
    }
    ;

    /**
	 * Gets the current succesor/predecessor position.
	 * @protected
	 * @returns {Number}
	 */
    Navigation.prototype.getPosition = function(successor) {
        var position, length, settings = this._core.settings;

        if (settings.slideBy == 'page') {
            position = $.inArray(this.current(), this._pages);
            length = this._pages.length;
            successor ? ++position : --position;
            position = this._pages[((position % length) + length) % length].start;
        } else {
            position = this._core.relative(this._core.current());
            length = this._core.items().length;
            successor ? position += settings.slideBy : position -= settings.slideBy;
        }

        return position;
    }
    ;

    /**
	 * Slides to the next item or page.
	 * @public
	 * @param {Number} [speed=false] - The time in milliseconds for the transition.
	 */
    Navigation.prototype.next = function(speed) {
        $.proxy(this._overrides.to, this._core)(this.getPosition(true), speed);
    }
    ;

    /**
	 * Slides to the previous item or page.
	 * @public
	 * @param {Number} [speed=false] - The time in milliseconds for the transition.
	 */
    Navigation.prototype.prev = function(speed) {
        $.proxy(this._overrides.to, this._core)(this.getPosition(false), speed);
    }
    ;

    /**
	 * Slides to the specified item or page.
	 * @public
	 * @param {Number} position - The position of the item or page.
	 * @param {Number} [speed] - The time in milliseconds for the transition.
	 * @param {Boolean} [standard=false] - Whether to use the standard behaviour or not.
	 */
    Navigation.prototype.to = function(position, speed, standard) {
        var length;

        if (!standard && this._pages.length) {
            length = this._pages.length;
            $.proxy(this._overrides.to, this._core)(this._pages[((position % length) + length) % length].start, speed);
        } else {
            $.proxy(this._overrides.to, this._core)(position, speed);
        }
    }
    ;

    $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * Hash Plugin
 * @version 2.1.0
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {
    'use strict';

    /**
	 * Creates the hash plugin.
	 * @class The Hash Plugin
	 * @param {Owl} carousel - The Owl Carousel
	 */
    var Hash = function(carousel) {
        /**
		 * Reference to the core.
		 * @protected
		 * @type {Owl}
		 */
        this._core = carousel;

        /**
		 * Hash index for the items.
		 * @protected
		 * @type {Object}
		 */
        this._hashes = {};

        /**
		 * The carousel element.
		 * @type {jQuery}
		 */
        this.$element = this._core.$element;

        /**
		 * All event handlers.
		 * @protected
		 * @type {Object}
		 */
        this._handlers = {
            'initialized.owl.carousel': $.proxy(function(e) {
                if (e.namespace && this._core.settings.startPosition === 'URLHash') {
                    $(window).trigger('hashchange.owl.navigation');
                }
            }, this),
            'prepared.owl.carousel': $.proxy(function(e) {
                if (e.namespace) {
                    var hash = $(e.content).find('[data-hash]').addBack('[data-hash]').attr('data-hash');

                    if (!hash) {
                        return;
                    }

                    this._hashes[hash] = e.content;
                }
            }, this),
            'changed.owl.carousel': $.proxy(function(e) {
                if (e.namespace && e.property.name === 'position') {
                    var current = this._core.items(this._core.relative(this._core.current()))
                      , hash = $.map(this._hashes, function(item, hash) {
                        return item === current ? hash : null;
                    }).join();

                    if (!hash || window.location.hash.slice(1) === hash) {
                        return;
                    }

                    window.location.hash = hash;
                }
            }, this)
        };

        // set default options
        this._core.options = $.extend({}, Hash.Defaults, this._core.options);

        // register the event handlers
        this.$element.on(this._handlers);

        // register event listener for hash navigation
        $(window).on('hashchange.owl.navigation', $.proxy(function(e) {
            var hash = window.location.hash.substring(1)
              , items = this._core.$stage.children()
              , position = this._hashes[hash] && items.index(this._hashes[hash]);

            if (position === undefined || position === this._core.current()) {
                return;
            }

            this._core.to(this._core.relative(position), false, true);
        }, this));
    };

    /**
	 * Default options.
	 * @public
	 */
    Hash.Defaults = {
        URLhashListener: false
    };

    /**
	 * Destroys the plugin.
	 * @public
	 */
    Hash.prototype.destroy = function() {
        var handler, property;

        $(window).off('hashchange.owl.navigation');

        for (handler in this._handlers) {
            this._core.$element.off(handler, this._handlers[handler]);
        }
        for (property in Object.getOwnPropertyNames(this)) {
            typeof this[property] != 'function' && (this[property] = null);
        }
    }
    ;

    $.fn.owlCarousel.Constructor.Plugins.Hash = Hash;

}
)(window.Zepto || window.jQuery, window, document);

/**
 * Support Plugin
 *
 * @version 2.1.0
 * @author Vivid Planet Software GmbH
 * @author Artus Kolanowski
 * @author David Deutsch
 * @license The MIT License (MIT)
 */
;(function($, window, document, undefined) {

    var style = $('<support>').get(0).style
      , prefixes = 'Webkit Moz O ms'.split(' ')
      , events = {
        transition: {
            end: {
                WebkitTransition: 'webkitTransitionEnd',
                MozTransition: 'transitionend',
                OTransition: 'oTransitionEnd',
                transition: 'transitionend'
            }
        },
        animation: {
            end: {
                WebkitAnimation: 'webkitAnimationEnd',
                MozAnimation: 'animationend',
                OAnimation: 'oAnimationEnd',
                animation: 'animationend'
            }
        }
    }
      , tests = {
        csstransforms: function() {
            return !!test('transform');
        },
        csstransforms3d: function() {
            return !!test('perspective');
        },
        csstransitions: function() {
            return !!test('transition');
        },
        cssanimations: function() {
            return !!test('animation');
        }
    };

    function test(property, prefixed) {
        var result = false
          , upper = property.charAt(0).toUpperCase() + property.slice(1);

        $.each((property + ' ' + prefixes.join(upper + ' ') + upper).split(' '), function(i, property) {
            if (style[property] !== undefined) {
                result = prefixed ? property : true;
                return false;
            }
        });

        return result;
    }

    function prefixed(property) {
        return test(property, true);
    }

    if (tests.csstransitions()) {
        /* jshint -W053 */
        $.support.transition = new String(prefixed('transition'))
        $.support.transition.end = events.transition.end[$.support.transition];
    }

    if (tests.cssanimations()) {
        /* jshint -W053 */
        $.support.animation = new String(prefixed('animation'))
        $.support.animation.end = events.animation.end[$.support.animation];
    }

    if (tests.csstransforms()) {
        /* jshint -W053 */
        $.support.transform = new String(prefixed('transform'));
        $.support.transform3d = tests.csstransforms3d();
    }

}
)(window.Zepto || window.jQuery, window, document);

/*
     _ _      _       _
 ___| (_) ___| | __  (_)___
/ __| | |/ __| |/ /  | / __|
\__ \ | | (__|   < _ | \__ \
|___/_|_|\___|_|\_(_)/ |___/
                   |__/

 Version: 1.6.0
  Author: Ken Wheeler
 Website: http://kenwheeler.github.io
    Docs: http://kenwheeler.github.io/slick
    Repo: http://github.com/kenwheeler/slick
  Issues: http://github.com/kenwheeler/slick/issues

 */
/* global window, document, define, jQuery, setInterval, clearInterval */
(function(factory) {
    'use strict';
    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports !== 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery);
    }

}(function($) {
    'use strict';
    var Slick = window.Slick || {};

    Slick = (function() {

        var instanceUid = 0;

        function Slick(element, settings) {

            var _ = this, dataSettings;

            _.defaults = {
                accessibility: true,
                adaptiveHeight: false,
                appendArrows: $(element),
                appendDots: $(element),
                arrows: true,
                asNavFor: null,
                prevArrow: '<button type="button" data-role="none" class="slick-prev" aria-label="Previous" tabindex="0" role="button">Previous</button>',
                nextArrow: '<button type="button" data-role="none" class="slick-next" aria-label="Next" tabindex="0" role="button">Next</button>',
                autoplay: false,
                autoplaySpeed: 3000,
                centerMode: false,
                centerPadding: '50px',
                cssEase: 'ease',
                customPaging: function(slider, i) {
                    return $('<button type="button" data-role="none" role="button" tabindex="0" />').text(i + 1);
                },
                dots: false,
                dotsClass: 'slick-dots',
                draggable: true,
                easing: 'linear',
                edgeFriction: 0.35,
                fade: false,
                focusOnSelect: false,
                infinite: true,
                initialSlide: 0,
                lazyLoad: 'ondemand',
                mobileFirst: false,
                pauseOnHover: true,
                pauseOnFocus: true,
                pauseOnDotsHover: false,
                respondTo: 'window',
                responsive: null,
                rows: 1,
                rtl: false,
                slide: '',
                slidesPerRow: 1,
                slidesToShow: 1,
                slidesToScroll: 1,
                speed: 500,
                swipe: true,
                swipeToSlide: false,
                touchMove: true,
                touchThreshold: 5,
                useCSS: true,
                useTransform: true,
                variableWidth: false,
                vertical: false,
                verticalSwiping: false,
                waitForAnimate: true,
                zIndex: 1000
            };

            _.initials = {
                animating: false,
                dragging: false,
                autoPlayTimer: null,
                currentDirection: 0,
                currentLeft: null,
                currentSlide: 0,
                direction: 1,
                $dots: null,
                listWidth: null,
                listHeight: null,
                loadIndex: 0,
                $nextArrow: null,
                $prevArrow: null,
                slideCount: null,
                slideWidth: null,
                $slideTrack: null,
                $slides: null,
                sliding: false,
                slideOffset: 0,
                swipeLeft: null,
                $list: null,
                touchObject: {},
                transformsEnabled: false,
                unslicked: false
            };

            $.extend(_, _.initials);

            _.activeBreakpoint = null;
            _.animType = null;
            _.animProp = null;
            _.breakpoints = [];
            _.breakpointSettings = [];
            _.cssTransitions = false;
            _.focussed = false;
            _.interrupted = false;
            _.hidden = 'hidden';
            _.paused = true;
            _.positionProp = null;
            _.respondTo = null;
            _.rowCount = 1;
            _.shouldClick = true;
            _.$slider = $(element);
            _.$slidesCache = null;
            _.transformType = null;
            _.transitionType = null;
            _.visibilityChange = 'visibilitychange';
            _.windowWidth = 0;
            _.windowTimer = null;

            dataSettings = $(element).data('slick') || {};

            _.options = $.extend({}, _.defaults, settings, dataSettings);

            _.currentSlide = _.options.initialSlide;

            _.originalSettings = _.options;

            if (typeof document.mozHidden !== 'undefined') {
                _.hidden = 'mozHidden';
                _.visibilityChange = 'mozvisibilitychange';
            } else if (typeof document.webkitHidden !== 'undefined') {
                _.hidden = 'webkitHidden';
                _.visibilityChange = 'webkitvisibilitychange';
            }

            _.autoPlay = $.proxy(_.autoPlay, _);
            _.autoPlayClear = $.proxy(_.autoPlayClear, _);
            _.autoPlayIterator = $.proxy(_.autoPlayIterator, _);
            _.changeSlide = $.proxy(_.changeSlide, _);
            _.clickHandler = $.proxy(_.clickHandler, _);
            _.selectHandler = $.proxy(_.selectHandler, _);
            _.setPosition = $.proxy(_.setPosition, _);
            _.swipeHandler = $.proxy(_.swipeHandler, _);
            _.dragHandler = $.proxy(_.dragHandler, _);
            _.keyHandler = $.proxy(_.keyHandler, _);

            _.instanceUid = instanceUid++;

            // A simple way to check for HTML strings
            // Strict HTML recognition (must start with <)
            // Extracted from jQuery v1.11 source
            _.htmlExpr = /^(?:\s*(<[\w\W]+>)[^>]*)$/;

            _.registerBreakpoints();
            _.init(true);

        }

        return Slick;

    }());

    Slick.prototype.activateADA = function() {
        var _ = this;

        _.$slideTrack.find('.slick-active').attr({
            'aria-hidden': 'false'
        }).find('a, input, button, select').attr({
            'tabindex': '0'
        });

    }
    ;

    Slick.prototype.addSlide = Slick.prototype.slickAdd = function(markup, index, addBefore) {

        var _ = this;

        if (typeof (index) === 'boolean') {
            addBefore = index;
            index = null;
        } else if (index < 0 || (index >= _.slideCount)) {
            return false;
        }

        _.unload();

        if (typeof (index) === 'number') {
            if (index === 0 && _.$slides.length === 0) {
                $(markup).appendTo(_.$slideTrack);
            } else if (addBefore) {
                $(markup).insertBefore(_.$slides.eq(index));
            } else {
                $(markup).insertAfter(_.$slides.eq(index));
            }
        } else {
            if (addBefore === true) {
                $(markup).prependTo(_.$slideTrack);
            } else {
                $(markup).appendTo(_.$slideTrack);
            }
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index);
        });

        _.$slidesCache = _.$slides;

        _.reinit();

    }
    ;

    Slick.prototype.animateHeight = function() {
        var _ = this;
        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.animate({
                height: targetHeight
            }, _.options.speed);
        }
    }
    ;

    Slick.prototype.animateSlide = function(targetLeft, callback) {

        var animProps = {}
          , _ = this;

        _.animateHeight();

        if (_.options.rtl === true && _.options.vertical === false) {
            targetLeft = -targetLeft;
        }
        if (_.transformsEnabled === false) {
            if (_.options.vertical === false) {
                _.$slideTrack.animate({
                    left: targetLeft
                }, _.options.speed, _.options.easing, callback);
            } else {
                _.$slideTrack.animate({
                    top: targetLeft
                }, _.options.speed, _.options.easing, callback);
            }

        } else {

            if (_.cssTransitions === false) {
                if (_.options.rtl === true) {
                    _.currentLeft = -(_.currentLeft);
                }
                $({
                    animStart: _.currentLeft
                }).animate({
                    animStart: targetLeft
                }, {
                    duration: _.options.speed,
                    easing: _.options.easing,
                    step: function(now) {
                        now = Math.ceil(now);
                        if (_.options.vertical === false) {
                            animProps[_.animType] = 'translate(' + now + 'px, 0px)';
                            _.$slideTrack.css(animProps);
                        } else {
                            animProps[_.animType] = 'translate(0px,' + now + 'px)';
                            _.$slideTrack.css(animProps);
                        }
                    },
                    complete: function() {
                        if (callback) {
                            callback.call();
                        }
                    }
                });

            } else {

                _.applyTransition();
                targetLeft = Math.ceil(targetLeft);

                if (_.options.vertical === false) {
                    animProps[_.animType] = 'translate3d(' + targetLeft + 'px, 0px, 0px)';
                } else {
                    animProps[_.animType] = 'translate3d(0px,' + targetLeft + 'px, 0px)';
                }
                _.$slideTrack.css(animProps);

                if (callback) {
                    setTimeout(function() {

                        _.disableTransition();

                        callback.call();
                    }, _.options.speed);
                }

            }

        }

    }
    ;

    Slick.prototype.getNavTarget = function() {

        var _ = this
          , asNavFor = _.options.asNavFor;

        if (asNavFor && asNavFor !== null) {
            asNavFor = $(asNavFor).not(_.$slider);
        }

        return asNavFor;

    }
    ;

    Slick.prototype.asNavFor = function(index) {

        var _ = this
          , asNavFor = _.getNavTarget();

        if (asNavFor !== null && typeof asNavFor === 'object') {
            asNavFor.each(function() {
                var target = $(this).slick('getSlick');
                if (!target.unslicked) {
                    target.slideHandler(index, true);
                }
            });
        }

    }
    ;

    Slick.prototype.applyTransition = function(slide) {

        var _ = this
          , transition = {};

        if (_.options.fade === false) {
            transition[_.transitionType] = _.transformType + ' ' + _.options.speed + 'ms ' + _.options.cssEase;
        } else {
            transition[_.transitionType] = 'opacity ' + _.options.speed + 'ms ' + _.options.cssEase;
        }

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    }
    ;

    Slick.prototype.autoPlay = function() {

        var _ = this;

        _.autoPlayClear();

        if (_.slideCount > _.options.slidesToShow) {
            _.autoPlayTimer = setInterval(_.autoPlayIterator, _.options.autoplaySpeed);
        }

    }
    ;

    Slick.prototype.autoPlayClear = function() {

        var _ = this;

        if (_.autoPlayTimer) {
            clearInterval(_.autoPlayTimer);
        }

    }
    ;

    Slick.prototype.autoPlayIterator = function() {

        var _ = this
          , slideTo = _.currentSlide + _.options.slidesToScroll;

        if (!_.paused && !_.interrupted && !_.focussed) {

            if (_.options.infinite === false) {

                if (_.direction === 1 && (_.currentSlide + 1) === (_.slideCount - 1)) {
                    _.direction = 0;
                }
                else if (_.direction === 0) {

                    slideTo = _.currentSlide - _.options.slidesToScroll;

                    if (_.currentSlide - 1 === 0) {
                        _.direction = 1;
                    }

                }

            }

            _.slideHandler(slideTo);

        }

    }
    ;

    Slick.prototype.buildArrows = function() {

        var _ = this;

        if (_.options.arrows === true) {

            _.$prevArrow = $(_.options.prevArrow).addClass('slick-arrow');
            _.$nextArrow = $(_.options.nextArrow).addClass('slick-arrow');

            if (_.slideCount > _.options.slidesToShow) {

                _.$prevArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');
                _.$nextArrow.removeClass('slick-hidden').removeAttr('aria-hidden tabindex');

                if (_.htmlExpr.test(_.options.prevArrow)) {
                    _.$prevArrow.prependTo(_.options.appendArrows);
                }

                if (_.htmlExpr.test(_.options.nextArrow)) {
                    _.$nextArrow.appendTo(_.options.appendArrows);
                }

                if (_.options.infinite !== true) {
                    _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                }

            } else {

                _.$prevArrow.add(_.$nextArrow)
                .addClass('slick-hidden').attr({
                    'aria-disabled': 'true',
                    'tabindex': '-1'
                });

            }

        }

    }
    ;

    Slick.prototype.buildDots = function() {

        var _ = this, i, dot;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$slider.addClass('slick-dotted');

            dot = $('<ul />').addClass(_.options.dotsClass);

            for (i = 0; i <= _.getDotCount(); i += 1) {
                dot.append($('<li />').append(_.options.customPaging.call(this, _, i)));
            }

            _.$dots = dot.appendTo(_.options.appendDots);

            _.$dots.find('li').first().addClass('slick-active').attr('aria-hidden', 'false');

        }

    }
    ;

    Slick.prototype.buildOut = function() {

        var _ = this;

        _.$slides = _.$slider.children(_.options.slide + ':not(.slick-cloned)').addClass('slick-slide');

        _.slideCount = _.$slides.length;

        _.$slides.each(function(index, element) {
            $(element).attr('data-slick-index', index).data('originalStyling', $(element).attr('style') || '');
        });

        _.$slider.addClass('slick-slider');

        _.$slideTrack = (_.slideCount === 0) ? $('<div class="slick-track"/>').appendTo(_.$slider) : _.$slides.wrapAll('<div class="slick-track"/>').parent();

        _.$list = _.$slideTrack.wrap('<div aria-live="polite" class="slick-list"/>').parent();
        _.$slideTrack.css('opacity', 0);

        if (_.options.centerMode === true || _.options.swipeToSlide === true) {
            _.options.slidesToScroll = 1;
        }

        $('img[data-lazy]', _.$slider).not('[src]').addClass('slick-loading');

        _.setupInfinite();

        _.buildArrows();

        _.buildDots();

        _.updateDots();

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        if (_.options.draggable === true) {
            _.$list.addClass('draggable');
        }

    }
    ;

    Slick.prototype.buildRows = function() {

        var _ = this, a, b, c, newSlides, numOfSlides, originalSlides, slidesPerSection;

        newSlides = document.createDocumentFragment();
        originalSlides = _.$slider.children();

        if (_.options.rows > 1) {

            slidesPerSection = _.options.slidesPerRow * _.options.rows;
            numOfSlides = Math.ceil(originalSlides.length / slidesPerSection);

            for (a = 0; a < numOfSlides; a++) {
                var slide = document.createElement('div');
                for (b = 0; b < _.options.rows; b++) {
                    var row = document.createElement('div');
                    for (c = 0; c < _.options.slidesPerRow; c++) {
                        var target = (a * slidesPerSection + ((b * _.options.slidesPerRow) + c));
                        if (originalSlides.get(target)) {
                            row.appendChild(originalSlides.get(target));
                        }
                    }
                    slide.appendChild(row);
                }
                newSlides.appendChild(slide);
            }

            _.$slider.empty().append(newSlides);
            _.$slider.children().children().children().css({
                'width': (100 / _.options.slidesPerRow) + '%',
                'display': 'inline-block'
            });

        }

    }
    ;

    Slick.prototype.checkResponsive = function(initial, forceUpdate) {

        var _ = this, breakpoint, targetBreakpoint, respondToWidth, triggerBreakpoint = false;
        var sliderWidth = _.$slider.width();
        var windowWidth = window.innerWidth || $(window).width();

        if (_.respondTo === 'window') {
            respondToWidth = windowWidth;
        } else if (_.respondTo === 'slider') {
            respondToWidth = sliderWidth;
        } else if (_.respondTo === 'min') {
            respondToWidth = Math.min(windowWidth, sliderWidth);
        }

        if (_.options.responsive && _.options.responsive.length && _.options.responsive !== null) {

            targetBreakpoint = null;

            for (breakpoint in _.breakpoints) {
                if (_.breakpoints.hasOwnProperty(breakpoint)) {
                    if (_.originalSettings.mobileFirst === false) {
                        if (respondToWidth < _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    } else {
                        if (respondToWidth > _.breakpoints[breakpoint]) {
                            targetBreakpoint = _.breakpoints[breakpoint];
                        }
                    }
                }
            }

            if (targetBreakpoint !== null) {
                if (_.activeBreakpoint !== null) {
                    if (targetBreakpoint !== _.activeBreakpoint || forceUpdate) {
                        _.activeBreakpoint = targetBreakpoint;
                        if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                            _.unslick(targetBreakpoint);
                        } else {
                            _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                            if (initial === true) {
                                _.currentSlide = _.options.initialSlide;
                            }
                            _.refresh(initial);
                        }
                        triggerBreakpoint = targetBreakpoint;
                    }
                } else {
                    _.activeBreakpoint = targetBreakpoint;
                    if (_.breakpointSettings[targetBreakpoint] === 'unslick') {
                        _.unslick(targetBreakpoint);
                    } else {
                        _.options = $.extend({}, _.originalSettings, _.breakpointSettings[targetBreakpoint]);
                        if (initial === true) {
                            _.currentSlide = _.options.initialSlide;
                        }
                        _.refresh(initial);
                    }
                    triggerBreakpoint = targetBreakpoint;
                }
            } else {
                if (_.activeBreakpoint !== null) {
                    _.activeBreakpoint = null;
                    _.options = _.originalSettings;
                    if (initial === true) {
                        _.currentSlide = _.options.initialSlide;
                    }
                    _.refresh(initial);
                    triggerBreakpoint = targetBreakpoint;
                }
            }

            // only trigger breakpoints during an actual break. not on initialize.
            if (!initial && triggerBreakpoint !== false) {
                _.$slider.trigger('breakpoint', [_, triggerBreakpoint]);
            }
        }

    }
    ;

    Slick.prototype.changeSlide = function(event, dontAnimate) {

        var _ = this, $target = $(event.currentTarget), indexOffset, slideOffset, unevenOffset;

        // If target is a link, prevent default action.
        if ($target.is('a')) {
            event.preventDefault();
        }

        // If target is not the <li> element (ie: a child), find the <li>.
        if (!$target.is('li')) {
            $target = $target.closest('li');
        }

        unevenOffset = (_.slideCount % _.options.slidesToScroll !== 0);
        indexOffset = unevenOffset ? 0 : (_.slideCount - _.currentSlide) % _.options.slidesToScroll;

        switch (event.data.message) {

        case 'previous':
            slideOffset = indexOffset === 0 ? _.options.slidesToScroll : _.options.slidesToShow - indexOffset;
            if (_.slideCount > _.options.slidesToShow) {
                _.slideHandler(_.currentSlide - slideOffset, false, dontAnimate);
            }
            break;

        case 'next':
            slideOffset = indexOffset === 0 ? _.options.slidesToScroll : indexOffset;
            if (_.slideCount > _.options.slidesToShow) {
                _.slideHandler(_.currentSlide + slideOffset, false, dontAnimate);
            }
            break;

        case 'index':
            var index = event.data.index === 0 ? 0 : event.data.index || $target.index() * _.options.slidesToScroll;

            _.slideHandler(_.checkNavigable(index), false, dontAnimate);
            $target.children().trigger('focus');
            break;

        default:
            return;
        }

    }
    ;

    Slick.prototype.checkNavigable = function(index) {

        var _ = this, navigables, prevNavigable;

        navigables = _.getNavigableIndexes();
        prevNavigable = 0;
        if (index > navigables[navigables.length - 1]) {
            index = navigables[navigables.length - 1];
        } else {
            for (var n in navigables) {
                if (index < navigables[n]) {
                    index = prevNavigable;
                    break;
                }
                prevNavigable = navigables[n];
            }
        }

        return index;
    }
    ;

    Slick.prototype.cleanUpEvents = function() {

        var _ = this;

        if (_.options.dots && _.$dots !== null) {

            $('li', _.$dots).off('click.slick', _.changeSlide).off('mouseenter.slick', $.proxy(_.interrupt, _, true)).off('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

        _.$slider.off('focus.slick blur.slick');

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow && _.$prevArrow.off('click.slick', _.changeSlide);
            _.$nextArrow && _.$nextArrow.off('click.slick', _.changeSlide);
        }

        _.$list.off('touchstart.slick mousedown.slick', _.swipeHandler);
        _.$list.off('touchmove.slick mousemove.slick', _.swipeHandler);
        _.$list.off('touchend.slick mouseup.slick', _.swipeHandler);
        _.$list.off('touchcancel.slick mouseleave.slick', _.swipeHandler);

        _.$list.off('click.slick', _.clickHandler);

        $(document).off(_.visibilityChange, _.visibility);

        _.cleanUpSlideEvents();

        if (_.options.accessibility === true) {
            _.$list.off('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().off('click.slick', _.selectHandler);
        }

        $(window).off('orientationchange.slick.slick-' + _.instanceUid, _.orientationChange);

        $(window).off('resize.slick.slick-' + _.instanceUid, _.resize);

        $('[draggable!=true]', _.$slideTrack).off('dragstart', _.preventDefault);

        $(window).off('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).off('ready.slick.slick-' + _.instanceUid, _.setPosition);

    }
    ;

    Slick.prototype.cleanUpSlideEvents = function() {

        var _ = this;

        _.$list.off('mouseenter.slick', $.proxy(_.interrupt, _, true));
        _.$list.off('mouseleave.slick', $.proxy(_.interrupt, _, false));

    }
    ;

    Slick.prototype.cleanUpRows = function() {

        var _ = this, originalSlides;

        if (_.options.rows > 1) {
            originalSlides = _.$slides.children().children();
            originalSlides.removeAttr('style');
            _.$slider.empty().append(originalSlides);
        }

    }
    ;

    Slick.prototype.clickHandler = function(event) {

        var _ = this;

        if (_.shouldClick === false) {
            event.stopImmediatePropagation();
            event.stopPropagation();
            event.preventDefault();
        }

    }
    ;

    Slick.prototype.destroy = function(refresh) {

        var _ = this;

        _.autoPlayClear();

        _.touchObject = {};

        _.cleanUpEvents();

        $('.slick-cloned', _.$slider).detach();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.$prevArrow.length) {

            _.$prevArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

            if (_.htmlExpr.test(_.options.prevArrow)) {
                _.$prevArrow.remove();
            }
        }

        if (_.$nextArrow && _.$nextArrow.length) {

            _.$nextArrow.removeClass('slick-disabled slick-arrow slick-hidden').removeAttr('aria-hidden aria-disabled tabindex').css('display', '');

            if (_.htmlExpr.test(_.options.nextArrow)) {
                _.$nextArrow.remove();
            }

        }

        if (_.$slides) {

            _.$slides.removeClass('slick-slide slick-active slick-center slick-visible slick-current').removeAttr('aria-hidden').removeAttr('data-slick-index').each(function() {
                $(this).attr('style', $(this).data('originalStyling'));
            });

            _.$slideTrack.children(this.options.slide).detach();

            _.$slideTrack.detach();

            _.$list.detach();

            _.$slider.append(_.$slides);
        }

        _.cleanUpRows();

        _.$slider.removeClass('slick-slider');
        _.$slider.removeClass('slick-initialized');
        _.$slider.removeClass('slick-dotted');

        _.unslicked = true;

        if (!refresh) {
            _.$slider.trigger('destroy', [_]);
        }

    }
    ;

    Slick.prototype.disableTransition = function(slide) {

        var _ = this
          , transition = {};

        transition[_.transitionType] = '';

        if (_.options.fade === false) {
            _.$slideTrack.css(transition);
        } else {
            _.$slides.eq(slide).css(transition);
        }

    }
    ;

    Slick.prototype.fadeSlide = function(slideIndex, callback) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).css({
                zIndex: _.options.zIndex
            });

            _.$slides.eq(slideIndex).animate({
                opacity: 1
            }, _.options.speed, _.options.easing, callback);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 1,
                zIndex: _.options.zIndex
            });

            if (callback) {
                setTimeout(function() {

                    _.disableTransition(slideIndex);

                    callback.call();
                }, _.options.speed);
            }

        }

    }
    ;

    Slick.prototype.fadeSlideOut = function(slideIndex) {

        var _ = this;

        if (_.cssTransitions === false) {

            _.$slides.eq(slideIndex).animate({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            }, _.options.speed, _.options.easing);

        } else {

            _.applyTransition(slideIndex);

            _.$slides.eq(slideIndex).css({
                opacity: 0,
                zIndex: _.options.zIndex - 2
            });

        }

    }
    ;

    Slick.prototype.filterSlides = Slick.prototype.slickFilter = function(filter) {

        var _ = this;

        if (filter !== null) {

            _.$slidesCache = _.$slides;

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.filter(filter).appendTo(_.$slideTrack);

            _.reinit();

        }

    }
    ;

    Slick.prototype.focusHandler = function() {

        var _ = this;

        _.$slider.off('focus.slick blur.slick').on('focus.slick blur.slick', '*:not(.slick-arrow)', function(event) {

            event.stopImmediatePropagation();
            var $sf = $(this);

            setTimeout(function() {

                if (_.options.pauseOnFocus) {
                    _.focussed = $sf.is(':focus');
                    _.autoPlay();
                }

            }, 0);

        });
    }
    ;

    Slick.prototype.getCurrent = Slick.prototype.slickCurrentSlide = function() {

        var _ = this;
        return _.currentSlide;

    }
    ;

    Slick.prototype.getDotCount = function() {

        var _ = this;

        var breakPoint = 0;
        var counter = 0;
        var pagerQty = 0;

        if (_.options.infinite === true) {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        } else if (_.options.centerMode === true) {
            pagerQty = _.slideCount;
        } else if (!_.options.asNavFor) {
            pagerQty = 1 + Math.ceil((_.slideCount - _.options.slidesToShow) / _.options.slidesToScroll);
        } else {
            while (breakPoint < _.slideCount) {
                ++pagerQty;
                breakPoint = counter + _.options.slidesToScroll;
                counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
            }
        }

        return pagerQty - 1;

    }
    ;

    Slick.prototype.getLeft = function(slideIndex) {

        var _ = this, targetLeft, verticalHeight, verticalOffset = 0, targetSlide;

        _.slideOffset = 0;
        verticalHeight = _.$slides.first().outerHeight(true);

        if (_.options.infinite === true) {
            if (_.slideCount > _.options.slidesToShow) {
                _.slideOffset = (_.slideWidth * _.options.slidesToShow) * -1;
                verticalOffset = (verticalHeight * _.options.slidesToShow) * -1;
            }
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                if (slideIndex + _.options.slidesToScroll > _.slideCount && _.slideCount > _.options.slidesToShow) {
                    if (slideIndex > _.slideCount) {
                        _.slideOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * _.slideWidth) * -1;
                        verticalOffset = ((_.options.slidesToShow - (slideIndex - _.slideCount)) * verticalHeight) * -1;
                    } else {
                        _.slideOffset = ((_.slideCount % _.options.slidesToScroll) * _.slideWidth) * -1;
                        verticalOffset = ((_.slideCount % _.options.slidesToScroll) * verticalHeight) * -1;
                    }
                }
            }
        } else {
            if (slideIndex + _.options.slidesToShow > _.slideCount) {
                _.slideOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * _.slideWidth;
                verticalOffset = ((slideIndex + _.options.slidesToShow) - _.slideCount) * verticalHeight;
            }
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.slideOffset = 0;
            verticalOffset = 0;
        }

        if (_.options.centerMode === true && _.options.infinite === true) {
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2) - _.slideWidth;
        } else if (_.options.centerMode === true) {
            _.slideOffset = 0;
            _.slideOffset += _.slideWidth * Math.floor(_.options.slidesToShow / 2);
        }

        if (_.options.vertical === false) {
            targetLeft = ((slideIndex * _.slideWidth) * -1) + _.slideOffset;
        } else {
            targetLeft = ((slideIndex * verticalHeight) * -1) + verticalOffset;
        }

        if (_.options.variableWidth === true) {

            if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
            } else {
                targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow);
            }

            if (_.options.rtl === true) {
                if (targetSlide[0]) {
                    targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                } else {
                    targetLeft = 0;
                }
            } else {
                targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
            }

            if (_.options.centerMode === true) {
                if (_.slideCount <= _.options.slidesToShow || _.options.infinite === false) {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex);
                } else {
                    targetSlide = _.$slideTrack.children('.slick-slide').eq(slideIndex + _.options.slidesToShow + 1);
                }

                if (_.options.rtl === true) {
                    if (targetSlide[0]) {
                        targetLeft = (_.$slideTrack.width() - targetSlide[0].offsetLeft - targetSlide.width()) * -1;
                    } else {
                        targetLeft = 0;
                    }
                } else {
                    targetLeft = targetSlide[0] ? targetSlide[0].offsetLeft * -1 : 0;
                }

                targetLeft += (_.$list.width() - targetSlide.outerWidth()) / 2;
            }
        }

        return targetLeft;

    }
    ;

    Slick.prototype.getOption = Slick.prototype.slickGetOption = function(option) {

        var _ = this;

        return _.options[option];

    }
    ;

    Slick.prototype.getNavigableIndexes = function() {

        var _ = this, breakPoint = 0, counter = 0, indexes = [], max;

        if (_.options.infinite === false) {
            max = _.slideCount;
        } else {
            breakPoint = _.options.slidesToScroll * -1;
            counter = _.options.slidesToScroll * -1;
            max = _.slideCount * 2;
        }

        while (breakPoint < max) {
            indexes.push(breakPoint);
            breakPoint = counter + _.options.slidesToScroll;
            counter += _.options.slidesToScroll <= _.options.slidesToShow ? _.options.slidesToScroll : _.options.slidesToShow;
        }

        return indexes;

    }
    ;

    Slick.prototype.getSlick = function() {

        return this;

    }
    ;

    Slick.prototype.getSlideCount = function() {

        var _ = this, slidesTraversed, swipedSlide, centerOffset;

        centerOffset = _.options.centerMode === true ? _.slideWidth * Math.floor(_.options.slidesToShow / 2) : 0;

        if (_.options.swipeToSlide === true) {
            _.$slideTrack.find('.slick-slide').each(function(index, slide) {
                if (slide.offsetLeft - centerOffset + ($(slide).outerWidth() / 2) > (_.swipeLeft * -1)) {
                    swipedSlide = slide;
                    return false;
                }
            });

            slidesTraversed = Math.abs($(swipedSlide).attr('data-slick-index') - _.currentSlide) || 1;

            return slidesTraversed;

        } else {
            return _.options.slidesToScroll;
        }

    }
    ;

    Slick.prototype.goTo = Slick.prototype.slickGoTo = function(slide, dontAnimate) {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'index',
                index: parseInt(slide)
            }
        }, dontAnimate);

    }
    ;

    Slick.prototype.init = function(creation) {

        var _ = this;

        if (!$(_.$slider).hasClass('slick-initialized')) {

            $(_.$slider).addClass('slick-initialized');

            _.buildRows();
            _.buildOut();
            _.setProps();
            _.startLoad();
            _.loadSlider();
            _.initializeEvents();
            _.updateArrows();
            _.updateDots();
            _.checkResponsive(true);
            _.focusHandler();

        }

        if (creation) {
            _.$slider.trigger('init', [_]);
        }

        if (_.options.accessibility === true) {
            _.initADA();
        }

        if (_.options.autoplay) {

            _.paused = false;
            _.autoPlay();

        }

    }
    ;

    Slick.prototype.initADA = function() {
        var _ = this;
        _.$slides.add(_.$slideTrack.find('.slick-cloned')).attr({
            'aria-hidden': 'true',
            'tabindex': '-1'
        }).find('a, input, button, select').attr({
            'tabindex': '-1'
        });

        _.$slideTrack.attr('role', 'listbox');

        _.$slides.not(_.$slideTrack.find('.slick-cloned')).each(function(i) {
            $(this).attr({
                'role': 'option',
                'aria-describedby': 'slick-slide' + _.instanceUid + i + ''
            });
        });

        if (_.$dots !== null) {
            _.$dots.attr('role', 'tablist').find('li').each(function(i) {
                $(this).attr({
                    'role': 'presentation',
                    'aria-selected': 'false',
                    'aria-controls': 'navigation' + _.instanceUid + i + '',
                    'id': 'slick-slide' + _.instanceUid + i + ''
                });
            }).first().attr('aria-selected', 'true').end().find('button').attr('role', 'button').end().closest('div').attr('role', 'toolbar');
        }
        _.activateADA();

    }
    ;

    Slick.prototype.initArrowEvents = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {
            _.$prevArrow.off('click.slick').on('click.slick', {
                message: 'previous'
            }, _.changeSlide);
            _.$nextArrow.off('click.slick').on('click.slick', {
                message: 'next'
            }, _.changeSlide);
        }

    }
    ;

    Slick.prototype.initDotEvents = function() {

        var _ = this;

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {
            $('li', _.$dots).on('click.slick', {
                message: 'index'
            }, _.changeSlide);
        }

        if (_.options.dots === true && _.options.pauseOnDotsHover === true) {

            $('li', _.$dots).on('mouseenter.slick', $.proxy(_.interrupt, _, true)).on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    }
    ;

    Slick.prototype.initSlideEvents = function() {

        var _ = this;

        if (_.options.pauseOnHover) {

            _.$list.on('mouseenter.slick', $.proxy(_.interrupt, _, true));
            _.$list.on('mouseleave.slick', $.proxy(_.interrupt, _, false));

        }

    }
    ;

    Slick.prototype.initializeEvents = function() {

        var _ = this;

        _.initArrowEvents();

        _.initDotEvents();
        _.initSlideEvents();

        _.$list.on('touchstart.slick mousedown.slick', {
            action: 'start'
        }, _.swipeHandler);
        _.$list.on('touchmove.slick mousemove.slick', {
            action: 'move'
        }, _.swipeHandler);
        _.$list.on('touchend.slick mouseup.slick', {
            action: 'end'
        }, _.swipeHandler);
        _.$list.on('touchcancel.slick mouseleave.slick', {
            action: 'end'
        }, _.swipeHandler);

        _.$list.on('click.slick', _.clickHandler);

        $(document).on(_.visibilityChange, $.proxy(_.visibility, _));

        if (_.options.accessibility === true) {
            _.$list.on('keydown.slick', _.keyHandler);
        }

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        $(window).on('orientationchange.slick.slick-' + _.instanceUid, $.proxy(_.orientationChange, _));

        $(window).on('resize.slick.slick-' + _.instanceUid, $.proxy(_.resize, _));

        $('[draggable!=true]', _.$slideTrack).on('dragstart', _.preventDefault);

        $(window).on('load.slick.slick-' + _.instanceUid, _.setPosition);
        $(document).on('ready.slick.slick-' + _.instanceUid, _.setPosition);

    }
    ;

    Slick.prototype.initUI = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.show();
            _.$nextArrow.show();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.show();

        }

    }
    ;

    Slick.prototype.keyHandler = function(event) {

        var _ = this;
        //Dont slide if the cursor is inside the form fields and arrow keys are pressed
        if (!event.target.tagName.match('TEXTAREA|INPUT|SELECT')) {
            if (event.keyCode === 37 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'next' : 'previous'
                    }
                });
            } else if (event.keyCode === 39 && _.options.accessibility === true) {
                _.changeSlide({
                    data: {
                        message: _.options.rtl === true ? 'previous' : 'next'
                    }
                });
            }
        }

    }
    ;

    Slick.prototype.lazyLoad = function() {

        var _ = this, loadRange, cloneRange, rangeStart, rangeEnd;

        function loadImages(imagesScope) {

            $('img[data-lazy]', imagesScope).each(function() {

                var image = $(this)
                  , imageSource = $(this).attr('data-lazy')
                  , imageToLoad = document.createElement('img');

                imageToLoad.onload = function() {

                    image.animate({
                        opacity: 0
                    }, 100, function() {
                        image.attr('src', imageSource).animate({
                            opacity: 1
                        }, 200, function() {
                            image.removeAttr('data-lazy').removeClass('slick-loading');
                        });
                        _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                    });

                }
                ;

                imageToLoad.onerror = function() {

                    image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);

                }
                ;

                imageToLoad.src = imageSource;

            });

        }

        if (_.options.centerMode === true) {
            if (_.options.infinite === true) {
                rangeStart = _.currentSlide + (_.options.slidesToShow / 2 + 1);
                rangeEnd = rangeStart + _.options.slidesToShow + 2;
            } else {
                rangeStart = Math.max(0, _.currentSlide - (_.options.slidesToShow / 2 + 1));
                rangeEnd = 2 + (_.options.slidesToShow / 2 + 1) + _.currentSlide;
            }
        } else {
            rangeStart = _.options.infinite ? _.options.slidesToShow + _.currentSlide : _.currentSlide;
            rangeEnd = Math.ceil(rangeStart + _.options.slidesToShow);
            if (_.options.fade === true) {
                if (rangeStart > 0)
                    rangeStart--;
                if (rangeEnd <= _.slideCount)
                    rangeEnd++;
            }
        }

        loadRange = _.$slider.find('.slick-slide').slice(rangeStart, rangeEnd);
        loadImages(loadRange);

        if (_.slideCount <= _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-slide');
            loadImages(cloneRange);
        } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow) {
            cloneRange = _.$slider.find('.slick-cloned').slice(0, _.options.slidesToShow);
            loadImages(cloneRange);
        } else if (_.currentSlide === 0) {
            cloneRange = _.$slider.find('.slick-cloned').slice(_.options.slidesToShow * -1);
            loadImages(cloneRange);
        }

    }
    ;

    Slick.prototype.loadSlider = function() {

        var _ = this;

        _.setPosition();

        _.$slideTrack.css({
            opacity: 1
        });

        _.$slider.removeClass('slick-loading');

        _.initUI();

        if (_.options.lazyLoad === 'progressive') {
            _.progressiveLazyLoad();
        }

    }
    ;

    Slick.prototype.next = Slick.prototype.slickNext = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'next'
            }
        });

    }
    ;

    Slick.prototype.orientationChange = function() {

        var _ = this;

        _.checkResponsive();
        _.setPosition();

    }
    ;

    Slick.prototype.pause = Slick.prototype.slickPause = function() {

        var _ = this;

        _.autoPlayClear();
        _.paused = true;

    }
    ;

    Slick.prototype.play = Slick.prototype.slickPlay = function() {

        var _ = this;

        _.autoPlay();
        _.options.autoplay = true;
        _.paused = false;
        _.focussed = false;
        _.interrupted = false;

    }
    ;

    Slick.prototype.postSlide = function(index) {

        var _ = this;

        if (!_.unslicked) {

            _.$slider.trigger('afterChange', [_, index]);

            _.animating = false;

            _.setPosition();

            _.swipeLeft = null;

            if (_.options.autoplay) {
                _.autoPlay();
            }

            if (_.options.accessibility === true) {
                _.initADA();
            }

        }

    }
    ;

    Slick.prototype.prev = Slick.prototype.slickPrev = function() {

        var _ = this;

        _.changeSlide({
            data: {
                message: 'previous'
            }
        });

    }
    ;

    Slick.prototype.preventDefault = function(event) {

        event.preventDefault();

    }
    ;

    Slick.prototype.progressiveLazyLoad = function(tryCount) {

        tryCount = tryCount || 1;

        var _ = this, $imgsToLoad = $('img[data-lazy]', _.$slider), image, imageSource, imageToLoad;

        if ($imgsToLoad.length) {

            image = $imgsToLoad.first();
            imageSource = image.attr('data-lazy');
            imageToLoad = document.createElement('img');

            imageToLoad.onload = function() {

                image.attr('src', imageSource).removeAttr('data-lazy').removeClass('slick-loading');

                if (_.options.adaptiveHeight === true) {
                    _.setPosition();
                }

                _.$slider.trigger('lazyLoaded', [_, image, imageSource]);
                _.progressiveLazyLoad();

            }
            ;

            imageToLoad.onerror = function() {

                if (tryCount < 3) {

                    /**
                     * try to load the image 3 times,
                     * leave a slight delay so we don't get
                     * servers blocking the request.
                     */
                    setTimeout(function() {
                        _.progressiveLazyLoad(tryCount + 1);
                    }, 500);

                } else {

                    image.removeAttr('data-lazy').removeClass('slick-loading').addClass('slick-lazyload-error');

                    _.$slider.trigger('lazyLoadError', [_, image, imageSource]);

                    _.progressiveLazyLoad();

                }

            }
            ;

            imageToLoad.src = imageSource;

        } else {

            _.$slider.trigger('allImagesLoaded', [_]);

        }

    }
    ;

    Slick.prototype.refresh = function(initializing) {

        var _ = this, currentSlide, lastVisibleIndex;

        lastVisibleIndex = _.slideCount - _.options.slidesToShow;

        // in non-infinite sliders, we don't want to go past the
        // last visible index.
        if (!_.options.infinite && (_.currentSlide > lastVisibleIndex)) {
            _.currentSlide = lastVisibleIndex;
        }

        // if less slides than to show, go to start.
        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;

        }

        currentSlide = _.currentSlide;

        _.destroy(true);

        $.extend(_, _.initials, {
            currentSlide: currentSlide
        });

        _.init();

        if (!initializing) {

            _.changeSlide({
                data: {
                    message: 'index',
                    index: currentSlide
                }
            }, false);

        }

    }
    ;

    Slick.prototype.registerBreakpoints = function() {

        var _ = this, breakpoint, currentBreakpoint, l, responsiveSettings = _.options.responsive || null;

        if ($.type(responsiveSettings) === 'array' && responsiveSettings.length) {

            _.respondTo = _.options.respondTo || 'window';

            for (breakpoint in responsiveSettings) {

                l = _.breakpoints.length - 1;
                currentBreakpoint = responsiveSettings[breakpoint].breakpoint;

                if (responsiveSettings.hasOwnProperty(breakpoint)) {

                    // loop through the breakpoints and cut out any existing
                    // ones with the same breakpoint number, we don't want dupes.
                    while (l >= 0) {
                        if (_.breakpoints[l] && _.breakpoints[l] === currentBreakpoint) {
                            _.breakpoints.splice(l, 1);
                        }
                        l--;
                    }

                    _.breakpoints.push(currentBreakpoint);
                    _.breakpointSettings[currentBreakpoint] = responsiveSettings[breakpoint].settings;

                }

            }

            _.breakpoints.sort(function(a, b) {
                return (_.options.mobileFirst) ? a - b : b - a;
            });

        }

    }
    ;

    Slick.prototype.reinit = function() {

        var _ = this;

        _.$slides = _.$slideTrack.children(_.options.slide).addClass('slick-slide');

        _.slideCount = _.$slides.length;

        if (_.currentSlide >= _.slideCount && _.currentSlide !== 0) {
            _.currentSlide = _.currentSlide - _.options.slidesToScroll;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            _.currentSlide = 0;
        }

        _.registerBreakpoints();

        _.setProps();
        _.setupInfinite();
        _.buildArrows();
        _.updateArrows();
        _.initArrowEvents();
        _.buildDots();
        _.updateDots();
        _.initDotEvents();
        _.cleanUpSlideEvents();
        _.initSlideEvents();

        _.checkResponsive(false, true);

        if (_.options.focusOnSelect === true) {
            $(_.$slideTrack).children().on('click.slick', _.selectHandler);
        }

        _.setSlideClasses(typeof _.currentSlide === 'number' ? _.currentSlide : 0);

        _.setPosition();
        _.focusHandler();

        _.paused = !_.options.autoplay;
        _.autoPlay();

        _.$slider.trigger('reInit', [_]);

    }
    ;

    Slick.prototype.resize = function() {

        var _ = this;

        if ($(window).width() !== _.windowWidth) {
            clearTimeout(_.windowDelay);
            _.windowDelay = window.setTimeout(function() {
                _.windowWidth = $(window).width();
                _.checkResponsive();
                if (!_.unslicked) {
                    _.setPosition();
                }
            }, 50);
        }
    }
    ;

    Slick.prototype.removeSlide = Slick.prototype.slickRemove = function(index, removeBefore, removeAll) {

        var _ = this;

        if (typeof (index) === 'boolean') {
            removeBefore = index;
            index = removeBefore === true ? 0 : _.slideCount - 1;
        } else {
            index = removeBefore === true ? --index : index;
        }

        if (_.slideCount < 1 || index < 0 || index > _.slideCount - 1) {
            return false;
        }

        _.unload();

        if (removeAll === true) {
            _.$slideTrack.children().remove();
        } else {
            _.$slideTrack.children(this.options.slide).eq(index).remove();
        }

        _.$slides = _.$slideTrack.children(this.options.slide);

        _.$slideTrack.children(this.options.slide).detach();

        _.$slideTrack.append(_.$slides);

        _.$slidesCache = _.$slides;

        _.reinit();

    }
    ;

    Slick.prototype.setCSS = function(position) {

        var _ = this, positionProps = {}, x, y;

        if (_.options.rtl === true) {
            position = -position;
        }
        x = _.positionProp == 'left' ? Math.ceil(position) + 'px' : '0px';
        y = _.positionProp == 'top' ? Math.ceil(position) + 'px' : '0px';

        positionProps[_.positionProp] = position;

        if (_.transformsEnabled === false) {
            _.$slideTrack.css(positionProps);
        } else {
            positionProps = {};
            if (_.cssTransitions === false) {
                positionProps[_.animType] = 'translate(' + x + ', ' + y + ')';
                _.$slideTrack.css(positionProps);
            } else {
                positionProps[_.animType] = 'translate3d(' + x + ', ' + y + ', 0px)';
                _.$slideTrack.css(positionProps);
            }
        }

    }
    ;

    Slick.prototype.setDimensions = function() {

        var _ = this;

        if (_.options.vertical === false) {
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: ('0px ' + _.options.centerPadding)
                });
            }
        } else {
            _.$list.height(_.$slides.first().outerHeight(true) * _.options.slidesToShow);
            if (_.options.centerMode === true) {
                _.$list.css({
                    padding: (_.options.centerPadding + ' 0px')
                });
            }
        }

        _.listWidth = _.$list.width();
        _.listHeight = _.$list.height();

        if (_.options.vertical === false && _.options.variableWidth === false) {
            _.slideWidth = Math.ceil(_.listWidth / _.options.slidesToShow);
            _.$slideTrack.width(Math.ceil((_.slideWidth * _.$slideTrack.children('.slick-slide').length)));

        } else if (_.options.variableWidth === true) {
            _.$slideTrack.width(5000 * _.slideCount);
        } else {
            _.slideWidth = Math.ceil(_.listWidth);
            _.$slideTrack.height(Math.ceil((_.$slides.first().outerHeight(true) * _.$slideTrack.children('.slick-slide').length)));
        }

        var offset = _.$slides.first().outerWidth(true) - _.$slides.first().width();
        if (_.options.variableWidth === false)
            _.$slideTrack.children('.slick-slide').width(_.slideWidth - offset);

    }
    ;

    Slick.prototype.setFade = function() {

        var _ = this, targetLeft;

        _.$slides.each(function(index, element) {
            targetLeft = (_.slideWidth * index) * -1;
            if (_.options.rtl === true) {
                $(element).css({
                    position: 'relative',
                    right: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            } else {
                $(element).css({
                    position: 'relative',
                    left: targetLeft,
                    top: 0,
                    zIndex: _.options.zIndex - 2,
                    opacity: 0
                });
            }
        });

        _.$slides.eq(_.currentSlide).css({
            zIndex: _.options.zIndex - 1,
            opacity: 1
        });

    }
    ;

    Slick.prototype.setHeight = function() {

        var _ = this;

        if (_.options.slidesToShow === 1 && _.options.adaptiveHeight === true && _.options.vertical === false) {
            var targetHeight = _.$slides.eq(_.currentSlide).outerHeight(true);
            _.$list.css('height', targetHeight);
        }

    }
    ;

    Slick.prototype.setOption = Slick.prototype.slickSetOption = function() {

        /**
         * accepts arguments in format of:
         *
         *  - for changing a single option's value:
         *     .slick("setOption", option, value, refresh )
         *
         *  - for changing a set of responsive options:
         *     .slick("setOption", 'responsive', [{}, ...], refresh )
         *
         *  - for updating multiple values at once (not responsive)
         *     .slick("setOption", { 'option': value, ... }, refresh )
         */

        var _ = this, l, item, option, value, refresh = false, type;

        if ($.type(arguments[0]) === 'object') {

            option = arguments[0];
            refresh = arguments[1];
            type = 'multiple';

        } else if ($.type(arguments[0]) === 'string') {

            option = arguments[0];
            value = arguments[1];
            refresh = arguments[2];

            if (arguments[0] === 'responsive' && $.type(arguments[1]) === 'array') {

                type = 'responsive';

            } else if (typeof arguments[1] !== 'undefined') {

                type = 'single';

            }

        }

        if (type === 'single') {

            _.options[option] = value;

        } else if (type === 'multiple') {

            $.each(option, function(opt, val) {

                _.options[opt] = val;

            });

        } else if (type === 'responsive') {

            for (item in value) {

                if ($.type(_.options.responsive) !== 'array') {

                    _.options.responsive = [value[item]];

                } else {

                    l = _.options.responsive.length - 1;

                    // loop through the responsive object and splice out duplicates.
                    while (l >= 0) {

                        if (_.options.responsive[l].breakpoint === value[item].breakpoint) {

                            _.options.responsive.splice(l, 1);

                        }

                        l--;

                    }

                    _.options.responsive.push(value[item]);

                }

            }

        }

        if (refresh) {

            _.unload();
            _.reinit();

        }

    }
    ;

    Slick.prototype.setPosition = function() {

        var _ = this;

        _.setDimensions();

        _.setHeight();

        if (_.options.fade === false) {
            _.setCSS(_.getLeft(_.currentSlide));
        } else {
            _.setFade();
        }

        _.$slider.trigger('setPosition', [_]);

    }
    ;

    Slick.prototype.setProps = function() {

        var _ = this
          , bodyStyle = document.body.style;

        _.positionProp = _.options.vertical === true ? 'top' : 'left';

        if (_.positionProp === 'top') {
            _.$slider.addClass('slick-vertical');
        } else {
            _.$slider.removeClass('slick-vertical');
        }

        if (bodyStyle.WebkitTransition !== undefined || bodyStyle.MozTransition !== undefined || bodyStyle.msTransition !== undefined) {
            if (_.options.useCSS === true) {
                _.cssTransitions = true;
            }
        }

        if (_.options.fade) {
            if (typeof _.options.zIndex === 'number') {
                if (_.options.zIndex < 3) {
                    _.options.zIndex = 3;
                }
            } else {
                _.options.zIndex = _.defaults.zIndex;
            }
        }

        if (bodyStyle.OTransform !== undefined) {
            _.animType = 'OTransform';
            _.transformType = '-o-transform';
            _.transitionType = 'OTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined)
                _.animType = false;
        }
        if (bodyStyle.MozTransform !== undefined) {
            _.animType = 'MozTransform';
            _.transformType = '-moz-transform';
            _.transitionType = 'MozTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.MozPerspective === undefined)
                _.animType = false;
        }
        if (bodyStyle.webkitTransform !== undefined) {
            _.animType = 'webkitTransform';
            _.transformType = '-webkit-transform';
            _.transitionType = 'webkitTransition';
            if (bodyStyle.perspectiveProperty === undefined && bodyStyle.webkitPerspective === undefined)
                _.animType = false;
        }
        if (bodyStyle.msTransform !== undefined) {
            _.animType = 'msTransform';
            _.transformType = '-ms-transform';
            _.transitionType = 'msTransition';
            if (bodyStyle.msTransform === undefined)
                _.animType = false;
        }
        if (bodyStyle.transform !== undefined && _.animType !== false) {
            _.animType = 'transform';
            _.transformType = 'transform';
            _.transitionType = 'transition';
        }
        _.transformsEnabled = _.options.useTransform && (_.animType !== null && _.animType !== false);
    }
    ;

    Slick.prototype.setSlideClasses = function(index) {

        var _ = this, centerOffset, allSlides, indexOffset, remainder;

        allSlides = _.$slider.find('.slick-slide').removeClass('slick-active slick-center slick-current').attr('aria-hidden', 'true');

        _.$slides.eq(index).addClass('slick-current');

        if (_.options.centerMode === true) {

            centerOffset = Math.floor(_.options.slidesToShow / 2);

            if (_.options.infinite === true) {

                if (index >= centerOffset && index <= (_.slideCount - 1) - centerOffset) {

                    _.$slides.slice(index - centerOffset, index + centerOffset + 1).addClass('slick-active').attr('aria-hidden', 'false');

                } else {

                    indexOffset = _.options.slidesToShow + index;
                    allSlides.slice(indexOffset - centerOffset + 1, indexOffset + centerOffset + 2).addClass('slick-active').attr('aria-hidden', 'false');

                }

                if (index === 0) {

                    allSlides.eq(allSlides.length - 1 - _.options.slidesToShow).addClass('slick-center');

                } else if (index === _.slideCount - 1) {

                    allSlides.eq(_.options.slidesToShow).addClass('slick-center');

                }

            }

            _.$slides.eq(index).addClass('slick-center');

        } else {

            if (index >= 0 && index <= (_.slideCount - _.options.slidesToShow)) {

                _.$slides.slice(index, index + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');

            } else if (allSlides.length <= _.options.slidesToShow) {

                allSlides.addClass('slick-active').attr('aria-hidden', 'false');

            } else {

                remainder = _.slideCount % _.options.slidesToShow;
                indexOffset = _.options.infinite === true ? _.options.slidesToShow + index : index;

                if (_.options.slidesToShow == _.options.slidesToScroll && (_.slideCount - index) < _.options.slidesToShow) {

                    allSlides.slice(indexOffset - (_.options.slidesToShow - remainder), indexOffset + remainder).addClass('slick-active').attr('aria-hidden', 'false');

                } else {

                    allSlides.slice(indexOffset, indexOffset + _.options.slidesToShow).addClass('slick-active').attr('aria-hidden', 'false');

                }

            }

        }

        if (_.options.lazyLoad === 'ondemand') {
            _.lazyLoad();
        }

    }
    ;

    Slick.prototype.setupInfinite = function() {

        var _ = this, i, slideIndex, infiniteCount;

        if (_.options.fade === true) {
            _.options.centerMode = false;
        }

        if (_.options.infinite === true && _.options.fade === false) {

            slideIndex = null;

            if (_.slideCount > _.options.slidesToShow) {

                if (_.options.centerMode === true) {
                    infiniteCount = _.options.slidesToShow + 1;
                } else {
                    infiniteCount = _.options.slidesToShow;
                }

                for (i = _.slideCount; i > (_.slideCount - infiniteCount); i -= 1) {
                    slideIndex = i - 1;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex - _.slideCount).prependTo(_.$slideTrack).addClass('slick-cloned');
                }
                for (i = 0; i < infiniteCount; i += 1) {
                    slideIndex = i;
                    $(_.$slides[slideIndex]).clone(true).attr('id', '').attr('data-slick-index', slideIndex + _.slideCount).appendTo(_.$slideTrack).addClass('slick-cloned');
                }
                _.$slideTrack.find('.slick-cloned').find('[id]').each(function() {
                    $(this).attr('id', '');
                });

            }

        }

    }
    ;

    Slick.prototype.interrupt = function(toggle) {

        var _ = this;

        if (!toggle) {
            _.autoPlay();
        }
        _.interrupted = toggle;

    }
    ;

    Slick.prototype.selectHandler = function(event) {

        var _ = this;

        var targetElement = $(event.target).is('.slick-slide') ? $(event.target) : $(event.target).parents('.slick-slide');

        var index = parseInt(targetElement.attr('data-slick-index'));

        if (!index)
            index = 0;

        if (_.slideCount <= _.options.slidesToShow) {

            _.setSlideClasses(index);
            _.asNavFor(index);
            return;

        }

        _.slideHandler(index);

    }
    ;

    Slick.prototype.slideHandler = function(index, sync, dontAnimate) {

        var targetSlide, animSlide, oldSlide, slideLeft, targetLeft = null, _ = this, navTarget;

        sync = sync || false;

        if (_.animating === true && _.options.waitForAnimate === true) {
            return;
        }

        if (_.options.fade === true && _.currentSlide === index) {
            return;
        }

        if (_.slideCount <= _.options.slidesToShow) {
            return;
        }

        if (sync === false) {
            _.asNavFor(index);
        }

        targetSlide = index;
        targetLeft = _.getLeft(targetSlide);
        slideLeft = _.getLeft(_.currentSlide);

        _.currentLeft = _.swipeLeft === null ? slideLeft : _.swipeLeft;

        if (_.options.infinite === false && _.options.centerMode === false && (index < 0 || index > _.getDotCount() * _.options.slidesToScroll)) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        } else if (_.options.infinite === false && _.options.centerMode === true && (index < 0 || index > (_.slideCount - _.options.slidesToScroll))) {
            if (_.options.fade === false) {
                targetSlide = _.currentSlide;
                if (dontAnimate !== true) {
                    _.animateSlide(slideLeft, function() {
                        _.postSlide(targetSlide);
                    });
                } else {
                    _.postSlide(targetSlide);
                }
            }
            return;
        }

        if (_.options.autoplay) {
            clearInterval(_.autoPlayTimer);
        }

        if (targetSlide < 0) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = _.slideCount - (_.slideCount % _.options.slidesToScroll);
            } else {
                animSlide = _.slideCount + targetSlide;
            }
        } else if (targetSlide >= _.slideCount) {
            if (_.slideCount % _.options.slidesToScroll !== 0) {
                animSlide = 0;
            } else {
                animSlide = targetSlide - _.slideCount;
            }
        } else {
            animSlide = targetSlide;
        }

        _.animating = true;

        _.$slider.trigger('beforeChange', [_, _.currentSlide, animSlide]);

        oldSlide = _.currentSlide;
        _.currentSlide = animSlide;

        _.setSlideClasses(_.currentSlide);

        if (_.options.asNavFor) {

            navTarget = _.getNavTarget();
            navTarget = navTarget.slick('getSlick');

            if (navTarget.slideCount <= navTarget.options.slidesToShow) {
                navTarget.setSlideClasses(_.currentSlide);
            }

        }

        _.updateDots();
        _.updateArrows();

        if (_.options.fade === true) {
            if (dontAnimate !== true) {

                _.fadeSlideOut(oldSlide);

                _.fadeSlide(animSlide, function() {
                    _.postSlide(animSlide);
                });

            } else {
                _.postSlide(animSlide);
            }
            _.animateHeight();
            return;
        }

        if (dontAnimate !== true) {
            _.animateSlide(targetLeft, function() {
                _.postSlide(animSlide);
            });
        } else {
            _.postSlide(animSlide);
        }

    }
    ;

    Slick.prototype.startLoad = function() {

        var _ = this;

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow) {

            _.$prevArrow.hide();
            _.$nextArrow.hide();

        }

        if (_.options.dots === true && _.slideCount > _.options.slidesToShow) {

            _.$dots.hide();

        }

        _.$slider.addClass('slick-loading');

    }
    ;

    Slick.prototype.swipeDirection = function() {

        var xDist, yDist, r, swipeAngle, _ = this;

        xDist = _.touchObject.startX - _.touchObject.curX;
        yDist = _.touchObject.startY - _.touchObject.curY;
        r = Math.atan2(yDist, xDist);

        swipeAngle = Math.round(r * 180 / Math.PI);
        if (swipeAngle < 0) {
            swipeAngle = 360 - Math.abs(swipeAngle);
        }

        if ((swipeAngle <= 45) && (swipeAngle >= 0)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle <= 360) && (swipeAngle >= 315)) {
            return (_.options.rtl === false ? 'left' : 'right');
        }
        if ((swipeAngle >= 135) && (swipeAngle <= 225)) {
            return (_.options.rtl === false ? 'right' : 'left');
        }
        if (_.options.verticalSwiping === true) {
            if ((swipeAngle >= 35) && (swipeAngle <= 135)) {
                return 'down';
            } else {
                return 'up';
            }
        }

        return 'vertical';

    }
    ;

    Slick.prototype.swipeEnd = function(event) {

        var _ = this, slideCount, direction;

        _.dragging = false;
        _.interrupted = false;
        _.shouldClick = (_.touchObject.swipeLength > 10) ? false : true;

        if (_.touchObject.curX === undefined) {
            return false;
        }

        if (_.touchObject.edgeHit === true) {
            _.$slider.trigger('edge', [_, _.swipeDirection()]);
        }

        if (_.touchObject.swipeLength >= _.touchObject.minSwipe) {

            direction = _.swipeDirection();

            switch (direction) {

            case 'left':
            case 'down':

                slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide + _.getSlideCount()) : _.currentSlide + _.getSlideCount();

                _.currentDirection = 0;

                break;

            case 'right':
            case 'up':

                slideCount = _.options.swipeToSlide ? _.checkNavigable(_.currentSlide - _.getSlideCount()) : _.currentSlide - _.getSlideCount();

                _.currentDirection = 1;

                break;

            default:

            }

            if (direction != 'vertical') {

                _.slideHandler(slideCount);
                _.touchObject = {};
                _.$slider.trigger('swipe', [_, direction]);

            }

        } else {

            if (_.touchObject.startX !== _.touchObject.curX) {

                _.slideHandler(_.currentSlide);
                _.touchObject = {};

            }

        }

    }
    ;

    Slick.prototype.swipeHandler = function(event) {

        var _ = this;

        if ((_.options.swipe === false) || ('ontouchend'in document && _.options.swipe === false)) {
            return;
        } else if (_.options.draggable === false && event.type.indexOf('mouse') !== -1) {
            return;
        }

        _.touchObject.fingerCount = event.originalEvent && event.originalEvent.touches !== undefined ? event.originalEvent.touches.length : 1;

        _.touchObject.minSwipe = _.listWidth / _.options.touchThreshold;

        if (_.options.verticalSwiping === true) {
            _.touchObject.minSwipe = _.listHeight / _.options.touchThreshold;
        }

        switch (event.data.action) {

        case 'start':
            _.swipeStart(event);
            break;

        case 'move':
            _.swipeMove(event);
            break;

        case 'end':
            _.swipeEnd(event);
            break;

        }

    }
    ;

    Slick.prototype.swipeMove = function(event) {

        var _ = this, edgeWasHit = false, curLeft, swipeDirection, swipeLength, positionOffset, touches;

        touches = event.originalEvent !== undefined ? event.originalEvent.touches : null;

        if (!_.dragging || touches && touches.length !== 1) {
            return false;
        }

        curLeft = _.getLeft(_.currentSlide);

        _.touchObject.curX = touches !== undefined ? touches[0].pageX : event.clientX;
        _.touchObject.curY = touches !== undefined ? touches[0].pageY : event.clientY;

        _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curX - _.touchObject.startX, 2)));

        if (_.options.verticalSwiping === true) {
            _.touchObject.swipeLength = Math.round(Math.sqrt(Math.pow(_.touchObject.curY - _.touchObject.startY, 2)));
        }

        swipeDirection = _.swipeDirection();

        if (swipeDirection === 'vertical') {
            return;
        }

        if (event.originalEvent !== undefined && _.touchObject.swipeLength > 4) {
            event.preventDefault();
        }

        positionOffset = (_.options.rtl === false ? 1 : -1) * (_.touchObject.curX > _.touchObject.startX ? 1 : -1);
        if (_.options.verticalSwiping === true) {
            positionOffset = _.touchObject.curY > _.touchObject.startY ? 1 : -1;
        }

        swipeLength = _.touchObject.swipeLength;

        _.touchObject.edgeHit = false;

        if (_.options.infinite === false) {
            if ((_.currentSlide === 0 && swipeDirection === 'right') || (_.currentSlide >= _.getDotCount() && swipeDirection === 'left')) {
                swipeLength = _.touchObject.swipeLength * _.options.edgeFriction;
                _.touchObject.edgeHit = true;
            }
        }

        if (_.options.vertical === false) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        } else {
            _.swipeLeft = curLeft + (swipeLength * (_.$list.height() / _.listWidth)) * positionOffset;
        }
        if (_.options.verticalSwiping === true) {
            _.swipeLeft = curLeft + swipeLength * positionOffset;
        }

        if (_.options.fade === true || _.options.touchMove === false) {
            return false;
        }

        if (_.animating === true) {
            _.swipeLeft = null;
            return false;
        }

        _.setCSS(_.swipeLeft);

    }
    ;

    Slick.prototype.swipeStart = function(event) {

        var _ = this, touches;

        _.interrupted = true;

        if (_.touchObject.fingerCount !== 1 || _.slideCount <= _.options.slidesToShow) {
            _.touchObject = {};
            return false;
        }

        if (event.originalEvent !== undefined && event.originalEvent.touches !== undefined) {
            touches = event.originalEvent.touches[0];
        }

        _.touchObject.startX = _.touchObject.curX = touches !== undefined ? touches.pageX : event.clientX;
        _.touchObject.startY = _.touchObject.curY = touches !== undefined ? touches.pageY : event.clientY;

        _.dragging = true;

    }
    ;

    Slick.prototype.unfilterSlides = Slick.prototype.slickUnfilter = function() {

        var _ = this;

        if (_.$slidesCache !== null) {

            _.unload();

            _.$slideTrack.children(this.options.slide).detach();

            _.$slidesCache.appendTo(_.$slideTrack);

            _.reinit();

        }

    }
    ;

    Slick.prototype.unload = function() {

        var _ = this;

        $('.slick-cloned', _.$slider).remove();

        if (_.$dots) {
            _.$dots.remove();
        }

        if (_.$prevArrow && _.htmlExpr.test(_.options.prevArrow)) {
            _.$prevArrow.remove();
        }

        if (_.$nextArrow && _.htmlExpr.test(_.options.nextArrow)) {
            _.$nextArrow.remove();
        }

        _.$slides.removeClass('slick-slide slick-active slick-visible slick-current').attr('aria-hidden', 'true').css('width', '');

    }
    ;

    Slick.prototype.unslick = function(fromBreakpoint) {

        var _ = this;
        _.$slider.trigger('unslick', [_, fromBreakpoint]);
        _.destroy();

    }
    ;

    Slick.prototype.updateArrows = function() {

        var _ = this, centerOffset;

        centerOffset = Math.floor(_.options.slidesToShow / 2);

        if (_.options.arrows === true && _.slideCount > _.options.slidesToShow && !_.options.infinite) {

            _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');
            _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            if (_.currentSlide === 0) {

                _.$prevArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$nextArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - _.options.slidesToShow && _.options.centerMode === false) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            } else if (_.currentSlide >= _.slideCount - 1 && _.options.centerMode === true) {

                _.$nextArrow.addClass('slick-disabled').attr('aria-disabled', 'true');
                _.$prevArrow.removeClass('slick-disabled').attr('aria-disabled', 'false');

            }

        }

    }
    ;

    Slick.prototype.updateDots = function() {

        var _ = this;

        if (_.$dots !== null) {

            _.$dots.find('li').removeClass('slick-active').attr('aria-hidden', 'true');

            _.$dots.find('li').eq(Math.floor(_.currentSlide / _.options.slidesToScroll)).addClass('slick-active').attr('aria-hidden', 'false');

        }

    }
    ;

    Slick.prototype.visibility = function() {

        var _ = this;

        if (_.options.autoplay) {

            if (document[_.hidden]) {

                _.interrupted = true;

            } else {

                _.interrupted = false;

            }

        }

    }
    ;

    $.fn.slick = function() {
        var _ = this, opt = arguments[0], args = Array.prototype.slice.call(arguments, 1), l = _.length, i, ret;
        for (i = 0; i < l; i++) {
            if (typeof opt == 'object' || typeof opt == 'undefined')
                _[i].slick = new Slick(_[i],opt);
            else
                ret = _[i].slick[opt].apply(_[i].slick, args);
            if (typeof ret != 'undefined')
                return ret;
        }
        return _;
    }
    ;

}));

/*!
Waypoints - 4.0.0
Copyright © 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
(function() {
    'use strict'

    var keyCounter = 0
    var allWaypoints = {}

    /* http://imakewebthings.com/waypoints/api/waypoint */
    function Waypoint(options) {
        if (!options) {
            throw new Error('No options passed to Waypoint constructor')
        }
        if (!options.element) {
            throw new Error('No element option passed to Waypoint constructor')
        }
        if (!options.handler) {
            throw new Error('No handler option passed to Waypoint constructor')
        }

        this.key = 'waypoint-' + keyCounter
        this.options = Waypoint.Adapter.extend({}, Waypoint.defaults, options)
        this.element = this.options.element
        this.adapter = new Waypoint.Adapter(this.element)
        this.callback = options.handler
        this.axis = this.options.horizontal ? 'horizontal' : 'vertical'
        this.enabled = this.options.enabled
        this.triggerPoint = null
        this.group = Waypoint.Group.findOrCreate({
            name: this.options.group,
            axis: this.axis
        })
        this.context = Waypoint.Context.findOrCreateByElement(this.options.context)

        if (Waypoint.offsetAliases[this.options.offset]) {
            this.options.offset = Waypoint.offsetAliases[this.options.offset]
        }
        this.group.add(this)
        this.context.add(this)
        allWaypoints[this.key] = this
        keyCounter += 1
    }

    /* Private */
    Waypoint.prototype.queueTrigger = function(direction) {
        this.group.queueTrigger(this, direction)
    }

    /* Private */
    Waypoint.prototype.trigger = function(args) {
        if (!this.enabled) {
            return
        }
        if (this.callback) {
            this.callback.apply(this, args)
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/destroy */
    Waypoint.prototype.destroy = function() {
        this.context.remove(this)
        this.group.remove(this)
        delete allWaypoints[this.key]
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/disable */
    Waypoint.prototype.disable = function() {
        this.enabled = false
        return this
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/enable */
    Waypoint.prototype.enable = function() {
        this.context.refresh()
        this.enabled = true
        return this
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/next */
    Waypoint.prototype.next = function() {
        return this.group.next(this)
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/previous */
    Waypoint.prototype.previous = function() {
        return this.group.previous(this)
    }

    /* Private */
    Waypoint.invokeAll = function(method) {
        var allWaypointsArray = []
        for (var waypointKey in allWaypoints) {
            allWaypointsArray.push(allWaypoints[waypointKey])
        }
        for (var i = 0, end = allWaypointsArray.length; i < end; i++) {
            allWaypointsArray[i][method]()
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/destroy-all */
    Waypoint.destroyAll = function() {
        Waypoint.invokeAll('destroy')
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/disable-all */
    Waypoint.disableAll = function() {
        Waypoint.invokeAll('disable')
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/enable-all */
    Waypoint.enableAll = function() {
        Waypoint.invokeAll('enable')
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/refresh-all */
    Waypoint.refreshAll = function() {
        Waypoint.Context.refreshAll()
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/viewport-height */
    Waypoint.viewportHeight = function() {
        return window.innerHeight || document.documentElement.clientHeight
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/viewport-width */
    Waypoint.viewportWidth = function() {
        return document.documentElement.clientWidth
    }

    Waypoint.adapters = []

    Waypoint.defaults = {
        context: window,
        continuous: true,
        enabled: true,
        group: 'default',
        horizontal: false,
        offset: 0
    }

    Waypoint.offsetAliases = {
        'bottom-in-view': function() {
            return this.context.innerHeight() - this.adapter.outerHeight()
        },
        'right-in-view': function() {
            return this.context.innerWidth() - this.adapter.outerWidth()
        }
    }

    window.Waypoint = Waypoint
}());
(function() {
    'use strict'

    function requestAnimationFrameShim(callback) {
        window.setTimeout(callback, 1000 / 60)
    }

    var keyCounter = 0
    var contexts = {}
    var Waypoint = window.Waypoint
    var oldWindowLoad = window.onload

    /* http://imakewebthings.com/waypoints/api/context */
    function Context(element) {
        this.element = element
        this.Adapter = Waypoint.Adapter
        this.adapter = new this.Adapter(element)
        this.key = 'waypoint-context-' + keyCounter
        this.didScroll = false
        this.didResize = false
        this.oldScroll = {
            x: this.adapter.scrollLeft(),
            y: this.adapter.scrollTop()
        }
        this.waypoints = {
            vertical: {},
            horizontal: {}
        }

        element.waypointContextKey = this.key
        contexts[element.waypointContextKey] = this
        keyCounter += 1

        this.createThrottledScrollHandler()
        this.createThrottledResizeHandler()
    }

    /* Private */
    Context.prototype.add = function(waypoint) {
        var axis = waypoint.options.horizontal ? 'horizontal' : 'vertical'
        this.waypoints[axis][waypoint.key] = waypoint
        this.refresh()
    }

    /* Private */
    Context.prototype.checkEmpty = function() {
        var horizontalEmpty = this.Adapter.isEmptyObject(this.waypoints.horizontal)
        var verticalEmpty = this.Adapter.isEmptyObject(this.waypoints.vertical)
        if (horizontalEmpty && verticalEmpty) {
            this.adapter.off('.waypoints')
            delete contexts[this.key]
        }
    }

    /* Private */
    Context.prototype.createThrottledResizeHandler = function() {
        var self = this

        function resizeHandler() {
            self.handleResize()
            self.didResize = false
        }

        this.adapter.on('resize.waypoints', function() {
            if (!self.didResize) {
                self.didResize = true
                Waypoint.requestAnimationFrame(resizeHandler)
            }
        })
    }

    /* Private */
    Context.prototype.createThrottledScrollHandler = function() {
        var self = this
        function scrollHandler() {
            self.handleScroll()
            self.didScroll = false
        }

        this.adapter.on('scroll.waypoints', function() {
            if (!self.didScroll || Waypoint.isTouch) {
                self.didScroll = true
                Waypoint.requestAnimationFrame(scrollHandler)
            }
        })
    }

    /* Private */
    Context.prototype.handleResize = function() {
        Waypoint.Context.refreshAll()
    }

    /* Private */
    Context.prototype.handleScroll = function() {
        var triggeredGroups = {}
        var axes = {
            horizontal: {
                newScroll: this.adapter.scrollLeft(),
                oldScroll: this.oldScroll.x,
                forward: 'right',
                backward: 'left'
            },
            vertical: {
                newScroll: this.adapter.scrollTop(),
                oldScroll: this.oldScroll.y,
                forward: 'down',
                backward: 'up'
            }
        }

        for (var axisKey in axes) {
            var axis = axes[axisKey]
            var isForward = axis.newScroll > axis.oldScroll
            var direction = isForward ? axis.forward : axis.backward

            for (var waypointKey in this.waypoints[axisKey]) {
                var waypoint = this.waypoints[axisKey][waypointKey]
                var wasBeforeTriggerPoint = axis.oldScroll < waypoint.triggerPoint
                var nowAfterTriggerPoint = axis.newScroll >= waypoint.triggerPoint
                var crossedForward = wasBeforeTriggerPoint && nowAfterTriggerPoint
                var crossedBackward = !wasBeforeTriggerPoint && !nowAfterTriggerPoint
                if (crossedForward || crossedBackward) {
                    waypoint.queueTrigger(direction)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
            }
        }

        for (var groupKey in triggeredGroups) {
            triggeredGroups[groupKey].flushTriggers()
        }

        this.oldScroll = {
            x: axes.horizontal.newScroll,
            y: axes.vertical.newScroll
        }
    }

    /* Private */
    Context.prototype.innerHeight = function() {
        /*eslint-disable eqeqeq */
        if (this.element == this.element.window) {
            return Waypoint.viewportHeight()
        }
        /*eslint-enable eqeqeq */
        return this.adapter.innerHeight()
    }

    /* Private */
    Context.prototype.remove = function(waypoint) {
        delete this.waypoints[waypoint.axis][waypoint.key]
        this.checkEmpty()
    }

    /* Private */
    Context.prototype.innerWidth = function() {
        /*eslint-disable eqeqeq */
        if (this.element == this.element.window) {
            return Waypoint.viewportWidth()
        }
        /*eslint-enable eqeqeq */
        return this.adapter.innerWidth()
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-destroy */
    Context.prototype.destroy = function() {
        var allWaypoints = []
        for (var axis in this.waypoints) {
            for (var waypointKey in this.waypoints[axis]) {
                allWaypoints.push(this.waypoints[axis][waypointKey])
            }
        }
        for (var i = 0, end = allWaypoints.length; i < end; i++) {
            allWaypoints[i].destroy()
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-refresh */
    Context.prototype.refresh = function() {
        /*eslint-disable eqeqeq */
        var isWindow = this.element == this.element.window
        /*eslint-enable eqeqeq */
        var contextOffset = isWindow ? undefined : this.adapter.offset()
        var triggeredGroups = {}
        var axes

        this.handleScroll()
        axes = {
            horizontal: {
                contextOffset: isWindow ? 0 : contextOffset.left,
                contextScroll: isWindow ? 0 : this.oldScroll.x,
                contextDimension: this.innerWidth(),
                oldScroll: this.oldScroll.x,
                forward: 'right',
                backward: 'left',
                offsetProp: 'left'
            },
            vertical: {
                contextOffset: isWindow ? 0 : contextOffset.top,
                contextScroll: isWindow ? 0 : this.oldScroll.y,
                contextDimension: this.innerHeight(),
                oldScroll: this.oldScroll.y,
                forward: 'down',
                backward: 'up',
                offsetProp: 'top'
            }
        }

        for (var axisKey in axes) {
            var axis = axes[axisKey]
            for (var waypointKey in this.waypoints[axisKey]) {
                var waypoint = this.waypoints[axisKey][waypointKey]
                var adjustment = waypoint.options.offset
                var oldTriggerPoint = waypoint.triggerPoint
                var elementOffset = 0
                var freshWaypoint = oldTriggerPoint == null
                var contextModifier, wasBeforeScroll, nowAfterScroll
                var triggeredBackward, triggeredForward

                if (waypoint.element !== waypoint.element.window) {
                    elementOffset = waypoint.adapter.offset()[axis.offsetProp]
                }

                if (typeof adjustment === 'function') {
                    adjustment = adjustment.apply(waypoint)
                } else if (typeof adjustment === 'string') {
                    adjustment = parseFloat(adjustment)
                    if (waypoint.options.offset.indexOf('%') > -1) {
                        adjustment = Math.ceil(axis.contextDimension * adjustment / 100)
                    }
                }

                contextModifier = axis.contextScroll - axis.contextOffset
                waypoint.triggerPoint = elementOffset + contextModifier - adjustment
                wasBeforeScroll = oldTriggerPoint < axis.oldScroll
                nowAfterScroll = waypoint.triggerPoint >= axis.oldScroll
                triggeredBackward = wasBeforeScroll && nowAfterScroll
                triggeredForward = !wasBeforeScroll && !nowAfterScroll

                if (!freshWaypoint && triggeredBackward) {
                    waypoint.queueTrigger(axis.backward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                } else if (!freshWaypoint && triggeredForward) {
                    waypoint.queueTrigger(axis.forward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                } else if (freshWaypoint && axis.oldScroll >= waypoint.triggerPoint) {
                    waypoint.queueTrigger(axis.forward)
                    triggeredGroups[waypoint.group.id] = waypoint.group
                }
            }
        }

        Waypoint.requestAnimationFrame(function() {
            for (var groupKey in triggeredGroups) {
                triggeredGroups[groupKey].flushTriggers()
            }
        })

        return this
    }

    /* Private */
    Context.findOrCreateByElement = function(element) {
        return Context.findByElement(element) || new Context(element)
    }

    /* Private */
    Context.refreshAll = function() {
        for (var contextId in contexts) {
            contexts[contextId].refresh()
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/context-find-by-element */
    Context.findByElement = function(element) {
        return contexts[element.waypointContextKey]
    }

    window.onload = function() {
        if (oldWindowLoad) {
            oldWindowLoad()
        }
        Context.refreshAll()
    }

    Waypoint.requestAnimationFrame = function(callback) {
        var requestFn = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || requestAnimationFrameShim
        requestFn.call(window, callback)
    }
    Waypoint.Context = Context
}());
(function() {
    'use strict'

    function byTriggerPoint(a, b) {
        return a.triggerPoint - b.triggerPoint
    }

    function byReverseTriggerPoint(a, b) {
        return b.triggerPoint - a.triggerPoint
    }

    var groups = {
        vertical: {},
        horizontal: {}
    }
    var Waypoint = window.Waypoint

    /* http://imakewebthings.com/waypoints/api/group */
    function Group(options) {
        this.name = options.name
        this.axis = options.axis
        this.id = this.name + '-' + this.axis
        this.waypoints = []
        this.clearTriggerQueues()
        groups[this.axis][this.name] = this
    }

    /* Private */
    Group.prototype.add = function(waypoint) {
        this.waypoints.push(waypoint)
    }

    /* Private */
    Group.prototype.clearTriggerQueues = function() {
        this.triggerQueues = {
            up: [],
            down: [],
            left: [],
            right: []
        }
    }

    /* Private */
    Group.prototype.flushTriggers = function() {
        for (var direction in this.triggerQueues) {
            var waypoints = this.triggerQueues[direction]
            var reverse = direction === 'up' || direction === 'left'
            waypoints.sort(reverse ? byReverseTriggerPoint : byTriggerPoint)
            for (var i = 0, end = waypoints.length; i < end; i += 1) {
                var waypoint = waypoints[i]
                if (waypoint.options.continuous || i === waypoints.length - 1) {
                    waypoint.trigger([direction])
                }
            }
        }
        this.clearTriggerQueues()
    }

    /* Private */
    Group.prototype.next = function(waypoint) {
        this.waypoints.sort(byTriggerPoint)
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        var isLast = index === this.waypoints.length - 1
        return isLast ? null : this.waypoints[index + 1]
    }

    /* Private */
    Group.prototype.previous = function(waypoint) {
        this.waypoints.sort(byTriggerPoint)
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        return index ? this.waypoints[index - 1] : null
    }

    /* Private */
    Group.prototype.queueTrigger = function(waypoint, direction) {
        this.triggerQueues[direction].push(waypoint)
    }

    /* Private */
    Group.prototype.remove = function(waypoint) {
        var index = Waypoint.Adapter.inArray(waypoint, this.waypoints)
        if (index > -1) {
            this.waypoints.splice(index, 1)
        }
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/first */
    Group.prototype.first = function() {
        return this.waypoints[0]
    }

    /* Public */
    /* http://imakewebthings.com/waypoints/api/last */
    Group.prototype.last = function() {
        return this.waypoints[this.waypoints.length - 1]
    }

    /* Private */
    Group.findOrCreate = function(options) {
        return groups[options.axis][options.name] || new Group(options)
    }

    Waypoint.Group = Group
}());
(function() {
    'use strict'

    var $ = window.jQuery
    var Waypoint = window.Waypoint

    function JQueryAdapter(element) {
        this.$element = $(element)
    }

    $.each(['innerHeight', 'innerWidth', 'off', 'offset', 'on', 'outerHeight', 'outerWidth', 'scrollLeft', 'scrollTop'], function(i, method) {
        JQueryAdapter.prototype[method] = function() {
            var args = Array.prototype.slice.call(arguments)
            return this.$element[method].apply(this.$element, args)
        }
    })

    $.each(['extend', 'inArray', 'isEmptyObject'], function(i, method) {
        JQueryAdapter[method] = $[method]
    })

    Waypoint.adapters.push({
        name: 'jquery',
        Adapter: JQueryAdapter
    })
    Waypoint.Adapter = JQueryAdapter
}());
(function() {
    'use strict'

    var Waypoint = window.Waypoint

    function createExtension(framework) {
        return function() {
            var waypoints = []
            var overrides = arguments[0]

            if (framework.isFunction(arguments[0])) {
                overrides = framework.extend({}, arguments[1])
                overrides.handler = arguments[0]
            }

            this.each(function() {
                var options = framework.extend({}, overrides, {
                    element: this
                })
                if (typeof options.context === 'string') {
                    options.context = framework(this).closest(options.context)[0]
                }
                waypoints.push(new Waypoint(options))
            })

            return waypoints
        }
    }

    if (window.jQuery) {
        window.jQuery.fn.waypoint = createExtension(window.jQuery)
    }
    if (window.Zepto) {
        window.Zepto.fn.waypoint = createExtension(window.Zepto)
    }
}());
/*!
Waypoints Sticky Element Shortcut - 4.0.0
Copyright © 2011-2015 Caleb Troughton
Licensed under the MIT license.
https://github.com/imakewebthings/waypoints/blob/master/licenses.txt
*/
(function() {
    'use strict'

    var $ = window.jQuery
    var Waypoint = window.Waypoint

    /* http://imakewebthings.com/waypoints/shortcuts/sticky-elements */
    function Sticky(options) {
        this.options = $.extend({}, Waypoint.defaults, Sticky.defaults, options)
        this.element = this.options.element
        this.$element = $(this.element)
        this.createWrapper()
        this.createWaypoint()
    }

    /* Private */
    Sticky.prototype.createWaypoint = function() {
        var originalHandler = this.options.handler

        this.waypoint = new Waypoint($.extend({}, this.options, {
            element: this.wrapper,
            handler: $.proxy(function(direction) {
                var shouldBeStuck = this.options.direction.indexOf(direction) > -1
                var wrapperHeight = shouldBeStuck ? this.$element.outerHeight(true) : ''

                this.$wrapper.height(wrapperHeight)
                this.$element.toggleClass(this.options.stuckClass, shouldBeStuck)

                if (originalHandler) {
                    originalHandler.call(this, direction)
                }
            }, this)
        }))
    }

    /* Private */
    Sticky.prototype.createWrapper = function() {
        if (this.options.wrapper) {
            this.$element.wrap(this.options.wrapper)
        }
        this.$wrapper = this.$element.parent()
        this.wrapper = this.$wrapper[0]
    }

    /* Public */
    Sticky.prototype.destroy = function() {
        if (this.$element.parent()[0] === this.wrapper) {
            this.waypoint.destroy()
            this.$element.removeClass(this.options.stuckClass)
            if (this.options.wrapper) {
                this.$element.unwrap()
            }
        }
    }

    Sticky.defaults = {
        wrapper: '<div class="sticky-wrapper" />',
        stuckClass: 'stuck',
        direction: 'down right'
    }

    Waypoint.Sticky = Sticky
}());
/*!
 * sweetalert2 v4.1.9
 * Released under the MIT License.
 */
(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global.Sweetalert2 = factory());
}(this, function() {
    'use strict';

    var swalPrefix = 'swal2-';

    var prefix = function(items) {
        var result = {};
        for (var i in items) {
            result[items[i]] = swalPrefix + items[i];
        }
        return result;
    };

    var swalClasses = prefix(['container', 'modal', 'overlay', 'close', 'content', 'spacer', 'confirm', 'cancel', 'icon', 'image', 'input', 'select', 'radio', 'checkbox', 'textarea', 'validationerror']);

    var iconTypes = prefix(['success', 'warning', 'info', 'question', 'error']);

    var defaultParams = {
        title: '',
        text: '',
        html: '',
        type: null,
        customClass: '',
        animation: true,
        allowOutsideClick: true,
        allowEscapeKey: true,
        showConfirmButton: true,
        showCancelButton: false,
        preConfirm: null,
        confirmButtonText: 'OK',
        confirmButtonColor: '#3085d6',
        confirmButtonClass: null,
        cancelButtonText: 'Cancel',
        cancelButtonColor: '#aaa',
        cancelButtonClass: null,
        buttonsStyling: true,
        reverseButtons: false,
        focusCancel: false,
        showCloseButton: false,
        showLoaderOnConfirm: false,
        imageUrl: null,
        imageWidth: null,
        imageHeight: null,
        imageClass: null,
        timer: null,
        width: 500,
        padding: 20,
        background: '#fff',
        input: null,
        // 'text' | 'email' | 'password' | 'select' | 'radio' | 'checkbox' | 'textarea' | 'file'
        inputPlaceholder: '',
        inputValue: '',
        inputOptions: {},
        inputAutoTrim: true,
        inputClass: null,
        inputAttributes: {},
        inputValidator: null,
        onOpen: null,
        onClose: null
    };

    var sweetHTML = '<div class="' + swalClasses.overlay + '" tabIndex="-1"></div>' + '<div class="' + swalClasses.modal + '" style="display: none" tabIndex="-1">' + '<div class="' + swalClasses.icon + ' ' + iconTypes.error + '">' + '<span class="x-mark"><span class="line left"></span><span class="line right"></span></span>' + '</div>' + '<div class="' + swalClasses.icon + ' ' + iconTypes.question + '">?</div>' + '<div class="' + swalClasses.icon + ' ' + iconTypes.warning + '">!</div>' + '<div class="' + swalClasses.icon + ' ' + iconTypes.info + '">i</div>' + '<div class="' + swalClasses.icon + ' ' + iconTypes.success + '">' + '<span class="line tip"></span> <span class="line long"></span>' + '<div class="placeholder"></div> <div class="fix"></div>' + '</div>' + '<img class="' + swalClasses.image + '">' + '<h2></h2>' + '<div class="' + swalClasses.content + '"></div>' + '<input class="' + swalClasses.input + '">' + '<select class="' + swalClasses.select + '"></select>' + '<div class="' + swalClasses.radio + '"></div>' + '<label for="' + swalClasses.checkbox + '" class="' + swalClasses.checkbox + '">' + '<input type="checkbox" id="' + swalClasses.checkbox + '">' + '</label>' + '<textarea class="' + swalClasses.textarea + '"></textarea>' + '<div class="' + swalClasses.validationerror + '"></div>' + '<hr class="' + swalClasses.spacer + '">' + '<button class="' + swalClasses.confirm + '">OK</button>' + '<button class="' + swalClasses.cancel + '">Cancel</button>' + '<span class="' + swalClasses.close + '">&times;</span>' + '</div>';

    var extend = function(a, b) {
        for (var key in b) {
            if (b.hasOwnProperty(key)) {
                a[key] = b[key];
            }
        }

        return a;
    };

    /*
   * Set hover, active and focus-states for buttons (source: http://www.sitepoint.com/javascript-generate-lighter-darker-color)
   */
    var colorLuminance = function(hex, lum) {
        // Validate hex string
        hex = String(hex).replace(/[^0-9a-f]/gi, '');
        if (hex.length < 6) {
            hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }
        lum = lum || 0;

        // Convert to decimal and change luminosity
        var rgb = '#';
        for (var i = 0; i < 3; i++) {
            var c = parseInt(hex.substr(i * 2, 2), 16);
            c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
            rgb += ('00' + c).substr(c.length);
        }

        return rgb;
    };

    /*
   * check if variable is function type. http://stackoverflow.com/questions/5999998/how-can-i-check-if-a-javascript-variable-is-function-type
   */
    var isFunction = function(functionToCheck) {
        return typeof functionToCheck === 'function';
    };

    var mediaqueryId = swalPrefix + 'mediaquery';

    // Remember state in cases where opening and handling a modal will fiddle with it.
    var states = {
        previousWindowKeyDown: null,
        previousActiveElement: null
    };

    /*
   * Manipulate DOM
   */
    var elementByClass = function(className) {
        return document.querySelector('.' + className);
    };

    var getModal = function() {
        return elementByClass(swalClasses.modal);
    };

    var getOverlay = function() {
        return elementByClass(swalClasses.overlay);
    };

    var getConfirmButton = function() {
        return elementByClass(swalClasses.confirm);
    };

    var getCancelButton = function() {
        return elementByClass(swalClasses.cancel);
    };

    var getCloseButton = function() {
        return elementByClass(swalClasses.close);
    };

    var getFocusableElements = function(focusCancel) {
        var buttons = [getConfirmButton(), getCancelButton()];
        if (focusCancel) {
            buttons.reverse();
        }
        return buttons.concat(Array.prototype.slice.call(getModal().querySelectorAll('button:not([class^=' + swalPrefix + ']), input:not([type=hidden]), textarea, select')));
    };

    var hasClass = function(elem, className) {
        return elem.classList.contains(className);
    };

    var focusInput = function(input) {
        input.focus();

        // http://stackoverflow.com/a/2345915/1331425
        var val = input.value;
        input.value = '';
        input.value = val;
    };

    var addClass = function(elem, className) {
        if (!elem || !className) {
            return;
        }
        var classes = className.split(/\s+/);
        classes.forEach(function(className) {
            elem.classList.add(className);
        });
    };

    var removeClass = function(elem, className) {
        if (!elem || !className) {
            return;
        }
        var classes = className.split(/\s+/);
        classes.forEach(function(className) {
            elem.classList.remove(className);
        });
    };

    var getChildByClass = function(elem, className) {
        for (var i = 0; i < elem.childNodes.length; i++) {
            if (hasClass(elem.childNodes[i], className)) {
                return elem.childNodes[i];
            }
        }
    };

    var _show = function(elem) {
        elem.style.opacity = '';
        elem.style.display = 'block';
    };

    var show = function(elems) {
        if (elems && !elems.length) {
            return _show(elems);
        }
        for (var i = 0; i < elems.length; ++i) {
            _show(elems[i]);
        }
    };

    var _hide = function(elem) {
        elem.style.opacity = '';
        elem.style.display = 'none';
    };

    var hide = function(elems) {
        if (elems && !elems.length) {
            return _hide(elems);
        }
        for (var i = 0; i < elems.length; ++i) {
            _hide(elems[i]);
        }
    };

    // borrowed from jqeury $(elem).is(':visible') implementation
    var isVisible = function(elem) {
        return elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length;
    };

    var removeStyleProperty = function(elem, property) {
        if (elem.style.removeProperty) {
            elem.style.removeProperty(property);
        } else {
            elem.style.removeAttribute(property);
        }
    };

    var getTopMargin = function(elem) {
        var elemDisplay = elem.style.display;
        elem.style.left = '-9999px';
        elem.style.display = 'block';

        var height = elem.clientHeight;

        elem.style.left = '';
        elem.style.display = elemDisplay;
        return ('-' + parseInt(height / 2, 10) + 'px');
    };

    var fadeIn = function(elem, interval) {
        if (+elem.style.opacity < 1) {
            interval = interval || 16;
            elem.style.opacity = 0;
            elem.style.display = 'block';
            var last = +new Date();
            var tick = function() {
                var newOpacity = +elem.style.opacity + (new Date() - last) / 100;
                elem.style.opacity = (newOpacity > 1) ? 1 : newOpacity;
                last = +new Date();

                if (+elem.style.opacity < 1) {
                    setTimeout(tick, interval);
                }
            };
            tick();
        }
    };

    var fadeOut = function(elem, interval) {
        if (+elem.style.opacity > 0) {
            interval = interval || 16;
            var opacity = elem.style.opacity;
            var last = +new Date();
            var tick = function() {
                var change = new Date() - last;
                var newOpacity = +elem.style.opacity - change / (opacity * 100);
                elem.style.opacity = newOpacity;
                last = +new Date();

                if (+elem.style.opacity > 0) {
                    setTimeout(tick, interval);
                } else {
                    _hide(elem);
                }
            };
            tick();
        }
    };

    var fireClick = function(node) {
        // Taken from http://www.nonobtrusive.com/2011/11/29/programatically-fire-crossbrowser-click-event-with-javascript/
        // Then fixed for today's Chrome browser.
        if (typeof MouseEvent === 'function') {
            // Up-to-date approach
            var mevt = new MouseEvent('click',{
                view: window,
                bubbles: false,
                cancelable: true
            });
            node.dispatchEvent(mevt);
        } else if (document.createEvent) {
            // Fallback
            var evt = document.createEvent('MouseEvents');
            evt.initEvent('click', false, false);
            node.dispatchEvent(evt);
        } else if (document.createEventObject) {
            node.fireEvent('onclick');
        } else if (typeof node.onclick === 'function') {
            node.onclick();
        }
    };

    var stopEventPropagation = function(e) {
        // In particular, make sure the space bar doesn't scroll the main window.
        if (typeof e.stopPropagation === 'function') {
            e.stopPropagation();
            e.preventDefault();
        } else if (window.event && window.event.hasOwnProperty('cancelBubble')) {
            window.event.cancelBubble = true;
        }
    };

    var animationEndEvent = (function() {
        var testEl = document.createElement('div')
          , transEndEventNames = {
            'WebkitAnimation': 'webkitAnimationEnd',
            'OAnimation': 'oAnimationEnd oanimationend',
            'msAnimation': 'MSAnimationEnd',
            'animation': 'animationend'
        };
        for (var i in transEndEventNames) {
            if (transEndEventNames.hasOwnProperty(i) && testEl.style[i] !== undefined) {
                return transEndEventNames[i];
            }
        }

        return false;
    }
    )();

    // Reset the page to its previous state
    var resetPrevState = function() {
        var modal = getModal();
        window.onkeydown = states.previousWindowKeyDown;
        if (states.previousActiveElement && states.previousActiveElement.focus) {
            states.previousActiveElement.focus();
        }
        clearTimeout(modal.timeout);

        // Remove dynamically created media query
        var head = document.getElementsByTagName('head')[0];
        var mediaquery = document.getElementById(mediaqueryId);
        if (mediaquery) {
            head.removeChild(mediaquery);
        }
    };

    var modalParams = extend({}, defaultParams);

    /*
   * Set type, text and actions on modal
   */
    var setParameters = function(params) {
        var modal = getModal();

        for (var param in params) {
            if (!defaultParams.hasOwnProperty(param) && param !== 'extraParams') {
                console.warn('SweetAlert2: Unknown parameter "' + param + '"');
            }
        }

        // set modal width, padding and margin-left
        modal.style.width = params.width + 'px';
        modal.style.padding = params.padding + 'px';
        modal.style.marginLeft = -params.width / 2 + 'px';
        modal.style.background = params.background;

        // add dynamic media query css
        var head = document.getElementsByTagName('head')[0];
        var cssNode = document.createElement('style');
        cssNode.type = 'text/css';
        cssNode.id = mediaqueryId;
        var margin = 5;
        // %
        var mediaQueryMaxWidth = params.width + parseInt(params.width * (margin / 100) * 2, 10);
        cssNode.innerHTML = '@media screen and (max-width: ' + mediaQueryMaxWidth + 'px) {' + '.' + swalClasses.modal + ' {' + 'width: auto !important;' + 'left: ' + margin + '% !important;' + 'right: ' + margin + '% !important;' + 'margin-left: 0 !important;' + '}' + '}';
        head.appendChild(cssNode);

        var $title = modal.querySelector('h2');
        var $content = modal.querySelector('.' + swalClasses.content);
        var $confirmBtn = getConfirmButton();
        var $cancelBtn = getCancelButton();
        var $spacer = modal.querySelector('.' + swalClasses.spacer);
        var $closeButton = modal.querySelector('.' + swalClasses.close);

        // Title
        $title.innerHTML = params.title.split('\n').join('<br>');

        // Content
        if (params.text || params.html) {
            if (typeof params.html === 'object') {
                $content.innerHTML = '';
                if (0 in params.html) {
                    for (var i = 0; i in params.html; i++) {
                        $content.appendChild(params.html[i]);
                    }
                } else {
                    $content.appendChild(params.html);
                }
            } else {
                $content.innerHTML = params.html || (params.text.split('\n').join('<br>'));
            }
            show($content);
        } else {
            hide($content);
        }

        // Close button
        if (params.showCloseButton) {
            show($closeButton);
        } else {
            hide($closeButton);
        }

        // Custom Class
        modal.className = swalClasses.modal;
        if (params.customClass) {
            addClass(modal, params.customClass);
        }

        // Icon
        hide(modal.querySelectorAll('.' + swalClasses.icon));
        if (params.type) {
            var validType = false;
            for (var iconType in iconTypes) {
                if (params.type === iconType) {
                    validType = true;
                    break;
                }
            }
            if (!validType) {
                console.error('SweetAlert2: Unknown alert type: ' + params.type);
                return false;
            }
            var $icon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes[params.type]);
            show($icon);

            // Animate icon
            switch (params.type) {
            case 'success':
                addClass($icon, 'animate');
                addClass($icon.querySelector('.tip'), 'animate-success-tip');
                addClass($icon.querySelector('.long'), 'animate-success-long');
                break;
            case 'error':
                addClass($icon, 'animate-error-icon');
                addClass($icon.querySelector('.x-mark'), 'animate-x-mark');
                break;
            case 'warning':
                addClass($icon, 'pulse-warning');
                break;
            default:
                break;
            }

        }

        // Custom image
        var $customImage = modal.querySelector('.' + swalClasses.image);
        if (params.imageUrl) {
            $customImage.setAttribute('src', params.imageUrl);
            show($customImage);

            if (params.imageWidth) {
                $customImage.setAttribute('width', params.imageWidth);
            } else {
                $customImage.removeAttribute('width');
            }

            if (params.imageHeight) {
                $customImage.setAttribute('height', params.imageHeight);
            } else {
                $customImage.removeAttribute('height');
            }

            $customImage.className = swalClasses.image;
            if (params.imageClass) {
                addClass($customImage, params.imageClass);
            }
        } else {
            hide($customImage);
        }

        // Cancel button
        if (params.showCancelButton) {
            $cancelBtn.style.display = 'inline-block';
        } else {
            hide($cancelBtn);
        }

        // Confirm button
        if (params.showConfirmButton) {
            removeStyleProperty($confirmBtn, 'display');
        } else {
            hide($confirmBtn);
        }

        // Buttons spacer
        if (!params.showConfirmButton && !params.showCancelButton) {
            hide($spacer);
        } else {
            show($spacer);
        }

        // Edit text on cancel and confirm buttons
        $confirmBtn.innerHTML = params.confirmButtonText;
        $cancelBtn.innerHTML = params.cancelButtonText;

        // Set buttons to selected background colors
        if (params.buttonsStyling) {
            $confirmBtn.style.backgroundColor = params.confirmButtonColor;
            $cancelBtn.style.backgroundColor = params.cancelButtonColor;
        }

        // Add buttons custom classes
        $confirmBtn.className = swalClasses.confirm;
        addClass($confirmBtn, params.confirmButtonClass);
        $cancelBtn.className = swalClasses.cancel;
        addClass($cancelBtn, params.cancelButtonClass);

        // Buttons styling
        if (params.buttonsStyling) {
            addClass($confirmBtn, 'styled');
            addClass($cancelBtn, 'styled');
        } else {
            removeClass($confirmBtn, 'styled');
            removeClass($cancelBtn, 'styled');

            $confirmBtn.style.backgroundColor = $confirmBtn.style.borderLeftColor = $confirmBtn.style.borderRightColor = '';
            $cancelBtn.style.backgroundColor = $cancelBtn.style.borderLeftColor = $cancelBtn.style.borderRightColor = '';
        }

        // CSS animation
        if (params.animation === true) {
            removeClass(modal, 'no-animation');
        } else {
            addClass(modal, 'no-animation');
        }
    };

    /*
   * Animations
   */
    var openModal = function(animation, onComplete) {
        var modal = getModal();
        if (animation) {
            fadeIn(getOverlay(), 10);
            addClass(modal, 'show-swal2');
            removeClass(modal, 'hide-swal2');
        } else {
            show(getOverlay());
        }
        show(modal);
        states.previousActiveElement = document.activeElement;
        if (onComplete !== null && typeof onComplete === 'function') {
            onComplete.call(this, modal);
        }
    };

    /*
   * Set 'margin-top'-property on modal based on its computed height
   */
    var fixVerticalPosition = function() {
        var modal = getModal();

        if (modal !== null) {
            modal.style.marginTop = getTopMargin(modal);
        }
    };

    function modalDependant() {

        if (arguments[0] === undefined) {
            console.error('SweetAlert2 expects at least 1 attribute!');
            return false;
        }

        var params = extend({}, modalParams);

        switch (typeof arguments[0]) {

        case 'string':
            params.title = arguments[0];
            params.text = arguments[1] || '';
            params.type = arguments[2] || '';

            break;

        case 'object':
            extend(params, arguments[0]);
            params.extraParams = arguments[0].extraParams;

            if (params.input === 'email' && params.inputValidator === null) {
                params.inputValidator = function(email) {
                    return new Promise(function(resolve, reject) {
                        var emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
                        if (emailRegex.test(email)) {
                            resolve();
                        } else {
                            reject('Invalid email address');
                        }
                    }
                    );
                }
                ;
            }

            break;

        default:
            console.error('SweetAlert2: Unexpected type of argument! Expected "string" or "object", got ' + typeof arguments[0]);
            return false;
        }

        setParameters(params);

        // Modal interactions
        var modal = getModal();

        return new Promise(function(resolve, reject) {
            // Close on timer
            if (params.timer) {
                modal.timeout = setTimeout(function() {
                    sweetAlert.closeModal(params.onClose);
                    reject('timer');
                }, params.timer);
            }

            var getInput = function() {
                switch (params.input) {
                case 'select':
                    return getChildByClass(modal, swalClasses.select);
                case 'radio':
                    return modal.querySelector('.' + swalClasses.radio + ' input:checked') || modal.querySelector('.' + swalClasses.radio + ' input:first-child');
                case 'checkbox':
                    return modal.querySelector('#' + swalClasses.checkbox);
                case 'textarea':
                    return getChildByClass(modal, swalClasses.textarea);
                default:
                    return getChildByClass(modal, swalClasses.input);
                }
            };
            var getInputValue = function() {
                var input = getInput();
                switch (params.input) {
                case 'checkbox':
                    return input.checked ? 1 : 0;
                case 'radio':
                    return input.checked ? input.value : null;
                case 'file':
                    return input.files.length ? input.files[0] : null;
                default:
                    return params.inputAutoTrim ? input.value.trim() : input.value;
                }
            };

            if (params.input) {
                setTimeout(function() {
                    var input = getInput();
                    if (input) {
                        focusInput(input);
                    }
                }, 0);
            }

            var confirm = function(value) {
                if (params.showLoaderOnConfirm) {
                    sweetAlert.showLoading();
                }

                if (params.preConfirm) {
                    params.preConfirm(value, params.extraParams).then(function(preConfirmValue) {
                        sweetAlert.closeModal(params.onClose);
                        resolve(preConfirmValue || value);
                    }, function(error) {
                        sweetAlert.hideLoading();
                        if (error) {
                            sweetAlert.showValidationError(error);
                        }
                    });
                } else {
                    sweetAlert.closeModal(params.onClose);
                    resolve(value);
                }
            };

            // Mouse interactions
            var onButtonEvent = function(event) {
                var e = event || window.event;
                var target = e.target || e.srcElement;
                var confirmBtn = getConfirmButton();
                var cancelBtn = getCancelButton();
                var targetedConfirm = confirmBtn === target || confirmBtn.contains(target);
                var targetedCancel = cancelBtn === target || cancelBtn.contains(target);

                switch (e.type) {
                case 'mouseover':
                case 'mouseup':
                    if (params.buttonsStyling) {
                        if (targetedConfirm) {
                            confirmBtn.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.1);
                        } else if (targetedCancel) {
                            cancelBtn.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.1);
                        }
                    }
                    break;
                case 'mouseout':
                    if (params.buttonsStyling) {
                        if (targetedConfirm) {
                            confirmBtn.style.backgroundColor = params.confirmButtonColor;
                        } else if (targetedCancel) {
                            cancelBtn.style.backgroundColor = params.cancelButtonColor;
                        }
                    }
                    break;
                case 'mousedown':
                    if (params.buttonsStyling) {
                        if (targetedConfirm) {
                            confirmBtn.style.backgroundColor = colorLuminance(params.confirmButtonColor, -0.2);
                        } else if (targetedCancel) {
                            cancelBtn.style.backgroundColor = colorLuminance(params.cancelButtonColor, -0.2);
                        }
                    }
                    break;
                case 'click':
                    // Clicked 'confirm'
                    if (targetedConfirm && sweetAlert.isVisible()) {
                        if (params.input) {
                            var inputValue = getInputValue();

                            if (params.inputValidator) {
                                sweetAlert.disableInput();
                                params.inputValidator(inputValue, params.extraParams).then(function() {
                                    sweetAlert.enableInput();
                                    confirm(inputValue);
                                }, function(error) {
                                    sweetAlert.enableInput();
                                    if (error) {
                                        sweetAlert.showValidationError(error);
                                    }
                                });
                            } else {
                                confirm(inputValue);
                            }

                        } else {
                            confirm(true);
                        }

                        // Clicked 'cancel'
                    } else if (targetedCancel && sweetAlert.isVisible()) {
                        sweetAlert.closeModal(params.onClose);
                        reject('cancel');
                    }

                    break;
                default:
                }
            };

            var $buttons = modal.querySelectorAll('button');
            var i;
            for (i = 0; i < $buttons.length; i++) {
                $buttons[i].onclick = onButtonEvent;
                $buttons[i].onmouseover = onButtonEvent;
                $buttons[i].onmouseout = onButtonEvent;
                $buttons[i].onmousedown = onButtonEvent;
            }

            // Closing modal by close button
            getCloseButton().onclick = function() {
                sweetAlert.closeModal(params.onClose);
                reject('close');
            }
            ;

            // Closing modal by overlay click
            getOverlay().onclick = function() {
                if (params.allowOutsideClick) {
                    sweetAlert.closeModal(params.onClose);
                    reject('overlay');
                }
            }
            ;

            var $confirmButton = getConfirmButton();
            var $cancelButton = getCancelButton();

            // Reverse buttons if neede d
            if (params.reverseButtons) {
                $confirmButton.parentNode.insertBefore($cancelButton, $confirmButton);
            } else {
                $confirmButton.parentNode.insertBefore($confirmButton, $cancelButton);
            }

            // Focus handling
            function setFocus(index, increment) {
                var focusableElements = getFocusableElements(params.focusCancel);
                // search for visible elements and select the next possible match
                for (var i = 0; i < focusableElements.length; i++) {
                    index = index + increment;

                    // rollover to first item
                    if (index === focusableElements.length) {
                        index = 0;

                        // go to last item
                    } else if (index === -1) {
                        index = focusableElements.length - 1;
                    }

                    // determine if element is visible
                    var el = focusableElements[index];
                    if (isVisible(el)) {
                        return el.focus();
                    }
                }
            }

            function handleKeyDown(event) {
                var e = event || window.event;
                var keyCode = e.keyCode || e.which;

                if ([9, 13, 32, 27].indexOf(keyCode) === -1) {
                    // Don't do work on keys we don't care about.
                    return;
                }

                var $targetElement = e.target || e.srcElement;

                var focusableElements = getFocusableElements(params.focusCancel);
                var btnIndex = -1;
                // Find the button - note, this is a nodelist, not an array.
                for (var i = 0; i < focusableElements.length; i++) {
                    if ($targetElement === focusableElements[i]) {
                        btnIndex = i;
                        break;
                    }
                }

                // TAB
                if (keyCode === 9) {
                    if (!e.shiftKey) {
                        // Cycle to the next button
                        setFocus(btnIndex, 1);
                    } else {
                        // Cycle to the prev button
                        setFocus(btnIndex, -1);
                    }

                    stopEventPropagation(e);

                } else {
                    if (keyCode === 13 || keyCode === 32) {
                        if (btnIndex === -1) {
                            // ENTER/SPACE clicked outside of a button.
                            if (params.focusCancel) {
                                fireClick($cancelButton, e);
                            } else {
                                fireClick($confirmButton, e);
                            }
                        }
                    } else if (keyCode === 27 && params.allowEscapeKey === true) {
                        sweetAlert.closeModal(params.onClose);
                        reject('esc');
                    }
                }
            }

            states.previousWindowKeyDown = window.onkeydown;
            window.onkeydown = handleKeyDown;

            // Loading state
            if (params.buttonsStyling) {
                $confirmButton.style.borderLeftColor = params.confirmButtonColor;
                $confirmButton.style.borderRightColor = params.confirmButtonColor;
            }

            /**
       * Show spinner instead of Confirm button and disable Cancel button
       */
            sweetAlert.showLoading = sweetAlert.enableLoading = function() {
                addClass($confirmButton, 'loading');
                addClass(modal, 'loading');
                $confirmButton.disabled = true;
                $cancelButton.disabled = true;
            }
            ;

            /**
       * Show spinner instead of Confirm button and disable Cancel button
       */
            sweetAlert.hideLoading = sweetAlert.disableLoading = function() {
                removeClass($confirmButton, 'loading');
                removeClass(modal, 'loading');
                $confirmButton.disabled = false;
                $cancelButton.disabled = false;
            }
            ;

            sweetAlert.enableButtons = function() {
                $confirmButton.disabled = false;
                $cancelButton.disabled = false;
            }
            ;

            sweetAlert.disableButtons = function() {
                $confirmButton.disabled = true;
                $cancelButton.disabled = true;
            }
            ;

            sweetAlert.enableConfirmButton = function() {
                $confirmButton.disabled = false;
            }
            ;

            sweetAlert.disableConfirmButton = function() {
                $confirmButton.disabled = true;
            }
            ;

            sweetAlert.enableInput = function() {
                var input = getInput();
                if (input.type === 'radio') {
                    var radiosContainer = input.parentNode.parentNode;
                    var radios = radiosContainer.querySelectorAll('input');
                    for (var i = 0; i < radios.length; i++) {
                        radios[i].disabled = false;
                    }
                } else {
                    input.disabled = false;
                }
            }
            ;

            sweetAlert.disableInput = function() {
                var input = getInput();
                if (input.type === 'radio') {
                    var radiosContainer = input.parentNode.parentNode;
                    var radios = radiosContainer.querySelectorAll('input');
                    for (var i = 0; i < radios.length; i++) {
                        radios[i].disabled = true;
                    }
                } else {
                    input.disabled = true;
                }
            }
            ;

            sweetAlert.showValidationError = function(error) {
                var $validationError = modal.querySelector('.' + swalClasses.validationerror);
                $validationError.innerHTML = error;
                show($validationError);

                var input = getInput();
                focusInput(input);
                addClass(input, 'error');
            }
            ;

            sweetAlert.resetValidationError = function() {
                var $validationError = modal.querySelector('.' + swalClasses.validationerror);
                hide($validationError);

                var input = getInput();
                if (input) {
                    removeClass(input, 'error');
                }
            }
            ;

            sweetAlert.enableButtons();
            sweetAlert.hideLoading();
            sweetAlert.resetValidationError();

            // input, select
            var inputTypes = ['input', 'select', 'radio', 'checkbox', 'textarea'];
            var input;
            for (i = 0; i < inputTypes.length; i++) {
                var inputClass = swalClasses[inputTypes[i]];
                input = getChildByClass(modal, inputClass);

                // set attributes
                while (input.attributes.length > 0) {
                    input.removeAttribute(input.attributes[0].name);
                }
                for (var attr in params.inputAttributes) {
                    input.setAttribute(attr, params.inputAttributes[attr]);
                }

                // set class
                input.className = inputClass;
                if (params.inputClass) {
                    addClass(input, params.inputClass);
                }

                _hide(input);
            }

            var populateInputOptions;
            switch (params.input) {
            case 'text':
            case 'email':
            case 'password':
            case 'file':
                input = getChildByClass(modal, swalClasses.input);
                input.value = params.inputValue;
                input.placeholder = params.inputPlaceholder;
                input.type = params.input;
                _show(input);
                break;
            case 'select':
                var select = getChildByClass(modal, swalClasses.select);
                select.innerHTML = '';
                if (params.inputPlaceholder) {
                    var placeholder = document.createElement('option');
                    placeholder.innerHTML = params.inputPlaceholder;
                    placeholder.value = '';
                    placeholder.disabled = true;
                    placeholder.selected = true;
                    select.appendChild(placeholder);
                }
                populateInputOptions = function(inputOptions) {
                    for (var optionValue in inputOptions) {
                        var option = document.createElement('option');
                        option.value = optionValue;
                        option.innerHTML = inputOptions[optionValue];
                        if (params.inputValue === optionValue) {
                            option.selected = true;
                        }
                        select.appendChild(option);
                    }
                    _show(select);
                    select.focus();
                }
                ;
                break;
            case 'radio':
                var radio = getChildByClass(modal, swalClasses.radio);
                radio.innerHTML = '';
                populateInputOptions = function(inputOptions) {
                    for (var radioValue in inputOptions) {
                        var id = 1;
                        var radioInput = document.createElement('input');
                        var radioLabel = document.createElement('label');
                        var radioLabelSpan = document.createElement('span');
                        radioInput.type = 'radio';
                        radioInput.name = swalClasses.radio;
                        radioInput.value = radioValue;
                        radioInput.id = swalClasses.radio + '-' + (id++);
                        if (params.inputValue === radioValue) {
                            radioInput.checked = true;
                        }
                        radioLabelSpan.innerHTML = inputOptions[radioValue];
                        radioLabel.appendChild(radioInput);
                        radioLabel.appendChild(radioLabelSpan);
                        radioLabel.for = radioInput.id;
                        radio.appendChild(radioLabel);
                    }
                    _show(radio);
                    var radios = radio.querySelectorAll('input');
                    if (radios.length) {
                        radios[0].focus();
                    }
                }
                ;
                break;
            case 'checkbox':
                var checkbox = getChildByClass(modal, swalClasses.checkbox);
                var checkboxInput = modal.querySelector('#' + swalClasses.checkbox);
                checkboxInput.value = 1;
                checkboxInput.checked = Boolean(params.inputValue);
                var label = checkbox.getElementsByTagName('span');
                if (label.length) {
                    checkbox.removeChild(label[0]);
                }
                label = document.createElement('span');
                label.innerHTML = params.inputPlaceholder;
                checkbox.appendChild(label);
                _show(checkbox);
                break;
            case 'textarea':
                var textarea = getChildByClass(modal, swalClasses.textarea);
                textarea.value = params.inputValue;
                textarea.placeholder = params.inputPlaceholder;
                _show(textarea);
                break;
            case null:
                break;
            default:
                console.error('SweetAlert2: Unexpected type of input! Expected "text" or "email" or "password", "select", "checkbox", "textarea" or "file", got "' + params.input + '"');
                break;
            }

            if (params.input === 'select' || params.input === 'radio') {
                if (params.inputOptions instanceof Promise) {
                    sweetAlert.showLoading();
                    params.inputOptions.then(function(inputOptions) {
                        sweetAlert.hideLoading();
                        populateInputOptions(inputOptions);
                    });
                } else if (typeof params.inputOptions === 'object') {
                    populateInputOptions(params.inputOptions);
                } else {
                    console.error('SweetAlert2: Unexpected type of inputOptions! Expected object or Promise, got ' + typeof params.inputOptions);
                }
            }

            fixVerticalPosition();
            openModal(params.animation, params.onOpen);

            // Focus the first element (input or button)
            setFocus(-1, 1);
        }
        );
    }

    // SweetAlert function
    function sweetAlert() {
        // Copy arguments to the local args variable
        var args = arguments;
        var modal = getModal();

        if (modal === null) {
            sweetAlert.init();
            modal = getModal();
        }

        if (sweetAlert.isVisible()) {
            resetPrevState();
        }

        return modalDependant.apply(this, args);
    }

    /*
   * Global function to determine if swal2 modal is visible
   */
    sweetAlert.isVisible = function() {
        var modal = getModal();
        return isVisible(modal);
    }
    ;

    /*
   * Global function for chaining sweetAlert modals
   */
    sweetAlert.queue = function(steps) {
        return new Promise(function(resolve, reject) {
            (function step(i, callback) {
                var nextStep = null;
                if (isFunction(steps)) {
                    nextStep = steps(i);
                } else if (i < steps.length) {
                    nextStep = steps[i];
                }
                if (nextStep) {
                    sweetAlert(nextStep).then(function() {
                        step(i + 1, callback);
                    }, function(dismiss) {
                        reject(dismiss);
                    });
                } else {
                    resolve();
                }
            }
            )(0);
        }
        );
    }
    ;

    /*
   * Global function to close sweetAlert
   */
    sweetAlert.close = sweetAlert.closeModal = function(onComplete) {
        var modal = getModal();
        removeClass(modal, 'show-swal2');
        addClass(modal, 'hide-swal2');

        // Reset icon animations
        var $successIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.success);
        removeClass($successIcon, 'animate');
        removeClass($successIcon.querySelector('.tip'), 'animate-success-tip');
        removeClass($successIcon.querySelector('.long'), 'animate-success-long');

        var $errorIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.error);
        removeClass($errorIcon, 'animate-error-icon');
        removeClass($errorIcon.querySelector('.x-mark'), 'animate-x-mark');

        var $warningIcon = modal.querySelector('.' + swalClasses.icon + '.' + iconTypes.warning);
        removeClass($warningIcon, 'pulse-warning');

        // If animation is supported, animate then clean
        if (animationEndEvent && !hasClass(modal, 'no-animation')) {
            modal.addEventListener(animationEndEvent, function swalCloseEventFinished() {
                modal.removeEventListener(animationEndEvent, swalCloseEventFinished);
                if (hasClass(modal, 'hide-swal2')) {
                    _hide(modal);
                    fadeOut(getOverlay(), 0);
                }

                resetPrevState();
            });
        } else {
            // Otherwise, clean immediately
            _hide(modal);
            _hide(getOverlay());
            resetPrevState();
        }
        if (onComplete !== null && typeof onComplete === 'function') {
            onComplete.call(this, modal);
        }
    }
    ;

    /*
   * Global function to click 'Confirm' button
   */
    sweetAlert.clickConfirm = function() {
        getConfirmButton().click();
    }
    ;

    /*
   * Global function to click 'Cancel' button
   */
    sweetAlert.clickCancel = function() {
        getCancelButton().click();
    }
    ;

    /*
   * Add modal + overlay to DOM
   */
    sweetAlert.init = function() {
        if (typeof document === 'undefined') {
            console.log('SweetAlert2 requires document to initialize');
            return;
        } else if (document.getElementsByClassName(swalClasses.container).length) {
            return;
        }

        var sweetWrap = document.createElement('div');
        sweetWrap.className = swalClasses.container;

        sweetWrap.innerHTML = sweetHTML;

        document.body.appendChild(sweetWrap);

        var modal = getModal();
        var $input = getChildByClass(modal, swalClasses.input);
        var $select = getChildByClass(modal, swalClasses.select);
        var $checkbox = modal.querySelector('#' + swalClasses.checkbox);
        var $textarea = getChildByClass(modal, swalClasses.textarea);
        var $customImg = getChildByClass(modal, swalClasses.image);

        $input.oninput = function() {
            sweetAlert.resetValidationError();
        }
        ;

        $input.onkeyup = function(event) {
            event.stopPropagation();
            if (event.keyCode === 13) {
                sweetAlert.clickConfirm();
            }
        }
        ;

        $select.onchange = function() {
            sweetAlert.resetValidationError();
        }
        ;

        $checkbox.onchange = function() {
            sweetAlert.resetValidationError();
        }
        ;

        $textarea.oninput = function() {
            sweetAlert.resetValidationError();
        }
        ;

        $customImg.onload = $customImg.onerror = fixVerticalPosition;

        window.addEventListener('resize', fixVerticalPosition, false);
    }
    ;

    /**
   * Set default params for each popup
   * @param {Object} userParams
   */
    sweetAlert.setDefaults = function(userParams) {
        if (!userParams) {
            throw new Error('userParams is required');
        }
        if (typeof userParams !== 'object') {
            throw new Error('userParams has to be a object');
        }

        extend(modalParams, userParams);
    }
    ;

    /**
   * Reset default params for each popup
   */
    sweetAlert.resetDefaults = function() {
        modalParams = extend({}, defaultParams);
    }
    ;

    sweetAlert.version = '4.1.9';

    window.sweetAlert = window.swal = sweetAlert;

    /*
  * If library is injected after page has loaded
  */
    (function() {
        if (document.readyState === 'complete' || document.readyState === 'interactive' && document.body) {
            sweetAlert.init();
        } else {
            document.addEventListener('DOMContentLoaded', function onDomContentLoaded() {
                document.removeEventListener('DOMContentLoaded', onDomContentLoaded, false);
                sweetAlert.init();
            }, false);
        }
    }
    )();

    if (typeof Promise === 'function') {
        Promise.prototype.done = Promise.prototype.done || function() {
            return this.catch(function() {// Catch promise rejections silently.
            // https://github.com/limonte/sweetalert2/issues/177
            });
        }
        ;
    } else {
        console.warn('SweetAlert2: Please inlude Promise polyfill BEFORE including sweetalert2.js if IE10+ support needed.');
    }

    return sweetAlert;

}));
/*! PhotoSwipe - v4.1.2 - 2017-04-05
* http://photoswipe.com
* Copyright (c) 2017 Dmitry Semenov; */
!function(a, b) {
    "function" == typeof define && define.amd ? define(b) : "object" == typeof exports ? module.exports = b() : a.PhotoSwipe = b()
}(this, function() {
    "use strict";
    var a = function(a, b, c, d) {
        var e = {
            features: null,
            bind: function(a, b, c, d) {
                var e = (d ? "remove" : "add") + "EventListener";
                b = b.split(" ");
                for (var f = 0; f < b.length; f++)
                    b[f] && a[e](b[f], c, !1)
            },
            isArray: function(a) {
                return a instanceof Array
            },
            createEl: function(a, b) {
                var c = document.createElement(b || "div");
                return a && (c.className = a),
                c
            },
            getScrollY: function() {
                var a = window.pageYOffset;
                return void 0 !== a ? a : document.documentElement.scrollTop
            },
            unbind: function(a, b, c) {
                e.bind(a, b, c, !0)
            },
            removeClass: function(a, b) {
                var c = new RegExp("(\\s|^)" + b + "(\\s|$)");
                a.className = a.className.replace(c, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")
            },
            addClass: function(a, b) {
                e.hasClass(a, b) || (a.className += (a.className ? " " : "") + b)
            },
            hasClass: function(a, b) {
                return a.className && new RegExp("(^|\\s)" + b + "(\\s|$)").test(a.className)
            },
            getChildByClass: function(a, b) {
                for (var c = a.firstChild; c; ) {
                    if (e.hasClass(c, b))
                        return c;
                    c = c.nextSibling
                }
            },
            arraySearch: function(a, b, c) {
                for (var d = a.length; d--; )
                    if (a[d][c] === b)
                        return d;
                return -1
            },
            extend: function(a, b, c) {
                for (var d in b)
                    if (b.hasOwnProperty(d)) {
                        if (c && a.hasOwnProperty(d))
                            continue;
                        a[d] = b[d]
                    }
            },
            easing: {
                sine: {
                    out: function(a) {
                        return Math.sin(a * (Math.PI / 2))
                    },
                    inOut: function(a) {
                        return -(Math.cos(Math.PI * a) - 1) / 2
                    }
                },
                cubic: {
                    out: function(a) {
                        return --a * a * a + 1
                    }
                }
            },
            detectFeatures: function() {
                if (e.features)
                    return e.features;
                var a = e.createEl()
                  , b = a.style
                  , c = ""
                  , d = {};
                if (d.oldIE = document.all && !document.addEventListener,
                d.touch = "ontouchstart"in window,
                window.requestAnimationFrame && (d.raf = window.requestAnimationFrame,
                d.caf = window.cancelAnimationFrame),
                d.pointerEvent = navigator.pointerEnabled || navigator.msPointerEnabled,
                !d.pointerEvent) {
                    var f = navigator.userAgent;
                    if (/iP(hone|od)/.test(navigator.platform)) {
                        var g = navigator.appVersion.match(/OS (\d+)_(\d+)_?(\d+)?/);
                        g && g.length > 0 && (g = parseInt(g[1], 10),
                        g >= 1 && g < 8 && (d.isOldIOSPhone = !0))
                    }
                    var h = f.match(/Android\s([0-9\.]*)/)
                      , i = h ? h[1] : 0;
                    i = parseFloat(i),
                    i >= 1 && (i < 4.4 && (d.isOldAndroid = !0),
                    d.androidVersion = i),
                    d.isMobileOpera = /opera mini|opera mobi/i.test(f)
                }
                for (var j, k, l = ["transform", "perspective", "animationName"], m = ["", "webkit", "Moz", "ms", "O"], n = 0; n < 4; n++) {
                    c = m[n];
                    for (var o = 0; o < 3; o++)
                        j = l[o],
                        k = c + (c ? j.charAt(0).toUpperCase() + j.slice(1) : j),
                        !d[j] && k in b && (d[j] = k);
                    c && !d.raf && (c = c.toLowerCase(),
                    d.raf = window[c + "RequestAnimationFrame"],
                    d.raf && (d.caf = window[c + "CancelAnimationFrame"] || window[c + "CancelRequestAnimationFrame"]))
                }
                if (!d.raf) {
                    var p = 0;
                    d.raf = function(a) {
                        var b = (new Date).getTime()
                          , c = Math.max(0, 16 - (b - p))
                          , d = window.setTimeout(function() {
                            a(b + c)
                        }, c);
                        return p = b + c,
                        d
                    }
                    ,
                    d.caf = function(a) {
                        clearTimeout(a)
                    }
                }
                return d.svg = !!document.createElementNS && !!document.createElementNS("http://www.w3.org/2000/svg", "svg").createSVGRect,
                e.features = d,
                d
            }
        };
        e.detectFeatures(),
        e.features.oldIE && (e.bind = function(a, b, c, d) {
            b = b.split(" ");
            for (var e, f = (d ? "detach" : "attach") + "Event", g = function() {
                c.handleEvent.call(c)
            }, h = 0; h < b.length; h++)
                if (e = b[h])
                    if ("object" == typeof c && c.handleEvent) {
                        if (d) {
                            if (!c["oldIE" + e])
                                return !1
                        } else
                            c["oldIE" + e] = g;
                        a[f]("on" + e, c["oldIE" + e])
                    } else
                        a[f]("on" + e, c)
        }
        );
        var f = this
          , g = 25
          , h = 3
          , i = {
            allowPanToNext: !0,
            spacing: .12,
            bgOpacity: 1,
            mouseUsed: !1,
            loop: !0,
            pinchToClose: !0,
            closeOnScroll: !0,
            closeOnVerticalDrag: !0,
            verticalDragRange: .75,
            hideAnimationDuration: 333,
            showAnimationDuration: 333,
            showHideOpacity: !1,
            focus: !0,
            escKey: !0,
            arrowKeys: !0,
            mainScrollEndFriction: .35,
            panEndFriction: .35,
            isClickableElement: function(a) {
                return "A" === a.tagName
            },
            getDoubleTapZoom: function(a, b) {
                return a ? 1 : b.initialZoomLevel < .7 ? 1 : 1.33
            },
            maxSpreadZoom: 1.33,
            modal: !0,
            scaleMode: "fit"
        };
        e.extend(i, d);
        var j, k, l, m, n, o, p, q, r, s, t, u, v, w, x, y, z, A, B, C, D, E, F, G, H, I, J, K, L, M, N, O, P, Q, R, S, T, U, V, W, X, Y, Z, $, _, aa, ba, ca, da, ea, fa, ga, ha, ia, ja, ka, la, ma = function() {
            return {
                x: 0,
                y: 0
            }
        }, na = ma(), oa = ma(), pa = ma(), qa = {}, ra = 0, sa = {}, ta = ma(), ua = 0, va = !0, wa = [], xa = {}, ya = !1, za = function(a, b) {
            e.extend(f, b.publicMethods),
            wa.push(a)
        }, Aa = function(a) {
            var b = ac();
            return a > b - 1 ? a - b : a < 0 ? b + a : a
        }, Ba = {}, Ca = function(a, b) {
            return Ba[a] || (Ba[a] = []),
            Ba[a].push(b)
        }, Da = function(a) {
            var b = Ba[a];
            if (b) {
                var c = Array.prototype.slice.call(arguments);
                c.shift();
                for (var d = 0; d < b.length; d++)
                    b[d].apply(f, c)
            }
        }, Ea = function() {
            return (new Date).getTime()
        }, Fa = function(a) {
            ja = a,
            f.bg.style.opacity = a * i.bgOpacity
        }, Ga = function(a, b, c, d, e) {
            (!ya || e && e !== f.currItem) && (d /= e ? e.fitRatio : f.currItem.fitRatio),
            a[E] = u + b + "px, " + c + "px" + v + " scale(" + d + ")"
        }, Ha = function(a) {
            ea && (a && (s > f.currItem.fitRatio ? ya || (mc(f.currItem, !1, !0),
            ya = !0) : ya && (mc(f.currItem),
            ya = !1)),
            Ga(ea, pa.x, pa.y, s))
        }, Ia = function(a) {
            a.container && Ga(a.container.style, a.initialPosition.x, a.initialPosition.y, a.initialZoomLevel, a)
        }, Ja = function(a, b) {
            b[E] = u + a + "px, 0px" + v
        }, Ka = function(a, b) {
            if (!i.loop && b) {
                var c = m + (ta.x * ra - a) / ta.x
                  , d = Math.round(a - tb.x);
                (c < 0 && d > 0 || c >= ac() - 1 && d < 0) && (a = tb.x + d * i.mainScrollEndFriction)
            }
            tb.x = a,
            Ja(a, n)
        }, La = function(a, b) {
            var c = ub[a] - sa[a];
            return oa[a] + na[a] + c - c * (b / t)
        }, Ma = function(a, b) {
            a.x = b.x,
            a.y = b.y,
            b.id && (a.id = b.id)
        }, Na = function(a) {
            a.x = Math.round(a.x),
            a.y = Math.round(a.y)
        }, Oa = null, Pa = function() {
            Oa && (e.unbind(document, "mousemove", Pa),
            e.addClass(a, "pswp--has_mouse"),
            i.mouseUsed = !0,
            Da("mouseUsed")),
            Oa = setTimeout(function() {
                Oa = null
            }, 100)
        }, Qa = function() {
            e.bind(document, "keydown", f),
            N.transform && e.bind(f.scrollWrap, "click", f),
            i.mouseUsed || e.bind(document, "mousemove", Pa),
            e.bind(window, "resize scroll orientationchange", f),
            Da("bindEvents")
        }, Ra = function() {
            e.unbind(window, "resize scroll orientationchange", f),
            e.unbind(window, "scroll", r.scroll),
            e.unbind(document, "keydown", f),
            e.unbind(document, "mousemove", Pa),
            N.transform && e.unbind(f.scrollWrap, "click", f),
            V && e.unbind(window, p, f),
            clearTimeout(O),
            Da("unbindEvents")
        }, Sa = function(a, b) {
            var c = ic(f.currItem, qa, a);
            return b && (da = c),
            c
        }, Ta = function(a) {
            return a || (a = f.currItem),
            a.initialZoomLevel
        }, Ua = function(a) {
            return a || (a = f.currItem),
            a.w > 0 ? i.maxSpreadZoom : 1
        }, Va = function(a, b, c, d) {
            return d === f.currItem.initialZoomLevel ? (c[a] = f.currItem.initialPosition[a],
            !0) : (c[a] = La(a, d),
            c[a] > b.min[a] ? (c[a] = b.min[a],
            !0) : c[a] < b.max[a] && (c[a] = b.max[a],
            !0))
        }, Wa = function() {
            if (E) {
                var b = N.perspective && !G;
                return u = "translate" + (b ? "3d(" : "("),
                void (v = N.perspective ? ", 0px)" : ")")
            }
            E = "left",
            e.addClass(a, "pswp--ie"),
            Ja = function(a, b) {
                b.left = a + "px"
            }
            ,
            Ia = function(a) {
                var b = a.fitRatio > 1 ? 1 : a.fitRatio
                  , c = a.container.style
                  , d = b * a.w
                  , e = b * a.h;
                c.width = d + "px",
                c.height = e + "px",
                c.left = a.initialPosition.x + "px",
                c.top = a.initialPosition.y + "px"
            }
            ,
            Ha = function() {
                if (ea) {
                    var a = ea
                      , b = f.currItem
                      , c = b.fitRatio > 1 ? 1 : b.fitRatio
                      , d = c * b.w
                      , e = c * b.h;
                    a.width = d + "px",
                    a.height = e + "px",
                    a.left = pa.x + "px",
                    a.top = pa.y + "px"
                }
            }
        }, Xa = function(a) {
            var b = "";
            i.escKey && 27 === a.keyCode ? b = "close" : i.arrowKeys && (37 === a.keyCode ? b = "prev" : 39 === a.keyCode && (b = "next")),
            b && (a.ctrlKey || a.altKey || a.shiftKey || a.metaKey || (a.preventDefault ? a.preventDefault() : a.returnValue = !1,
            f[b]()))
        }, Ya = function(a) {
            a && (Y || X || fa || T) && (a.preventDefault(),
            a.stopPropagation())
        }, Za = function() {
            f.setScrollOffset(0, e.getScrollY())
        }, $a = {}, _a = 0, ab = function(a) {
            $a[a] && ($a[a].raf && I($a[a].raf),
            _a--,
            delete $a[a])
        }, bb = function(a) {
            $a[a] && ab(a),
            $a[a] || (_a++,
            $a[a] = {})
        }, cb = function() {
            for (var a in $a)
                $a.hasOwnProperty(a) && ab(a)
        }, db = function(a, b, c, d, e, f, g) {
            var h, i = Ea();
            bb(a);
            var j = function() {
                if ($a[a]) {
                    if (h = Ea() - i,
                    h >= d)
                        return ab(a),
                        f(c),
                        void (g && g());
                    f((c - b) * e(h / d) + b),
                    $a[a].raf = H(j)
                }
            };
            j()
        }, eb = {
            shout: Da,
            listen: Ca,
            viewportSize: qa,
            options: i,
            isMainScrollAnimating: function() {
                return fa
            },
            getZoomLevel: function() {
                return s
            },
            getCurrentIndex: function() {
                return m
            },
            isDragging: function() {
                return V
            },
            isZooming: function() {
                return aa
            },
            setScrollOffset: function(a, b) {
                sa.x = a,
                M = sa.y = b,
                Da("updateScrollOffset", sa)
            },
            applyZoomPan: function(a, b, c, d) {
                pa.x = b,
                pa.y = c,
                s = a,
                Ha(d)
            },
            init: function() {
                if (!j && !k) {
                    var c;
                    f.framework = e,
                    f.template = a,
                    f.bg = e.getChildByClass(a, "pswp__bg"),
                    J = a.className,
                    j = !0,
                    N = e.detectFeatures(),
                    H = N.raf,
                    I = N.caf,
                    E = N.transform,
                    L = N.oldIE,
                    f.scrollWrap = e.getChildByClass(a, "pswp__scroll-wrap"),
                    f.container = e.getChildByClass(f.scrollWrap, "pswp__container"),
                    n = f.container.style,
                    f.itemHolders = y = [{
                        el: f.container.children[0],
                        wrap: 0,
                        index: -1
                    }, {
                        el: f.container.children[1],
                        wrap: 0,
                        index: -1
                    }, {
                        el: f.container.children[2],
                        wrap: 0,
                        index: -1
                    }],
                    y[0].el.style.display = y[2].el.style.display = "none",
                    Wa(),
                    r = {
                        resize: f.updateSize,
                        orientationchange: function() {
                            clearTimeout(O),
                            O = setTimeout(function() {
                                qa.x !== f.scrollWrap.clientWidth && f.updateSize()
                            }, 500)
                        },
                        scroll: Za,
                        keydown: Xa,
                        click: Ya
                    };
                    var d = N.isOldIOSPhone || N.isOldAndroid || N.isMobileOpera;
                    for (N.animationName && N.transform && !d || (i.showAnimationDuration = i.hideAnimationDuration = 0),
                    c = 0; c < wa.length; c++)
                        f["init" + wa[c]]();
                    if (b) {
                        var g = f.ui = new b(f,e);
                        g.init()
                    }
                    Da("firstUpdate"),
                    m = m || i.index || 0,
                    (isNaN(m) || m < 0 || m >= ac()) && (m = 0),
                    f.currItem = _b(m),
                    (N.isOldIOSPhone || N.isOldAndroid) && (va = !1),
                    a.setAttribute("aria-hidden", "false"),
                    i.modal && (va ? a.style.position = "fixed" : (a.style.position = "absolute",
                    a.style.top = e.getScrollY() + "px")),
                    void 0 === M && (Da("initialLayout"),
                    M = K = e.getScrollY());
                    var l = "pswp--open ";
                    for (i.mainClass && (l += i.mainClass + " "),
                    i.showHideOpacity && (l += "pswp--animate_opacity "),
                    l += G ? "pswp--touch" : "pswp--notouch",
                    l += N.animationName ? " pswp--css_animation" : "",
                    l += N.svg ? " pswp--svg" : "",
                    e.addClass(a, l),
                    f.updateSize(),
                    o = -1,
                    ua = null,
                    c = 0; c < h; c++)
                        Ja((c + o) * ta.x, y[c].el.style);
                    L || e.bind(f.scrollWrap, q, f),
                    Ca("initialZoomInEnd", function() {
                        f.setContent(y[0], m - 1),
                        f.setContent(y[2], m + 1),
                        y[0].el.style.display = y[2].el.style.display = "block",
                        i.focus && a.focus(),
                        Qa()
                    }),
                    f.setContent(y[1], m),
                    f.updateCurrItem(),
                    Da("afterInit"),
                    va || (w = setInterval(function() {
                        _a || V || aa || s !== f.currItem.initialZoomLevel || f.updateSize()
                    }, 1e3)),
                    e.addClass(a, "pswp--visible")
                }
            },
            close: function() {
                j && (j = !1,
                k = !0,
                Da("close"),
                Ra(),
                cc(f.currItem, null, !0, f.destroy))
            },
            destroy: function() {
                Da("destroy"),
                Xb && clearTimeout(Xb),
                a.setAttribute("aria-hidden", "true"),
                a.className = J,
                w && clearInterval(w),
                e.unbind(f.scrollWrap, q, f),
                e.unbind(window, "scroll", f),
                zb(),
                cb(),
                Ba = null
            },
            panTo: function(a, b, c) {
                c || (a > da.min.x ? a = da.min.x : a < da.max.x && (a = da.max.x),
                b > da.min.y ? b = da.min.y : b < da.max.y && (b = da.max.y)),
                pa.x = a,
                pa.y = b,
                Ha()
            },
            handleEvent: function(a) {
                a = a || window.event,
                r[a.type] && r[a.type](a)
            },
            goTo: function(a) {
                a = Aa(a);
                var b = a - m;
                ua = b,
                m = a,
                f.currItem = _b(m),
                ra -= b,
                Ka(ta.x * ra),
                cb(),
                fa = !1,
                f.updateCurrItem()
            },
            next: function() {
                f.goTo(m + 1)
            },
            prev: function() {
                f.goTo(m - 1)
            },
            updateCurrZoomItem: function(a) {
                if (a && Da("beforeChange", 0),
                y[1].el.children.length) {
                    var b = y[1].el.children[0];
                    ea = e.hasClass(b, "pswp__zoom-wrap") ? b.style : null
                } else
                    ea = null;
                da = f.currItem.bounds,
                t = s = f.currItem.initialZoomLevel,
                pa.x = da.center.x,
                pa.y = da.center.y,
                a && Da("afterChange")
            },
            invalidateCurrItems: function() {
                x = !0;
                for (var a = 0; a < h; a++)
                    y[a].item && (y[a].item.needsUpdate = !0)
            },
            updateCurrItem: function(a) {
                if (0 !== ua) {
                    var b, c = Math.abs(ua);
                    if (!(a && c < 2)) {
                        f.currItem = _b(m),
                        ya = !1,
                        Da("beforeChange", ua),
                        c >= h && (o += ua + (ua > 0 ? -h : h),
                        c = h);
                        for (var d = 0; d < c; d++)
                            ua > 0 ? (b = y.shift(),
                            y[h - 1] = b,
                            o++,
                            Ja((o + 2) * ta.x, b.el.style),
                            f.setContent(b, m - c + d + 1 + 1)) : (b = y.pop(),
                            y.unshift(b),
                            o--,
                            Ja(o * ta.x, b.el.style),
                            f.setContent(b, m + c - d - 1 - 1));
                        if (ea && 1 === Math.abs(ua)) {
                            var e = _b(z);
                            e.initialZoomLevel !== s && (ic(e, qa),
                            mc(e),
                            Ia(e))
                        }
                        ua = 0,
                        f.updateCurrZoomItem(),
                        z = m,
                        Da("afterChange")
                    }
                }
            },
            updateSize: function(b) {
                if (!va && i.modal) {
                    var c = e.getScrollY();
                    if (M !== c && (a.style.top = c + "px",
                    M = c),
                    !b && xa.x === window.innerWidth && xa.y === window.innerHeight)
                        return;
                    xa.x = window.innerWidth,
                    xa.y = window.innerHeight,
                    a.style.height = xa.y + "px"
                }
                if (qa.x = f.scrollWrap.clientWidth,
                qa.y = f.scrollWrap.clientHeight,
                Za(),
                ta.x = qa.x + Math.round(qa.x * i.spacing),
                ta.y = qa.y,
                Ka(ta.x * ra),
                Da("beforeResize"),
                void 0 !== o) {
                    for (var d, g, j, k = 0; k < h; k++)
                        d = y[k],
                        Ja((k + o) * ta.x, d.el.style),
                        j = m + k - 1,
                        i.loop && ac() > 2 && (j = Aa(j)),
                        g = _b(j),
                        g && (x || g.needsUpdate || !g.bounds) ? (f.cleanSlide(g),
                        f.setContent(d, j),
                        1 === k && (f.currItem = g,
                        f.updateCurrZoomItem(!0)),
                        g.needsUpdate = !1) : d.index === -1 && j >= 0 && f.setContent(d, j),
                        g && g.container && (ic(g, qa),
                        mc(g),
                        Ia(g));
                    x = !1
                }
                t = s = f.currItem.initialZoomLevel,
                da = f.currItem.bounds,
                da && (pa.x = da.center.x,
                pa.y = da.center.y,
                Ha(!0)),
                Da("resize")
            },
            zoomTo: function(a, b, c, d, f) {
                b && (t = s,
                ub.x = Math.abs(b.x) - pa.x,
                ub.y = Math.abs(b.y) - pa.y,
                Ma(oa, pa));
                var g = Sa(a, !1)
                  , h = {};
                Va("x", g, h, a),
                Va("y", g, h, a);
                var i = s
                  , j = {
                    x: pa.x,
                    y: pa.y
                };
                Na(h);
                var k = function(b) {
                    1 === b ? (s = a,
                    pa.x = h.x,
                    pa.y = h.y) : (s = (a - i) * b + i,
                    pa.x = (h.x - j.x) * b + j.x,
                    pa.y = (h.y - j.y) * b + j.y),
                    f && f(b),
                    Ha(1 === b)
                };
                c ? db("customZoomTo", 0, 1, c, d || e.easing.sine.inOut, k) : k(1)
            }
        }, fb = 30, gb = 10, hb = {}, ib = {}, jb = {}, kb = {}, lb = {}, mb = [], nb = {}, ob = [], pb = {}, qb = 0, rb = ma(), sb = 0, tb = ma(), ub = ma(), vb = ma(), wb = function(a, b) {
            return a.x === b.x && a.y === b.y
        }, xb = function(a, b) {
            return Math.abs(a.x - b.x) < g && Math.abs(a.y - b.y) < g
        }, yb = function(a, b) {
            return pb.x = Math.abs(a.x - b.x),
            pb.y = Math.abs(a.y - b.y),
            Math.sqrt(pb.x * pb.x + pb.y * pb.y)
        }, zb = function() {
            Z && (I(Z),
            Z = null)
        }, Ab = function() {
            V && (Z = H(Ab),
            Qb())
        }, Bb = function() {
            return !("fit" === i.scaleMode && s === f.currItem.initialZoomLevel)
        }, Cb = function(a, b) {
            return !(!a || a === document) && (!(a.getAttribute("class") && a.getAttribute("class").indexOf("pswp__scroll-wrap") > -1) && (b(a) ? a : Cb(a.parentNode, b)))
        }, Db = {}, Eb = function(a, b) {
            return Db.prevent = !Cb(a.target, i.isClickableElement),
            Da("preventDragEvent", a, b, Db),
            Db.prevent
        }, Fb = function(a, b) {
            return b.x = a.pageX,
            b.y = a.pageY,
            b.id = a.identifier,
            b
        }, Gb = function(a, b, c) {
            c.x = .5 * (a.x + b.x),
            c.y = .5 * (a.y + b.y)
        }, Hb = function(a, b, c) {
            if (a - Q > 50) {
                var d = ob.length > 2 ? ob.shift() : {};
                d.x = b,
                d.y = c,
                ob.push(d),
                Q = a
            }
        }, Ib = function() {
            var a = pa.y - f.currItem.initialPosition.y;
            return 1 - Math.abs(a / (qa.y / 2))
        }, Jb = {}, Kb = {}, Lb = [], Mb = function(a) {
            for (; Lb.length > 0; )
                Lb.pop();
            return F ? (la = 0,
            mb.forEach(function(a) {
                0 === la ? Lb[0] = a : 1 === la && (Lb[1] = a),
                la++
            })) : a.type.indexOf("touch") > -1 ? a.touches && a.touches.length > 0 && (Lb[0] = Fb(a.touches[0], Jb),
            a.touches.length > 1 && (Lb[1] = Fb(a.touches[1], Kb))) : (Jb.x = a.pageX,
            Jb.y = a.pageY,
            Jb.id = "",
            Lb[0] = Jb),
            Lb
        }, Nb = function(a, b) {
            var c, d, e, g, h = 0, j = pa[a] + b[a], k = b[a] > 0, l = tb.x + b.x, m = tb.x - nb.x;
            return c = j > da.min[a] || j < da.max[a] ? i.panEndFriction : 1,
            j = pa[a] + b[a] * c,
            !i.allowPanToNext && s !== f.currItem.initialZoomLevel || (ea ? "h" !== ga || "x" !== a || X || (k ? (j > da.min[a] && (c = i.panEndFriction,
            h = da.min[a] - j,
            d = da.min[a] - oa[a]),
            (d <= 0 || m < 0) && ac() > 1 ? (g = l,
            m < 0 && l > nb.x && (g = nb.x)) : da.min.x !== da.max.x && (e = j)) : (j < da.max[a] && (c = i.panEndFriction,
            h = j - da.max[a],
            d = oa[a] - da.max[a]),
            (d <= 0 || m > 0) && ac() > 1 ? (g = l,
            m > 0 && l < nb.x && (g = nb.x)) : da.min.x !== da.max.x && (e = j))) : g = l,
            "x" !== a) ? void (fa || $ || s > f.currItem.fitRatio && (pa[a] += b[a] * c)) : (void 0 !== g && (Ka(g, !0),
            $ = g !== nb.x),
            da.min.x !== da.max.x && (void 0 !== e ? pa.x = e : $ || (pa.x += b.x * c)),
            void 0 !== g)
        }, Ob = function(a) {
            if (!("mousedown" === a.type && a.button > 0)) {
                if ($b)
                    return void a.preventDefault();
                if (!U || "mousedown" !== a.type) {
                    if (Eb(a, !0) && a.preventDefault(),
                    Da("pointerDown"),
                    F) {
                        var b = e.arraySearch(mb, a.pointerId, "id");
                        b < 0 && (b = mb.length),
                        mb[b] = {
                            x: a.pageX,
                            y: a.pageY,
                            id: a.pointerId
                        }
                    }
                    var c = Mb(a)
                      , d = c.length;
                    _ = null,
                    cb(),
                    V && 1 !== d || (V = ha = !0,
                    e.bind(window, p, f),
                    S = ka = ia = T = $ = Y = W = X = !1,
                    ga = null,
                    Da("firstTouchStart", c),
                    Ma(oa, pa),
                    na.x = na.y = 0,
                    Ma(kb, c[0]),
                    Ma(lb, kb),
                    nb.x = ta.x * ra,
                    ob = [{
                        x: kb.x,
                        y: kb.y
                    }],
                    Q = P = Ea(),
                    Sa(s, !0),
                    zb(),
                    Ab()),
                    !aa && d > 1 && !fa && !$ && (t = s,
                    X = !1,
                    aa = W = !0,
                    na.y = na.x = 0,
                    Ma(oa, pa),
                    Ma(hb, c[0]),
                    Ma(ib, c[1]),
                    Gb(hb, ib, vb),
                    ub.x = Math.abs(vb.x) - pa.x,
                    ub.y = Math.abs(vb.y) - pa.y,
                    ba = ca = yb(hb, ib))
                }
            }
        }, Pb = function(a) {
            if (a.preventDefault(),
            F) {
                var b = e.arraySearch(mb, a.pointerId, "id");
                if (b > -1) {
                    var c = mb[b];
                    c.x = a.pageX,
                    c.y = a.pageY
                }
            }
            if (V) {
                var d = Mb(a);
                if (ga || Y || aa)
                    _ = d;
                else if (tb.x !== ta.x * ra)
                    ga = "h";
                else {
                    var f = Math.abs(d[0].x - kb.x) - Math.abs(d[0].y - kb.y);
                    Math.abs(f) >= gb && (ga = f > 0 ? "h" : "v",
                    _ = d)
                }
            }
        }, Qb = function() {
            if (_) {
                var a = _.length;
                if (0 !== a)
                    if (Ma(hb, _[0]),
                    jb.x = hb.x - kb.x,
                    jb.y = hb.y - kb.y,
                    aa && a > 1) {
                        if (kb.x = hb.x,
                        kb.y = hb.y,
                        !jb.x && !jb.y && wb(_[1], ib))
                            return;
                        Ma(ib, _[1]),
                        X || (X = !0,
                        Da("zoomGestureStarted"));
                        var b = yb(hb, ib)
                          , c = Vb(b);
                        c > f.currItem.initialZoomLevel + f.currItem.initialZoomLevel / 15 && (ka = !0);
                        var d = 1
                          , e = Ta()
                          , g = Ua();
                        if (c < e)
                            if (i.pinchToClose && !ka && t <= f.currItem.initialZoomLevel) {
                                var h = e - c
                                  , j = 1 - h / (e / 1.2);
                                Fa(j),
                                Da("onPinchClose", j),
                                ia = !0
                            } else
                                d = (e - c) / e,
                                d > 1 && (d = 1),
                                c = e - d * (e / 3);
                        else
                            c > g && (d = (c - g) / (6 * e),
                            d > 1 && (d = 1),
                            c = g + d * e);
                        d < 0 && (d = 0),
                        ba = b,
                        Gb(hb, ib, rb),
                        na.x += rb.x - vb.x,
                        na.y += rb.y - vb.y,
                        Ma(vb, rb),
                        pa.x = La("x", c),
                        pa.y = La("y", c),
                        S = c > s,
                        s = c,
                        Ha()
                    } else {
                        if (!ga)
                            return;
                        if (ha && (ha = !1,
                        Math.abs(jb.x) >= gb && (jb.x -= _[0].x - lb.x),
                        Math.abs(jb.y) >= gb && (jb.y -= _[0].y - lb.y)),
                        kb.x = hb.x,
                        kb.y = hb.y,
                        0 === jb.x && 0 === jb.y)
                            return;
                        if ("v" === ga && i.closeOnVerticalDrag && !Bb()) {
                            na.y += jb.y,
                            pa.y += jb.y;
                            var k = Ib();
                            return T = !0,
                            Da("onVerticalDrag", k),
                            Fa(k),
                            void Ha()
                        }
                        Hb(Ea(), hb.x, hb.y),
                        Y = !0,
                        da = f.currItem.bounds;
                        var l = Nb("x", jb);
                        l || (Nb("y", jb),
                        Na(pa),
                        Ha())
                    }
            }
        }, Rb = function(a) {
            if (N.isOldAndroid) {
                if (U && "mouseup" === a.type)
                    return;
                a.type.indexOf("touch") > -1 && (clearTimeout(U),
                U = setTimeout(function() {
                    U = 0
                }, 600))
            }
            Da("pointerUp"),
            Eb(a, !1) && a.preventDefault();
            var b;
            if (F) {
                var c = e.arraySearch(mb, a.pointerId, "id");
                if (c > -1)
                    if (b = mb.splice(c, 1)[0],
                    navigator.pointerEnabled)
                        b.type = a.pointerType || "mouse";
                    else {
                        var d = {
                            4: "mouse",
                            2: "touch",
                            3: "pen"
                        };
                        b.type = d[a.pointerType],
                        b.type || (b.type = a.pointerType || "mouse")
                    }
            }
            var g, h = Mb(a), j = h.length;
            if ("mouseup" === a.type && (j = 0),
            2 === j)
                return _ = null,
                !0;
            1 === j && Ma(lb, h[0]),
            0 !== j || ga || fa || (b || ("mouseup" === a.type ? b = {
                x: a.pageX,
                y: a.pageY,
                type: "mouse"
            } : a.changedTouches && a.changedTouches[0] && (b = {
                x: a.changedTouches[0].pageX,
                y: a.changedTouches[0].pageY,
                type: "touch"
            })),
            Da("touchRelease", a, b));
            var k = -1;
            if (0 === j && (V = !1,
            e.unbind(window, p, f),
            zb(),
            aa ? k = 0 : sb !== -1 && (k = Ea() - sb)),
            sb = 1 === j ? Ea() : -1,
            g = k !== -1 && k < 150 ? "zoom" : "swipe",
            aa && j < 2 && (aa = !1,
            1 === j && (g = "zoomPointerUp"),
            Da("zoomGestureEnded")),
            _ = null,
            Y || X || fa || T)
                if (cb(),
                R || (R = Sb()),
                R.calculateSwipeSpeed("x"),
                T) {
                    var l = Ib();
                    if (l < i.verticalDragRange)
                        f.close();
                    else {
                        var m = pa.y
                          , n = ja;
                        db("verticalDrag", 0, 1, 300, e.easing.cubic.out, function(a) {
                            pa.y = (f.currItem.initialPosition.y - m) * a + m,
                            Fa((1 - n) * a + n),
                            Ha()
                        }),
                        Da("onVerticalDrag", 1)
                    }
                } else {
                    if (($ || fa) && 0 === j) {
                        var o = Ub(g, R);
                        if (o)
                            return;
                        g = "zoomPointerUp"
                    }
                    if (!fa)
                        return "swipe" !== g ? void Wb() : void (!$ && s > f.currItem.fitRatio && Tb(R))
                }
        }, Sb = function() {
            var a, b, c = {
                lastFlickOffset: {},
                lastFlickDist: {},
                lastFlickSpeed: {},
                slowDownRatio: {},
                slowDownRatioReverse: {},
                speedDecelerationRatio: {},
                speedDecelerationRatioAbs: {},
                distanceOffset: {},
                backAnimDestination: {},
                backAnimStarted: {},
                calculateSwipeSpeed: function(d) {
                    ob.length > 1 ? (a = Ea() - Q + 50,
                    b = ob[ob.length - 2][d]) : (a = Ea() - P,
                    b = lb[d]),
                    c.lastFlickOffset[d] = kb[d] - b,
                    c.lastFlickDist[d] = Math.abs(c.lastFlickOffset[d]),
                    c.lastFlickDist[d] > 20 ? c.lastFlickSpeed[d] = c.lastFlickOffset[d] / a : c.lastFlickSpeed[d] = 0,
                    Math.abs(c.lastFlickSpeed[d]) < .1 && (c.lastFlickSpeed[d] = 0),
                    c.slowDownRatio[d] = .95,
                    c.slowDownRatioReverse[d] = 1 - c.slowDownRatio[d],
                    c.speedDecelerationRatio[d] = 1
                },
                calculateOverBoundsAnimOffset: function(a, b) {
                    c.backAnimStarted[a] || (pa[a] > da.min[a] ? c.backAnimDestination[a] = da.min[a] : pa[a] < da.max[a] && (c.backAnimDestination[a] = da.max[a]),
                    void 0 !== c.backAnimDestination[a] && (c.slowDownRatio[a] = .7,
                    c.slowDownRatioReverse[a] = 1 - c.slowDownRatio[a],
                    c.speedDecelerationRatioAbs[a] < .05 && (c.lastFlickSpeed[a] = 0,
                    c.backAnimStarted[a] = !0,
                    db("bounceZoomPan" + a, pa[a], c.backAnimDestination[a], b || 300, e.easing.sine.out, function(b) {
                        pa[a] = b,
                        Ha()
                    }))))
                },
                calculateAnimOffset: function(a) {
                    c.backAnimStarted[a] || (c.speedDecelerationRatio[a] = c.speedDecelerationRatio[a] * (c.slowDownRatio[a] + c.slowDownRatioReverse[a] - c.slowDownRatioReverse[a] * c.timeDiff / 10),
                    c.speedDecelerationRatioAbs[a] = Math.abs(c.lastFlickSpeed[a] * c.speedDecelerationRatio[a]),
                    c.distanceOffset[a] = c.lastFlickSpeed[a] * c.speedDecelerationRatio[a] * c.timeDiff,
                    pa[a] += c.distanceOffset[a])
                },
                panAnimLoop: function() {
                    if ($a.zoomPan && ($a.zoomPan.raf = H(c.panAnimLoop),
                    c.now = Ea(),
                    c.timeDiff = c.now - c.lastNow,
                    c.lastNow = c.now,
                    c.calculateAnimOffset("x"),
                    c.calculateAnimOffset("y"),
                    Ha(),
                    c.calculateOverBoundsAnimOffset("x"),
                    c.calculateOverBoundsAnimOffset("y"),
                    c.speedDecelerationRatioAbs.x < .05 && c.speedDecelerationRatioAbs.y < .05))
                        return pa.x = Math.round(pa.x),
                        pa.y = Math.round(pa.y),
                        Ha(),
                        void ab("zoomPan")
                }
            };
            return c
        }, Tb = function(a) {
            return a.calculateSwipeSpeed("y"),
            da = f.currItem.bounds,
            a.backAnimDestination = {},
            a.backAnimStarted = {},
            Math.abs(a.lastFlickSpeed.x) <= .05 && Math.abs(a.lastFlickSpeed.y) <= .05 ? (a.speedDecelerationRatioAbs.x = a.speedDecelerationRatioAbs.y = 0,
            a.calculateOverBoundsAnimOffset("x"),
            a.calculateOverBoundsAnimOffset("y"),
            !0) : (bb("zoomPan"),
            a.lastNow = Ea(),
            void a.panAnimLoop())
        }, Ub = function(a, b) {
            var c;
            fa || (qb = m);
            var d;
            if ("swipe" === a) {
                var g = kb.x - lb.x
                  , h = b.lastFlickDist.x < 10;
                g > fb && (h || b.lastFlickOffset.x > 20) ? d = -1 : g < -fb && (h || b.lastFlickOffset.x < -20) && (d = 1)
            }
            var j;
            d && (m += d,
            m < 0 ? (m = i.loop ? ac() - 1 : 0,
            j = !0) : m >= ac() && (m = i.loop ? 0 : ac() - 1,
            j = !0),
            j && !i.loop || (ua += d,
            ra -= d,
            c = !0));
            var k, l = ta.x * ra, n = Math.abs(l - tb.x);
            return c || l > tb.x == b.lastFlickSpeed.x > 0 ? (k = Math.abs(b.lastFlickSpeed.x) > 0 ? n / Math.abs(b.lastFlickSpeed.x) : 333,
            k = Math.min(k, 400),
            k = Math.max(k, 250)) : k = 333,
            qb === m && (c = !1),
            fa = !0,
            Da("mainScrollAnimStart"),
            db("mainScroll", tb.x, l, k, e.easing.cubic.out, Ka, function() {
                cb(),
                fa = !1,
                qb = -1,
                (c || qb !== m) && f.updateCurrItem(),
                Da("mainScrollAnimComplete")
            }),
            c && f.updateCurrItem(!0),
            c
        }, Vb = function(a) {
            return 1 / ca * a * t
        }, Wb = function() {
            var a = s
              , b = Ta()
              , c = Ua();
            s < b ? a = b : s > c && (a = c);
            var d, g = 1, h = ja;
            return ia && !S && !ka && s < b ? (f.close(),
            !0) : (ia && (d = function(a) {
                Fa((g - h) * a + h)
            }
            ),
            f.zoomTo(a, 0, 200, e.easing.cubic.out, d),
            !0)
        };
        za("Gestures", {
            publicMethods: {
                initGestures: function() {
                    var a = function(a, b, c, d, e) {
                        A = a + b,
                        B = a + c,
                        C = a + d,
                        D = e ? a + e : ""
                    };
                    F = N.pointerEvent,
                    F && N.touch && (N.touch = !1),
                    F ? navigator.pointerEnabled ? a("pointer", "down", "move", "up", "cancel") : a("MSPointer", "Down", "Move", "Up", "Cancel") : N.touch ? (a("touch", "start", "move", "end", "cancel"),
                    G = !0) : a("mouse", "down", "move", "up"),
                    p = B + " " + C + " " + D,
                    q = A,
                    F && !G && (G = navigator.maxTouchPoints > 1 || navigator.msMaxTouchPoints > 1),
                    f.likelyTouchDevice = G,
                    r[A] = Ob,
                    r[B] = Pb,
                    r[C] = Rb,
                    D && (r[D] = r[C]),
                    N.touch && (q += " mousedown",
                    p += " mousemove mouseup",
                    r.mousedown = r[A],
                    r.mousemove = r[B],
                    r.mouseup = r[C]),
                    G || (i.allowPanToNext = !1)
                }
            }
        });
        var Xb, Yb, Zb, $b, _b, ac, bc, cc = function(b, c, d, g) {
            Xb && clearTimeout(Xb),
            $b = !0,
            Zb = !0;
            var h;
            b.initialLayout ? (h = b.initialLayout,
            b.initialLayout = null) : h = i.getThumbBoundsFn && i.getThumbBoundsFn(m);
            var j = d ? i.hideAnimationDuration : i.showAnimationDuration
              , k = function() {
                ab("initialZoom"),
                d ? (f.template.removeAttribute("style"),
                f.bg.removeAttribute("style")) : (Fa(1),
                c && (c.style.display = "block"),
                e.addClass(a, "pswp--animated-in"),
                Da("initialZoom" + (d ? "OutEnd" : "InEnd"))),
                g && g(),
                $b = !1
            };
            if (!j || !h || void 0 === h.x)
                return Da("initialZoom" + (d ? "Out" : "In")),
                s = b.initialZoomLevel,
                Ma(pa, b.initialPosition),
                Ha(),
                a.style.opacity = d ? 0 : 1,
                Fa(1),
                void (j ? setTimeout(function() {
                    k()
                }, j) : k());
            var n = function() {
                var c = l
                  , g = !f.currItem.src || f.currItem.loadError || i.showHideOpacity;
                b.miniImg && (b.miniImg.style.webkitBackfaceVisibility = "hidden"),
                d || (s = h.w / b.w,
                pa.x = h.x,
                pa.y = h.y - K,
                f[g ? "template" : "bg"].style.opacity = .001,
                Ha()),
                bb("initialZoom"),
                d && !c && e.removeClass(a, "pswp--animated-in"),
                g && (d ? e[(c ? "remove" : "add") + "Class"](a, "pswp--animate_opacity") : setTimeout(function() {
                    e.addClass(a, "pswp--animate_opacity")
                }, 30)),
                Xb = setTimeout(function() {
                    if (Da("initialZoom" + (d ? "Out" : "In")),
                    d) {
                        var f = h.w / b.w
                          , i = {
                            x: pa.x,
                            y: pa.y
                        }
                          , l = s
                          , m = ja
                          , n = function(b) {
                            1 === b ? (s = f,
                            pa.x = h.x,
                            pa.y = h.y - M) : (s = (f - l) * b + l,
                            pa.x = (h.x - i.x) * b + i.x,
                            pa.y = (h.y - M - i.y) * b + i.y),
                            Ha(),
                            g ? a.style.opacity = 1 - b : Fa(m - b * m)
                        };
                        c ? db("initialZoom", 0, 1, j, e.easing.cubic.out, n, k) : (n(1),
                        Xb = setTimeout(k, j + 20))
                    } else
                        s = b.initialZoomLevel,
                        Ma(pa, b.initialPosition),
                        Ha(),
                        Fa(1),
                        g ? a.style.opacity = 1 : Fa(1),
                        Xb = setTimeout(k, j + 20)
                }, d ? 25 : 90)
            };
            n()
        }, dc = {}, ec = [], fc = {
            index: 0,
            errorMsg: '<div class="pswp__error-msg"><a href="%url%" target="_blank">The image</a> could not be loaded.</div>',
            forceProgressiveLoading: !1,
            preload: [1, 1],
            getNumItemsFn: function() {
                return Yb.length
            }
        }, gc = function() {
            return {
                center: {
                    x: 0,
                    y: 0
                },
                max: {
                    x: 0,
                    y: 0
                },
                min: {
                    x: 0,
                    y: 0
                }
            }
        }, hc = function(a, b, c) {
            var d = a.bounds;
            d.center.x = Math.round((dc.x - b) / 2),
            d.center.y = Math.round((dc.y - c) / 2) + a.vGap.top,
            d.max.x = b > dc.x ? Math.round(dc.x - b) : d.center.x,
            d.max.y = c > dc.y ? Math.round(dc.y - c) + a.vGap.top : d.center.y,
            d.min.x = b > dc.x ? 0 : d.center.x,
            d.min.y = c > dc.y ? a.vGap.top : d.center.y
        }, ic = function(a, b, c) {
            if (a.src && !a.loadError) {
                var d = !c;
                if (d && (a.vGap || (a.vGap = {
                    top: 0,
                    bottom: 0
                }),
                Da("parseVerticalMargin", a)),
                dc.x = b.x,
                dc.y = b.y - a.vGap.top - a.vGap.bottom,
                d) {
                    var e = dc.x / a.w
                      , f = dc.y / a.h;
                    a.fitRatio = e < f ? e : f;
                    var g = i.scaleMode;
                    "orig" === g ? c = 1 : "fit" === g && (c = a.fitRatio),
                    c > 1 && (c = 1),
                    a.initialZoomLevel = c,
                    a.bounds || (a.bounds = gc())
                }
                if (!c)
                    return;
                return hc(a, a.w * c, a.h * c),
                d && c === a.initialZoomLevel && (a.initialPosition = a.bounds.center),
                a.bounds
            }
            return a.w = a.h = 0,
            a.initialZoomLevel = a.fitRatio = 1,
            a.bounds = gc(),
            a.initialPosition = a.bounds.center,
            a.bounds
        }, jc = function(a, b, c, d, e, g) {
            b.loadError || d && (b.imageAppended = !0,
            mc(b, d, b === f.currItem && ya),
            c.appendChild(d),
            g && setTimeout(function() {
                b && b.loaded && b.placeholder && (b.placeholder.style.display = "none",
                b.placeholder = null)
            }, 500))
        }, kc = function(a) {
            a.loading = !0,
            a.loaded = !1;
            var b = a.img = e.createEl("pswp__img", "img")
              , c = function() {
                a.loading = !1,
                a.loaded = !0,
                a.loadComplete ? a.loadComplete(a) : a.img = null,
                b.onload = b.onerror = null,
                b = null
            };
            return b.onload = c,
            b.onerror = function() {
                a.loadError = !0,
                c()
            }
            ,
            b.src = a.src,
            b
        }, lc = function(a, b) {
            if (a.src && a.loadError && a.container)
                return b && (a.container.innerHTML = ""),
                a.container.innerHTML = i.errorMsg.replace("%url%", a.src),
                !0
        }, mc = function(a, b, c) {
            if (a.src) {
                b || (b = a.container.lastChild);
                var d = c ? a.w : Math.round(a.w * a.fitRatio)
                  , e = c ? a.h : Math.round(a.h * a.fitRatio);
                a.placeholder && !a.loaded && (a.placeholder.style.width = d + "px",
                a.placeholder.style.height = e + "px"),
                b.style.width = d + "px",
                b.style.height = e + "px"
            }
        }, nc = function() {
            if (ec.length) {
                for (var a, b = 0; b < ec.length; b++)
                    a = ec[b],
                    a.holder.index === a.index && jc(a.index, a.item, a.baseDiv, a.img, !1, a.clearPlaceholder);
                ec = []
            }
        };
        za("Controller", {
            publicMethods: {
                lazyLoadItem: function(a) {
                    a = Aa(a);
                    var b = _b(a);
                    b && (!b.loaded && !b.loading || x) && (Da("gettingData", a, b),
                    b.src && kc(b))
                },
                initController: function() {
                    e.extend(i, fc, !0),
                    f.items = Yb = c,
                    _b = f.getItemAt,
                    ac = i.getNumItemsFn,
                    bc = i.loop,
                    ac() < 3 && (i.loop = !1),
                    Ca("beforeChange", function(a) {
                        var b, c = i.preload, d = null === a || a >= 0, e = Math.min(c[0], ac()), g = Math.min(c[1], ac());
                        for (b = 1; b <= (d ? g : e); b++)
                            f.lazyLoadItem(m + b);
                        for (b = 1; b <= (d ? e : g); b++)
                            f.lazyLoadItem(m - b)
                    }),
                    Ca("initialLayout", function() {
                        f.currItem.initialLayout = i.getThumbBoundsFn && i.getThumbBoundsFn(m)
                    }),
                    Ca("mainScrollAnimComplete", nc),
                    Ca("initialZoomInEnd", nc),
                    Ca("destroy", function() {
                        for (var a, b = 0; b < Yb.length; b++)
                            a = Yb[b],
                            a.container && (a.container = null),
                            a.placeholder && (a.placeholder = null),
                            a.img && (a.img = null),
                            a.preloader && (a.preloader = null),
                            a.loadError && (a.loaded = a.loadError = !1);
                        ec = null
                    })
                },
                getItemAt: function(a) {
                    return a >= 0 && (void 0 !== Yb[a] && Yb[a])
                },
                allowProgressiveImg: function() {
                    return i.forceProgressiveLoading || !G || i.mouseUsed || screen.width > 1200
                },
                setContent: function(a, b) {
                    i.loop && (b = Aa(b));
                    var c = f.getItemAt(a.index);
                    c && (c.container = null);
                    var d, g = f.getItemAt(b);
                    if (!g)
                        return void (a.el.innerHTML = "");
                    Da("gettingData", b, g),
                    a.index = b,
                    a.item = g;
                    var h = g.container = e.createEl("pswp__zoom-wrap");
                    if (!g.src && g.html && (g.html.tagName ? h.appendChild(g.html) : h.innerHTML = g.html),
                    lc(g),
                    ic(g, qa),
                    !g.src || g.loadError || g.loaded)
                        g.src && !g.loadError && (d = e.createEl("pswp__img", "img"),
                        d.style.opacity = 1,
                        d.src = g.src,
                        mc(g, d),
                        jc(b, g, h, d, !0));
                    else {
                        if (g.loadComplete = function(c) {
                            if (j) {
                                if (a && a.index === b) {
                                    if (lc(c, !0))
                                        return c.loadComplete = c.img = null,
                                        ic(c, qa),
                                        Ia(c),
                                        void (a.index === m && f.updateCurrZoomItem());
                                    c.imageAppended ? !$b && c.placeholder && (c.placeholder.style.display = "none",
                                    c.placeholder = null) : N.transform && (fa || $b) ? ec.push({
                                        item: c,
                                        baseDiv: h,
                                        img: c.img,
                                        index: b,
                                        holder: a,
                                        clearPlaceholder: !0
                                    }) : jc(b, c, h, c.img, fa || $b, !0)
                                }
                                c.loadComplete = null,
                                c.img = null,
                                Da("imageLoadComplete", b, c)
                            }
                        }
                        ,
                        e.features.transform) {
                            var k = "pswp__img pswp__img--placeholder";
                            k += g.msrc ? "" : " pswp__img--placeholder--blank";
                            var l = e.createEl(k, g.msrc ? "img" : "");
                            g.msrc && (l.src = g.msrc),
                            mc(g, l),
                            h.appendChild(l),
                            g.placeholder = l
                        }
                        g.loading || kc(g),
                        f.allowProgressiveImg() && (!Zb && N.transform ? ec.push({
                            item: g,
                            baseDiv: h,
                            img: g.img,
                            index: b,
                            holder: a
                        }) : jc(b, g, h, g.img, !0, !0))
                    }
                    Zb || b !== m ? Ia(g) : (ea = h.style,
                    cc(g, d || g.img)),
                    a.el.innerHTML = "",
                    a.el.appendChild(h)
                },
                cleanSlide: function(a) {
                    a.img && (a.img.onload = a.img.onerror = null),
                    a.loaded = a.loading = a.img = a.imageAppended = !1
                }
            }
        });
        var oc, pc = {}, qc = function(a, b, c) {
            var d = document.createEvent("CustomEvent")
              , e = {
                origEvent: a,
                target: a.target,
                releasePoint: b,
                pointerType: c || "touch"
            };
            d.initCustomEvent("pswpTap", !0, !0, e),
            a.target.dispatchEvent(d)
        };
        za("Tap", {
            publicMethods: {
                initTap: function() {
                    Ca("firstTouchStart", f.onTapStart),
                    Ca("touchRelease", f.onTapRelease),
                    Ca("destroy", function() {
                        pc = {},
                        oc = null
                    })
                },
                onTapStart: function(a) {
                    a.length > 1 && (clearTimeout(oc),
                    oc = null)
                },
                onTapRelease: function(a, b) {
                    if (b && !Y && !W && !_a) {
                        var c = b;
                        if (oc && (clearTimeout(oc),
                        oc = null,
                        xb(c, pc)))
                            return void Da("doubleTap", c);
                        if ("mouse" === b.type)
                            return void qc(a, b, "mouse");
                        var d = a.target.tagName.toUpperCase();
                        if ("BUTTON" === d || e.hasClass(a.target, "pswp__single-tap"))
                            return void qc(a, b);
                        Ma(pc, c),
                        oc = setTimeout(function() {
                            qc(a, b),
                            oc = null
                        }, 300)
                    }
                }
            }
        });
        var rc;
        za("DesktopZoom", {
            publicMethods: {
                initDesktopZoom: function() {
                    L || (G ? Ca("mouseUsed", function() {
                        f.setupDesktopZoom()
                    }) : f.setupDesktopZoom(!0))
                },
                setupDesktopZoom: function(b) {
                    rc = {};
                    var c = "wheel mousewheel DOMMouseScroll";
                    Ca("bindEvents", function() {
                        e.bind(a, c, f.handleMouseWheel)
                    }),
                    Ca("unbindEvents", function() {
                        rc && e.unbind(a, c, f.handleMouseWheel)
                    }),
                    f.mouseZoomedIn = !1;
                    var d, g = function() {
                        f.mouseZoomedIn && (e.removeClass(a, "pswp--zoomed-in"),
                        f.mouseZoomedIn = !1),
                        s < 1 ? e.addClass(a, "pswp--zoom-allowed") : e.removeClass(a, "pswp--zoom-allowed"),
                        h()
                    }, h = function() {
                        d && (e.removeClass(a, "pswp--dragging"),
                        d = !1)
                    };
                    Ca("resize", g),
                    Ca("afterChange", g),
                    Ca("pointerDown", function() {
                        f.mouseZoomedIn && (d = !0,
                        e.addClass(a, "pswp--dragging"))
                    }),
                    Ca("pointerUp", h),
                    b || g()
                },
                handleMouseWheel: function(a) {
                    if (s <= f.currItem.fitRatio)
                        return i.modal && (!i.closeOnScroll || _a || V ? a.preventDefault() : E && Math.abs(a.deltaY) > 2 && (l = !0,
                        f.close())),
                        !0;
                    if (a.stopPropagation(),
                    rc.x = 0,
                    "deltaX"in a)
                        1 === a.deltaMode ? (rc.x = 18 * a.deltaX,
                        rc.y = 18 * a.deltaY) : (rc.x = a.deltaX,
                        rc.y = a.deltaY);
                    else if ("wheelDelta"in a)
                        a.wheelDeltaX && (rc.x = -.16 * a.wheelDeltaX),
                        a.wheelDeltaY ? rc.y = -.16 * a.wheelDeltaY : rc.y = -.16 * a.wheelDelta;
                    else {
                        if (!("detail"in a))
                            return;
                        rc.y = a.detail
                    }
                    Sa(s, !0);
                    var b = pa.x - rc.x
                      , c = pa.y - rc.y;
                    (i.modal || b <= da.min.x && b >= da.max.x && c <= da.min.y && c >= da.max.y) && a.preventDefault(),
                    f.panTo(b, c)
                },
                toggleDesktopZoom: function(b) {
                    b = b || {
                        x: qa.x / 2 + sa.x,
                        y: qa.y / 2 + sa.y
                    };
                    var c = i.getDoubleTapZoom(!0, f.currItem)
                      , d = s === c;
                    f.mouseZoomedIn = !d,
                    f.zoomTo(d ? f.currItem.initialZoomLevel : c, b, 333),
                    e[(d ? "remove" : "add") + "Class"](a, "pswp--zoomed-in")
                }
            }
        });
        var sc, tc, uc, vc, wc, xc, yc, zc, Ac, Bc, Cc, Dc, Ec = {
            history: !0,
            galleryUID: 1
        }, Fc = function() {
            return Cc.hash.substring(1)
        }, Gc = function() {
            sc && clearTimeout(sc),
            uc && clearTimeout(uc)
        }, Hc = function() {
            var a = Fc()
              , b = {};
            if (a.length < 5)
                return b;
            var c, d = a.split("&");
            for (c = 0; c < d.length; c++)
                if (d[c]) {
                    var e = d[c].split("=");
                    e.length < 2 || (b[e[0]] = e[1])
                }
            if (i.galleryPIDs) {
                var f = b.pid;
                for (b.pid = 0,
                c = 0; c < Yb.length; c++)
                    if (Yb[c].pid === f) {
                        b.pid = c;
                        break
                    }
            } else
                b.pid = parseInt(b.pid, 10) - 1;
            return b.pid < 0 && (b.pid = 0),
            b
        }, Ic = function() {
            if (uc && clearTimeout(uc),
            _a || V)
                return void (uc = setTimeout(Ic, 500));
            vc ? clearTimeout(tc) : vc = !0;
            var a = m + 1
              , b = _b(m);
            b.hasOwnProperty("pid") && (a = b.pid);
            var c = yc + "&gid=" + i.galleryUID + "&pid=" + a;
            zc || Cc.hash.indexOf(c) === -1 && (Bc = !0);
            var d = Cc.href.split("#")[0] + "#" + c;
            Dc ? "#" + c !== window.location.hash && history[zc ? "replaceState" : "pushState"]("", document.title, d) : zc ? Cc.replace(d) : Cc.hash = c,
            zc = !0,
            tc = setTimeout(function() {
                vc = !1
            }, 60)
        };
        za("History", {
            publicMethods: {
                initHistory: function() {
                    if (e.extend(i, Ec, !0),
                    i.history) {
                        Cc = window.location,
                        Bc = !1,
                        Ac = !1,
                        zc = !1,
                        yc = Fc(),
                        Dc = "pushState"in history,
                        yc.indexOf("gid=") > -1 && (yc = yc.split("&gid=")[0],
                        yc = yc.split("?gid=")[0]),
                        Ca("afterChange", f.updateURL),
                        Ca("unbindEvents", function() {
                            e.unbind(window, "hashchange", f.onHashChange)
                        });
                        var a = function() {
                            xc = !0,
                            Ac || (Bc ? history.back() : yc ? Cc.hash = yc : Dc ? history.pushState("", document.title, Cc.pathname + Cc.search) : Cc.hash = ""),
                            Gc()
                        };
                        Ca("unbindEvents", function() {
                            l && a()
                        }),
                        Ca("destroy", function() {
                            xc || a()
                        }),
                        Ca("firstUpdate", function() {
                            m = Hc().pid
                        });
                        var b = yc.indexOf("pid=");
                        b > -1 && (yc = yc.substring(0, b),
                        "&" === yc.slice(-1) && (yc = yc.slice(0, -1))),
                        setTimeout(function() {
                            j && e.bind(window, "hashchange", f.onHashChange)
                        }, 40)
                    }
                },
                onHashChange: function() {
                    return Fc() === yc ? (Ac = !0,
                    void f.close()) : void (vc || (wc = !0,
                    f.goTo(Hc().pid),
                    wc = !1))
                },
                updateURL: function() {
                    Gc(),
                    wc || (zc ? sc = setTimeout(Ic, 800) : Ic())
                }
            }
        }),
        e.extend(f, eb)
    };
    return a
});
/*! PhotoSwipe Default UI - 4.1.2 - 2017-04-05
* http://photoswipe.com
* Copyright (c) 2017 Dmitry Semenov; */
!function(a, b) {
    "function" == typeof define && define.amd ? define(b) : "object" == typeof exports ? module.exports = b() : a.PhotoSwipeUI_Default = b()
}(this, function() {
    "use strict";
    var a = function(a, b) {
        var c, d, e, f, g, h, i, j, k, l, m, n, o, p, q, r, s, t, u, v = this, w = !1, x = !0, y = !0, z = {
            barsSize: {
                top: 44,
                bottom: "auto"
            },
            closeElClasses: ["item", "caption", "zoom-wrap", "ui", "top-bar"],
            timeToIdle: 4e3,
            timeToIdleOutside: 1e3,
            loadingIndicatorDelay: 1e3,
            addCaptionHTMLFn: function(a, b) {
                return a.title ? (b.children[0].innerHTML = a.title,
                !0) : (b.children[0].innerHTML = "",
                !1)
            },
            closeEl: !0,
            captionEl: !0,
            fullscreenEl: !0,
            zoomEl: !0,
            shareEl: !0,
            counterEl: !0,
            arrowEl: !0,
            preloaderEl: !0,
            tapToClose: !1,
            tapToToggleControls: !0,
            clickToCloseNonZoomable: !0,
            shareButtons: [{
                id: "facebook",
                label: "Share on Facebook",
                url: "https://www.facebook.com/sharer/sharer.php?u={{url}}"
            }, {
                id: "twitter",
                label: "Tweet",
                url: "https://twitter.com/intent/tweet?text={{text}}&url={{url}}"
            }, {
                id: "pinterest",
                label: "Pin it",
                url: "http://www.pinterest.com/pin/create/button/?url={{url}}&media={{image_url}}&description={{text}}"
            }, {
                id: "download",
                label: "Download image",
                url: "{{raw_image_url}}",
                download: !0
            }],
            getImageURLForShare: function() {
                return a.currItem.src || ""
            },
            getPageURLForShare: function() {
                return window.location.href
            },
            getTextForShare: function() {
                return a.currItem.title || ""
            },
            indexIndicatorSep: " / ",
            fitControlsWidth: 1200
        }, A = function(a) {
            if (r)
                return !0;
            a = a || window.event,
            q.timeToIdle && q.mouseUsed && !k && K();
            for (var c, d, e = a.target || a.srcElement, f = e.getAttribute("class") || "", g = 0; g < S.length; g++)
                c = S[g],
                c.onTap && f.indexOf("pswp__" + c.name) > -1 && (c.onTap(),
                d = !0);
            if (d) {
                a.stopPropagation && a.stopPropagation(),
                r = !0;
                var h = b.features.isOldAndroid ? 600 : 30;
                s = setTimeout(function() {
                    r = !1
                }, h)
            }
        }, B = function() {
            return !a.likelyTouchDevice || q.mouseUsed || screen.width > q.fitControlsWidth
        }, C = function(a, c, d) {
            b[(d ? "add" : "remove") + "Class"](a, "pswp__" + c)
        }, D = function() {
            var a = 1 === q.getNumItemsFn();
            a !== p && (C(d, "ui--one-slide", a),
            p = a)
        }, E = function() {
            C(i, "share-modal--hidden", y)
        }, F = function() {
            return y = !y,
            y ? (b.removeClass(i, "pswp__share-modal--fade-in"),
            setTimeout(function() {
                y && E()
            }, 300)) : (E(),
            setTimeout(function() {
                y || b.addClass(i, "pswp__share-modal--fade-in")
            }, 30)),
            y || H(),
            !1
        }, G = function(b) {
            b = b || window.event;
            var c = b.target || b.srcElement;
            return a.shout("shareLinkClick", b, c),
            !!c.href && (!!c.hasAttribute("download") || (window.open(c.href, "pswp_share", "scrollbars=yes,resizable=yes,toolbar=no,location=yes,width=550,height=420,top=100,left=" + (window.screen ? Math.round(screen.width / 2 - 275) : 100)),
            y || F(),
            !1))
        }, H = function() {
            for (var a, b, c, d, e, f = "", g = 0; g < q.shareButtons.length; g++)
                a = q.shareButtons[g],
                c = q.getImageURLForShare(a),
                d = q.getPageURLForShare(a),
                e = q.getTextForShare(a),
                b = a.url.replace("{{url}}", encodeURIComponent(d)).replace("{{image_url}}", encodeURIComponent(c)).replace("{{raw_image_url}}", c).replace("{{text}}", encodeURIComponent(e)),
                f += '<a href="' + b + '" target="_blank" class="pswp__share--' + a.id + '"' + (a.download ? "download" : "") + ">" + a.label + "</a>",
                q.parseShareButtonOut && (f = q.parseShareButtonOut(a, f));
            i.children[0].innerHTML = f,
            i.children[0].onclick = G
        }, I = function(a) {
            for (var c = 0; c < q.closeElClasses.length; c++)
                if (b.hasClass(a, "pswp__" + q.closeElClasses[c]))
                    return !0
        }, J = 0, K = function() {
            clearTimeout(u),
            J = 0,
            k && v.setIdle(!1)
        }, L = function(a) {
            a = a ? a : window.event;
            var b = a.relatedTarget || a.toElement;
            b && "HTML" !== b.nodeName || (clearTimeout(u),
            u = setTimeout(function() {
                v.setIdle(!0)
            }, q.timeToIdleOutside))
        }, M = function() {
            q.fullscreenEl && !b.features.isOldAndroid && (c || (c = v.getFullscreenAPI()),
            c ? (b.bind(document, c.eventK, v.updateFullscreen),
            v.updateFullscreen(),
            b.addClass(a.template, "pswp--supports-fs")) : b.removeClass(a.template, "pswp--supports-fs"))
        }, N = function() {
            q.preloaderEl && (O(!0),
            l("beforeChange", function() {
                clearTimeout(o),
                o = setTimeout(function() {
                    a.currItem && a.currItem.loading ? (!a.allowProgressiveImg() || a.currItem.img && !a.currItem.img.naturalWidth) && O(!1) : O(!0)
                }, q.loadingIndicatorDelay)
            }),
            l("imageLoadComplete", function(b, c) {
                a.currItem === c && O(!0)
            }))
        }, O = function(a) {
            n !== a && (C(m, "preloader--active", !a),
            n = a)
        }, P = function(a) {
            var c = a.vGap;
            if (B()) {
                var g = q.barsSize;
                if (q.captionEl && "auto" === g.bottom)
                    if (f || (f = b.createEl("pswp__caption pswp__caption--fake"),
                    f.appendChild(b.createEl("pswp__caption__center")),
                    d.insertBefore(f, e),
                    b.addClass(d, "pswp__ui--fit")),
                    q.addCaptionHTMLFn(a, f, !0)) {
                        var h = f.clientHeight;
                        c.bottom = parseInt(h, 10) || 44
                    } else
                        c.bottom = g.top;
                else
                    c.bottom = "auto" === g.bottom ? 0 : g.bottom;
                c.top = g.top
            } else
                c.top = c.bottom = 0
        }, Q = function() {
            q.timeToIdle && l("mouseUsed", function() {
                b.bind(document, "mousemove", K),
                b.bind(document, "mouseout", L),
                t = setInterval(function() {
                    J++,
                    2 === J && v.setIdle(!0)
                }, q.timeToIdle / 2)
            })
        }, R = function() {
            l("onVerticalDrag", function(a) {
                x && a < .95 ? v.hideControls() : !x && a >= .95 && v.showControls()
            });
            var a;
            l("onPinchClose", function(b) {
                x && b < .9 ? (v.hideControls(),
                a = !0) : a && !x && b > .9 && v.showControls()
            }),
            l("zoomGestureEnded", function() {
                a = !1,
                a && !x && v.showControls()
            })
        }, S = [{
            name: "caption",
            option: "captionEl",
            onInit: function(a) {
                e = a
            }
        }, {
            name: "share-modal",
            option: "shareEl",
            onInit: function(a) {
                i = a
            },
            onTap: function() {
                F()
            }
        }, {
            name: "button--share",
            option: "shareEl",
            onInit: function(a) {
                h = a
            },
            onTap: function() {
                F()
            }
        }, {
            name: "button--zoom",
            option: "zoomEl",
            onTap: a.toggleDesktopZoom
        }, {
            name: "counter",
            option: "counterEl",
            onInit: function(a) {
                g = a
            }
        }, {
            name: "button--close",
            option: "closeEl",
            onTap: a.close
        }, {
            name: "button--arrow--left",
            option: "arrowEl",
            onTap: a.prev
        }, {
            name: "button--arrow--right",
            option: "arrowEl",
            onTap: a.next
        }, {
            name: "button--fs",
            option: "fullscreenEl",
            onTap: function() {
                c.isFullscreen() ? c.exit() : c.enter()
            }
        }, {
            name: "preloader",
            option: "preloaderEl",
            onInit: function(a) {
                m = a
            }
        }], T = function() {
            var a, c, e, f = function(d) {
                if (d)
                    for (var f = d.length, g = 0; g < f; g++) {
                        a = d[g],
                        c = a.className;
                        for (var h = 0; h < S.length; h++)
                            e = S[h],
                            c.indexOf("pswp__" + e.name) > -1 && (q[e.option] ? (b.removeClass(a, "pswp__element--disabled"),
                            e.onInit && e.onInit(a)) : b.addClass(a, "pswp__element--disabled"))
                    }
            };
            f(d.children);
            var g = b.getChildByClass(d, "pswp__top-bar");
            g && f(g.children)
        };
        v.init = function() {
            b.extend(a.options, z, !0),
            q = a.options,
            d = b.getChildByClass(a.scrollWrap, "pswp__ui"),
            l = a.listen,
            R(),
            l("beforeChange", v.update),
            l("doubleTap", function(b) {
                var c = a.currItem.initialZoomLevel;
                a.getZoomLevel() !== c ? a.zoomTo(c, b, 333) : a.zoomTo(q.getDoubleTapZoom(!1, a.currItem), b, 333)
            }),
            l("preventDragEvent", function(a, b, c) {
                var d = a.target || a.srcElement;
                d && d.getAttribute("class") && a.type.indexOf("mouse") > -1 && (d.getAttribute("class").indexOf("__caption") > 0 || /(SMALL|STRONG|EM)/i.test(d.tagName)) && (c.prevent = !1)
            }),
            l("bindEvents", function() {
                b.bind(d, "pswpTap click", A),
                b.bind(a.scrollWrap, "pswpTap", v.onGlobalTap),
                a.likelyTouchDevice || b.bind(a.scrollWrap, "mouseover", v.onMouseOver)
            }),
            l("unbindEvents", function() {
                y || F(),
                t && clearInterval(t),
                b.unbind(document, "mouseout", L),
                b.unbind(document, "mousemove", K),
                b.unbind(d, "pswpTap click", A),
                b.unbind(a.scrollWrap, "pswpTap", v.onGlobalTap),
                b.unbind(a.scrollWrap, "mouseover", v.onMouseOver),
                c && (b.unbind(document, c.eventK, v.updateFullscreen),
                c.isFullscreen() && (q.hideAnimationDuration = 0,
                c.exit()),
                c = null)
            }),
            l("destroy", function() {
                q.captionEl && (f && d.removeChild(f),
                b.removeClass(e, "pswp__caption--empty")),
                i && (i.children[0].onclick = null),
                b.removeClass(d, "pswp__ui--over-close"),
                b.addClass(d, "pswp__ui--hidden"),
                v.setIdle(!1)
            }),
            q.showAnimationDuration || b.removeClass(d, "pswp__ui--hidden"),
            l("initialZoomIn", function() {
                q.showAnimationDuration && b.removeClass(d, "pswp__ui--hidden")
            }),
            l("initialZoomOut", function() {
                b.addClass(d, "pswp__ui--hidden")
            }),
            l("parseVerticalMargin", P),
            T(),
            q.shareEl && h && i && (y = !0),
            D(),
            Q(),
            M(),
            N()
        }
        ,
        v.setIdle = function(a) {
            k = a,
            C(d, "ui--idle", a)
        }
        ,
        v.update = function() {
            x && a.currItem ? (v.updateIndexIndicator(),
            q.captionEl && (q.addCaptionHTMLFn(a.currItem, e),
            C(e, "caption--empty", !a.currItem.title)),
            w = !0) : w = !1,
            y || F(),
            D()
        }
        ,
        v.updateFullscreen = function(d) {
            d && setTimeout(function() {
                a.setScrollOffset(0, b.getScrollY())
            }, 50),
            b[(c.isFullscreen() ? "add" : "remove") + "Class"](a.template, "pswp--fs")
        }
        ,
        v.updateIndexIndicator = function() {
            q.counterEl && (g.innerHTML = a.getCurrentIndex() + 1 + q.indexIndicatorSep + q.getNumItemsFn())
        }
        ,
        v.onGlobalTap = function(c) {
            c = c || window.event;
            var d = c.target || c.srcElement;
            if (!r)
                if (c.detail && "mouse" === c.detail.pointerType) {
                    if (I(d))
                        return void a.close();
                    b.hasClass(d, "pswp__img") && (1 === a.getZoomLevel() && a.getZoomLevel() <= a.currItem.fitRatio ? q.clickToCloseNonZoomable && a.close() : a.toggleDesktopZoom(c.detail.releasePoint))
                } else if (q.tapToToggleControls && (x ? v.hideControls() : v.showControls()),
                q.tapToClose && (b.hasClass(d, "pswp__img") || I(d)))
                    return void a.close()
        }
        ,
        v.onMouseOver = function(a) {
            a = a || window.event;
            var b = a.target || a.srcElement;
            C(d, "ui--over-close", I(b))
        }
        ,
        v.hideControls = function() {
            b.addClass(d, "pswp__ui--hidden"),
            x = !1
        }
        ,
        v.showControls = function() {
            x = !0,
            w || v.update(),
            b.removeClass(d, "pswp__ui--hidden")
        }
        ,
        v.supportsFullscreen = function() {
            var a = document;
            return !!(a.exitFullscreen || a.mozCancelFullScreen || a.webkitExitFullscreen || a.msExitFullscreen)
        }
        ,
        v.getFullscreenAPI = function() {
            var b, c = document.documentElement, d = "fullscreenchange";
            return c.requestFullscreen ? b = {
                enterK: "requestFullscreen",
                exitK: "exitFullscreen",
                elementK: "fullscreenElement",
                eventK: d
            } : c.mozRequestFullScreen ? b = {
                enterK: "mozRequestFullScreen",
                exitK: "mozCancelFullScreen",
                elementK: "mozFullScreenElement",
                eventK: "moz" + d
            } : c.webkitRequestFullscreen ? b = {
                enterK: "webkitRequestFullscreen",
                exitK: "webkitExitFullscreen",
                elementK: "webkitFullscreenElement",
                eventK: "webkit" + d
            } : c.msRequestFullscreen && (b = {
                enterK: "msRequestFullscreen",
                exitK: "msExitFullscreen",
                elementK: "msFullscreenElement",
                eventK: "MSFullscreenChange"
            }),
            b && (b.enter = function() {
                return j = q.closeOnScroll,
                q.closeOnScroll = !1,
                "webkitRequestFullscreen" !== this.enterK ? a.template[this.enterK]() : void a.template[this.enterK](Element.ALLOW_KEYBOARD_INPUT)
            }
            ,
            b.exit = function() {
                return q.closeOnScroll = j,
                document[this.exitK]()
            }
            ,
            b.isFullscreen = function() {
                return document[this.elementK]
            }
            ),
            b
        }
    };
    return a
});
/*!
 * @preserve
 *
 * Readmore.js jQuery plugin
 * Author: @jed_foster
 * Project home: http://jedfoster.github.io/Readmore.js
 * Licensed under the MIT license
 *
 * Debounce function from http://davidwalsh.name/javascript-debounce-function
 */

/* global jQuery */

(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        module.exports = factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {
    'use strict';

    var readmore = 'readmore'
      , defaults = {
        speed: 100,
        collapsedHeight: 200,
        heightMargin: 16,
        moreLink: '<a href="#">Read More</a>',
        lessLink: '<a href="#">Close</a>',
        embedCSS: true,
        blockCSS: 'display: block; width: 100%;',
        startOpen: false,

        // callbacks
        blockProcessed: function() {},
        beforeToggle: function() {},
        afterToggle: function() {}
    }
      , cssEmbedded = {}
      , uniqueIdCounter = 0;

    function debounce(func, wait, immediate) {
        var timeout;

        return function() {
            var context = this
              , args = arguments;
            var later = function() {
                timeout = null;
                if (!immediate) {
                    func.apply(context, args);
                }
            };
            var callNow = immediate && !timeout;

            clearTimeout(timeout);
            timeout = setTimeout(later, wait);

            if (callNow) {
                func.apply(context, args);
            }
        }
        ;
    }

    function uniqueId(prefix) {
        var id = ++uniqueIdCounter;

        return String(prefix == null ? 'rmjs-' : prefix) + id;
    }

    function setBoxHeights(element) {
        var el = element.clone().css({
            height: 'auto',
            width: element.width(),
            maxHeight: 'none',
            overflow: 'hidden'
        }).insertAfter(element)
          , expandedHeight = el.outerHeight()
          , cssMaxHeight = parseInt(el.css({
            maxHeight: ''
        }).css('max-height').replace(/[^-\d\.]/g, ''), 10)
          , defaultHeight = element.data('defaultHeight');

        el.remove();

        var collapsedHeight = cssMaxHeight || element.data('collapsedHeight') || defaultHeight;

        // Store our measurements.
        element.data({
            expandedHeight: expandedHeight,
            maxHeight: cssMaxHeight,
            collapsedHeight: collapsedHeight
        })// and disable any `max-height` property set in CSS
        .css({
            maxHeight: 'none'
        });
    }

    var resizeBoxes = debounce(function() {
        $('[data-readmore]').each(function() {
            var current = $(this)
              , isExpanded = (current.attr('aria-expanded') === 'true');

            setBoxHeights(current);

            current.css({
                height: current.data((isExpanded ? 'expandedHeight' : 'collapsedHeight'))
            });
        });
    }, 100);

    function embedCSS(options) {
        if (!cssEmbedded[options.selector]) {
            var styles = ' ';

            if (options.embedCSS && options.blockCSS !== '') {
                styles += options.selector + ' + [data-readmore-toggle], ' + options.selector + '[data-readmore]{' + options.blockCSS + '}';
            }

            // Include the transition CSS even if embedCSS is false
            styles += options.selector + '[data-readmore]{' + 'transition: height ' + options.speed + 'ms;' + 'overflow: hidden;' + '}';

            (function(d, u) {
                var css = d.createElement('style');
                css.type = 'text/css';

                if (css.styleSheet) {
                    css.styleSheet.cssText = u;
                } else {
                    css.appendChild(d.createTextNode(u));
                }

                d.getElementsByTagName('head')[0].appendChild(css);
            }(document, styles));

            cssEmbedded[options.selector] = true;
        }
    }

    function Readmore(element, options) {
        this.element = element;

        this.options = $.extend({}, defaults, options);

        embedCSS(this.options);

        this._defaults = defaults;
        this._name = readmore;

        this.init();

        // IE8 chokes on `window.addEventListener`, so need to test for support.
        if (window.addEventListener) {
            // Need to resize boxes when the page has fully loaded.
            window.addEventListener('load', resizeBoxes);
            window.addEventListener('resize', resizeBoxes);
        } else {
            window.attachEvent('load', resizeBoxes);
            window.attachEvent('resize', resizeBoxes);
        }
    }

    Readmore.prototype = {
        init: function() {
            var current = $(this.element);

            current.data({
                defaultHeight: this.options.collapsedHeight,
                heightMargin: this.options.heightMargin
            });

            setBoxHeights(current);

            var collapsedHeight = current.data('collapsedHeight')
              , heightMargin = current.data('heightMargin');

            if (current.outerHeight(true) <= collapsedHeight + heightMargin) {
                // The block is shorter than the limit, so there's no need to truncate it.
                if (this.options.blockProcessed && typeof this.options.blockProcessed === 'function') {
                    this.options.blockProcessed(current, false);
                }
                return true;
            } else {
                var id = current.attr('id') || uniqueId()
                  , useLink = this.options.startOpen ? this.options.lessLink : this.options.moreLink;

                current.attr({
                    'data-readmore': '',
                    'aria-expanded': this.options.startOpen,
                    'id': id
                });

                current.after($(useLink).on('click', (function(_this) {
                    return function(event) {
                        _this.toggle(this, current[0], event);
                    }
                    ;
                }
                )(this)).attr({
                    'data-readmore-toggle': id,
                    'aria-controls': id
                }));

                if (!this.options.startOpen) {
                    current.css({
                        height: collapsedHeight
                    });
                }

                if (this.options.blockProcessed && typeof this.options.blockProcessed === 'function') {
                    this.options.blockProcessed(current, true);
                }
            }
        },

        toggle: function(trigger, element, event) {
            if (event) {
                event.preventDefault();
            }

            if (!trigger) {
                trigger = $('[aria-controls="' + this.element.id + '"]')[0];
            }

            if (!element) {
                element = this.element;
            }

            var $element = $(element)
              , newHeight = ''
              , newLink = ''
              , expanded = false
              , collapsedHeight = $element.data('collapsedHeight');

            if ($element.height() <= collapsedHeight) {
                newHeight = $element.data('expandedHeight') + 'px';
                newLink = 'lessLink';
                expanded = true;
            } else {
                newHeight = collapsedHeight;
                newLink = 'moreLink';
            }

            // Fire beforeToggle callback
            // Since we determined the new "expanded" state above we're now out of sync
            // with our true current state, so we need to flip the value of `expanded`
            if (this.options.beforeToggle && typeof this.options.beforeToggle === 'function') {
                this.options.beforeToggle(trigger, $element, !expanded);
            }

            $element.css({
                'height': newHeight
            });

            // Fire afterToggle callback
            $element.on('transitionend', (function(_this) {
                return function() {
                    if (_this.options.afterToggle && typeof _this.options.afterToggle === 'function') {
                        _this.options.afterToggle(trigger, $element, expanded);
                    }

                    $(this).attr({
                        'aria-expanded': expanded
                    }).off('transitionend');
                }
            }
            )(this));

            $(trigger).replaceWith($(this.options[newLink]).on('click', (function(_this) {
                return function(event) {
                    _this.toggle(this, element, event);
                }
                ;
            }
            )(this)).attr({
                'data-readmore-toggle': $element.attr('id'),
                'aria-controls': $element.attr('id')
            }));
        },

        destroy: function() {
            $(this.element).each(function() {
                var current = $(this);

                current.attr({
                    'data-readmore': null,
                    'aria-expanded': null
                }).css({
                    maxHeight: '',
                    height: ''
                }).next('[data-readmore-toggle]').remove();

                current.removeData();
            });
        }
    };

    $.fn.readmore = function(options) {
        var args = arguments
          , selector = this.selector;

        options = options || {};

        if (typeof options === 'object') {
            return this.each(function() {
                if ($.data(this, 'plugin_' + readmore)) {
                    var instance = $.data(this, 'plugin_' + readmore);
                    instance.destroy.apply(instance);
                }

                options.selector = selector;

                $.data(this, 'plugin_' + readmore, new Readmore(this,options));
            });
        } else if (typeof options === 'string' && options[0] !== '_' && options !== 'init') {
            return this.each(function() {
                var instance = $.data(this, 'plugin_' + readmore);
                if (instance instanceof Readmore && typeof instance[options] === 'function') {
                    instance[options].apply(instance, Array.prototype.slice.call(args, 1));
                }
            });
        }
    }
    ;

}));

function initBasketQuantityUpdate() {

    jQuery(document).on('change paste keyup', '#shopping-cart-table .input-text', function(e) {
        var itemId = jQuery(this).data('cart-item-id');
        jQuery('.update-' + itemId).removeClass('hide');
    });

    jQuery(document).on('click', '#shopping-cart-table .btn-product-update', function(e) {
        e.preventDefault();
        jQuery('button[name="update_cart_action"].btn-update').click();
    });
}
function initCouponButtonSwitch() {
    // Basket page
    jQuery(document).on('change paste keyup', '#coupon_code', function() {
        jQuery('#coupon_apply').show();
        jQuery('#coupon_remove').hide();
    });
    // Checkout page
    jQuery(document).on('change paste keyup', '#id_couponcode', function() {
        jQuery('#onestepcheckout-coupon-add').show();
        jQuery('#onestepcheckout-coupon-remove').hide();
    });
}
function reflowFoundationDropdown() {
    jQuery(document).foundation('dropdown', 'reflow');
}

function reflowFoundationAccordion() {
    jQuery(document).foundation('accordion', 'reflow');
}

function reflowFoundationTab() {
    jQuery(document).foundation('tab', 'reflow');
}

function reflowFoundationReveal() {
    jQuery(document).foundation('reveal', 'reflow');
}

function reflowAbide() {
    jQuery(document).foundation('abide', 'reflow');
}

function reflowTabs() {
    jQuery(document).foundation('tab', 'reflow');
}

function reflowAccordion() {
    jQuery(document).foundation('accordion', 'reflow');
}

function imageBlazy() {
    var bLazy = new Blazy({
        selector: '.lazy-image',
        offset: 200,
        successClass: 'lazy-image-loaded'
    });
}

function initLayeredNavOpener() {
    jQuery('body').on('click', '.layered-nav-opener', function() {
        jQuery(this).toggleClass('open');
    });
}
function reevalLogicSpotCategoryPage() {
    imageBlazy();
    reflowFoundationDropdown();
}
function initResponsiveTables() {
    var switched = false;
    var updateTables = function() {
        if ((jQuery(window).width() < 767) && !switched) {
            switched = true;
            jQuery("table.responsive").each(function(i, element) {
                splitTable(jQuery(element));
            });
            return true;
        } else if (switched && (jQuery(window).width() > 767)) {
            switched = false;
            jQuery("table.responsive").each(function(i, element) {
                unsplitTable(jQuery(element));
            });
        }
    };

    jQuery(window).load(updateTables);
    jQuery(window).on("redraw", function() {
        switched = false;
        updateTables();
    });
    // An event to listen for
    jQuery(window).on("resize", updateTables);
}

function splitTable(original) {
    original.wrap("<div class='table-wrapper' />");

    var copy = original.clone();
    copy.find("td:not(:first-child), th:not(:first-child)").css("display", "none");
    copy.removeClass("responsive");

    original.closest(".table-wrapper").append(copy);
    copy.wrap("<div class='pinned' />");
    original.wrap("<div class='scrollable' />");

    setCellHeights(original, copy);
}

function unsplitTable(original) {
    original.closest(".table-wrapper").find(".pinned").remove();
    original.unwrap();
    original.unwrap();
}

function setCellHeights(original, copy) {
    var tr = original.find('tr')
      , tr_copy = copy.find('tr')
      , heights = [];

    tr.each(function(index) {
        var self = jQuery(this)
          , tx = self.find('th, td');

        tx.each(function() {
            var height = jQuery(this).outerHeight(true);
            heights[index] = heights[index] || 0;
            if (height > heights[index])
                heights[index] = height;
        });

    });

    tr_copy.each(function(index) {
        jQuery(this).height(heights[index]);
    });
}
function initOffCanvasLeftActions() {
    jQuery(document).on('open.fndtn.offcanvas', '[data-offcanvas]', function() {
        jQuery('html').css('overflow', 'hidden');
    });

    jQuery(document).on('close.fndtn.offcanvas', '[data-offcanvas]', function() {
        jQuery('html').css('overflow', 'auto');
    });

    // Actions for the Left Hand Off Canvas Menu
    jQuery(document).on('click', '.left-off-canvas-menu .has-dropdown > a', function(e) {
        e.stopImmediatePropagation();
        e.preventDefault();
        // on first click, prevent anchor, apply class Open
        console.log(jQuery(this).parent().hasClass('open'));
        if (jQuery(this).parent().hasClass('open') === false) {
            // remove any open class before applying
            jQuery('.has-dropdown').removeClass('open');
            jQuery(this).parent().addClass('open');
        } else {
            jQuery(this).parent().removeClass('open');
        }
    });
}

function stickyCheckout() {
    if (Foundation.utils.is_large_up()) {
        var checkoutSticky = new Waypoint.Sticky({
            element: jQuery('.onestepcheckout-place-order-wrapper')[0],
            handler: function() {
                var parent = jQuery(this.element).parent();
                var maxWidth = parent.width();
                jQuery(this.element).width(maxWidth);
            }
        });

        var unstickCheckoutSticky = new Waypoint({
            element: jQuery('footer')[0],
            offset: 120,
            handler: function() {
                jQuery(checkoutSticky.element).fadeToggle(200);
            }
        });
    }
}

function observeCustomerButton() {
    jQuery(document).on('click', '.checkout-new-customer', function() {
        jQuery('.checkout-wrapper').removeClass('checkout-wrapper-hidden');
        jQuery('html, body').animate({
            scrollTop: jQuery(".checkout-wrapper").offset().top - 30
        }, 1000);
    });
}

function checkoutCardValidator() {
    if (jQuery('#sagepaydirectpro_cc_number').length) {
        jQuery('#sagepaydirectpro_cc_number').validateCreditCard(function(result) {
            if (result.card_type) {
                switch (result.card_type.name) {
                case 'amex':
                    mageCardType = 'AMEX';
                    break;
                case 'visa_electron':
                    mageCardType = 'UKE';
                    break;
                case 'visa':
                    mageCardType = 'VISA';
                    break;
                case 'mastercard':
                    mageCardType = 'MC';
                    break;
                case 'maestro':
                    mageCardType = 'SWITCH';
                    break;
                case 'discover':
                    /* falls through */
                case 'diners_club_carte_blanche':
                    /* falls through */
                case 'diners_club_international':
                    /* falls through */
                case 'jcb':
                    /* falls through */
                case 'laser':
                    /* falls through */
                default:
                    mageCardType = false;
                    break;
                }
                console.log(mageCardType);
                if (mageCardType) {
                    jQuery(this).attr('data-card-type', result.card_type.name);
                    jQuery('.ls_card_type').addClass('zero-height');
                    jQuery('select[name="payment[cc_type]"]').find("option[value=" + mageCardType + "]").prop("selected", true);
                } else {
                    jQuery(this).attr('data-card-type', '');
                    jQuery('.ls_card_type').removeClass('zero-height');
                }
            } else {
                jQuery(this).attr('data-card-type', '');
                if (this.val().length >= 4) {
                    jQuery('.ls_card_type').removeClass('zero-height');
                }
            }
        });

        jQuery(function() {
            jQuery('input[name="payment[cc_number]"]').validateCreditCard(function(result) {
                if (result.card_type) {
                    jQuery(this).attr('data-card-type', result.card_type.name);
                    jQuery('select[name="payment[cc_type]"]').find("option[data-js-card=" + result.card_type.name + "]").prop("selected", true);
                } else {
                    jQuery(this).attr('data-card-type', '');
                }
            });
        });
    }
}

function checkoutSaveCardTrigger() {
    jQuery(document).on('click', '#remembertoken-sagepaydirectpro', function(e) {
        var remembertoken = jQuery('#remembertoken-sagepaydirectpro');
        if (remembertoken.is(':checked')) {
            remembertoken.parent().parent().addClass('checked');
        } else {
            remembertoken.parent().parent().removeClass('checked');
        }
    });
}

function revealTextInit() {
    jQuery('.revealtext').addClass('revealtext-hide');
    jQuery(document).on('click', '[data-revealtext]', function(e) {
        e.preventDefault();

        targetId = jQuery(this).toggleClass('open').data('revealtext');
        jQuery('#' + targetId).toggleClass('revealtext-hide')
    });
}

revealTextInit();

function ls_alert(options) {

    // Note that not all SweetAlert options are below, just a few overwritten ones
    var defaultParams = {
        animation: false,
        allowOutsideClick: false,
        allowEscapeKey: false,
        confirmButtonColor: null,
        buttonsStyling: false
    };

    options = jQuery.extend({}, defaultParams, options);

    if ('function' == typeof swal) {
        swal(options).done();
    } else {
        alert(options.text);
    }
}

function initRemoveProductLink() {
    jQuery(document).on('click', '#cart-sidebar .btn-remove', function(e) {

        var url = jQuery(e.target).attr('href');

        var defaultParams = {
            title: 'Please confirm',
            text: 'Are you sure you would like to remove this item from the shopping cart?',
            animation: false,
            confirmButtonColor: null,
            showCancelButton: true,
            cancelButtonClass: 'alert',
            cancelButtonColor: null,
            buttonsStyling: false
        };

        if ('function' == typeof swal) {
            e.preventDefault();
            swal(defaultParams).then(function() {
                window.location.href = url;
            }).done();
        } else {
            confirm('Are you sure you would like to remove this item from the shopping cart?');
        }
    });
}

//! moment.js

;(function(global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.moment = factory()
}(this, (function() {
    'use strict';

    var hookCallback;

    function hooks() {
        return hookCallback.apply(null, arguments);
    }

    // This is done to register the method called with moment()
    // without creating circular dependencies.
    function setHookCallback(callback) {
        hookCallback = callback;
    }

    function isArray(input) {
        return input instanceof Array || Object.prototype.toString.call(input) === '[object Array]';
    }

    function isObject(input) {
        // IE8 will treat undefined and null as object if it wasn't for
        // input != null
        return input != null && Object.prototype.toString.call(input) === '[object Object]';
    }

    function isObjectEmpty(obj) {
        if (Object.getOwnPropertyNames) {
            return (Object.getOwnPropertyNames(obj).length === 0);
        } else {
            var k;
            for (k in obj) {
                if (obj.hasOwnProperty(k)) {
                    return false;
                }
            }
            return true;
        }
    }

    function isUndefined(input) {
        return input === void 0;
    }

    function isNumber(input) {
        return typeof input === 'number' || Object.prototype.toString.call(input) === '[object Number]';
    }

    function isDate(input) {
        return input instanceof Date || Object.prototype.toString.call(input) === '[object Date]';
    }

    function map(arr, fn) {
        var res = [], i;
        for (i = 0; i < arr.length; ++i) {
            res.push(fn(arr[i], i));
        }
        return res;
    }

    function hasOwnProp(a, b) {
        return Object.prototype.hasOwnProperty.call(a, b);
    }

    function extend(a, b) {
        for (var i in b) {
            if (hasOwnProp(b, i)) {
                a[i] = b[i];
            }
        }

        if (hasOwnProp(b, 'toString')) {
            a.toString = b.toString;
        }

        if (hasOwnProp(b, 'valueOf')) {
            a.valueOf = b.valueOf;
        }

        return a;
    }

    function createUTC(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, true).utc();
    }

    function defaultParsingFlags() {
        // We need to deep clone this object.
        return {
            empty: false,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: false,
            invalidMonth: null,
            invalidFormat: false,
            userInvalidated: false,
            iso: false,
            parsedDateParts: [],
            meridiem: null,
            rfc2822: false,
            weekdayMismatch: false
        };
    }

    function getParsingFlags(m) {
        if (m._pf == null) {
            m._pf = defaultParsingFlags();
        }
        return m._pf;
    }

    var some;
    if (Array.prototype.some) {
        some = Array.prototype.some;
    } else {
        some = function(fun) {
            var t = Object(this);
            var len = t.length >>> 0;

            for (var i = 0; i < len; i++) {
                if (i in t && fun.call(this, t[i], i, t)) {
                    return true;
                }
            }

            return false;
        }
        ;
    }

    function isValid(m) {
        if (m._isValid == null) {
            var flags = getParsingFlags(m);
            var parsedParts = some.call(flags.parsedDateParts, function(i) {
                return i != null;
            });
            var isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || (flags.meridiem && parsedParts));

            if (m._strict) {
                isNowValid = isNowValid && flags.charsLeftOver === 0 && flags.unusedTokens.length === 0 && flags.bigHour === undefined;
            }

            if (Object.isFrozen == null || !Object.isFrozen(m)) {
                m._isValid = isNowValid;
            } else {
                return isNowValid;
            }
        }
        return m._isValid;
    }

    function createInvalid(flags) {
        var m = createUTC(NaN);
        if (flags != null) {
            extend(getParsingFlags(m), flags);
        } else {
            getParsingFlags(m).userInvalidated = true;
        }

        return m;
    }

    // Plugins that add properties should also add the key here (null value),
    // so we can properly clone ourselves.
    var momentProperties = hooks.momentProperties = [];

    function copyConfig(to, from) {
        var i, prop, val;

        if (!isUndefined(from._isAMomentObject)) {
            to._isAMomentObject = from._isAMomentObject;
        }
        if (!isUndefined(from._i)) {
            to._i = from._i;
        }
        if (!isUndefined(from._f)) {
            to._f = from._f;
        }
        if (!isUndefined(from._l)) {
            to._l = from._l;
        }
        if (!isUndefined(from._strict)) {
            to._strict = from._strict;
        }
        if (!isUndefined(from._tzm)) {
            to._tzm = from._tzm;
        }
        if (!isUndefined(from._isUTC)) {
            to._isUTC = from._isUTC;
        }
        if (!isUndefined(from._offset)) {
            to._offset = from._offset;
        }
        if (!isUndefined(from._pf)) {
            to._pf = getParsingFlags(from);
        }
        if (!isUndefined(from._locale)) {
            to._locale = from._locale;
        }

        if (momentProperties.length > 0) {
            for (i = 0; i < momentProperties.length; i++) {
                prop = momentProperties[i];
                val = from[prop];
                if (!isUndefined(val)) {
                    to[prop] = val;
                }
            }
        }

        return to;
    }

    var updateInProgress = false;

    // Moment prototype object
    function Moment(config) {
        copyConfig(this, config);
        this._d = new Date(config._d != null ? config._d.getTime() : NaN);
        if (!this.isValid()) {
            this._d = new Date(NaN);
        }
        // Prevent infinite loop in case updateOffset creates new moment
        // objects.
        if (updateInProgress === false) {
            updateInProgress = true;
            hooks.updateOffset(this);
            updateInProgress = false;
        }
    }

    function isMoment(obj) {
        return obj instanceof Moment || (obj != null && obj._isAMomentObject != null);
    }

    function absFloor(number) {
        if (number < 0) {
            // -0 -> 0
            return Math.ceil(number) || 0;
        } else {
            return Math.floor(number);
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion
          , value = 0;

        if (coercedNumber !== 0 && isFinite(coercedNumber)) {
            value = absFloor(coercedNumber);
        }

        return value;
    }

    // compare two arrays, return the number of differences
    function compareArrays(array1, array2, dontConvert) {
        var len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0, i;
        for (i = 0; i < len; i++) {
            if ((dontConvert && array1[i] !== array2[i]) || (!dontConvert && toInt(array1[i]) !== toInt(array2[i]))) {
                diffs++;
            }
        }
        return diffs + lengthDiff;
    }

    function warn(msg) {
        if (hooks.suppressDeprecationWarnings === false && (typeof console !== 'undefined') && console.warn) {
            console.warn('Deprecation warning: ' + msg);
        }
    }

    function deprecate(msg, fn) {
        var firstTime = true;

        return extend(function() {
            if (hooks.deprecationHandler != null) {
                hooks.deprecationHandler(null, msg);
            }
            if (firstTime) {
                var args = [];
                var arg;
                for (var i = 0; i < arguments.length; i++) {
                    arg = '';
                    if (typeof arguments[i] === 'object') {
                        arg += '\n[' + i + '] ';
                        for (var key in arguments[0]) {
                            arg += key + ': ' + arguments[0][key] + ', ';
                        }
                        arg = arg.slice(0, -2);
                        // Remove trailing comma and space
                    } else {
                        arg = arguments[i];
                    }
                    args.push(arg);
                }
                warn(msg + '\nArguments: ' + Array.prototype.slice.call(args).join('') + '\n' + (new Error()).stack);
                firstTime = false;
            }
            return fn.apply(this, arguments);
        }, fn);
    }

    var deprecations = {};

    function deprecateSimple(name, msg) {
        if (hooks.deprecationHandler != null) {
            hooks.deprecationHandler(name, msg);
        }
        if (!deprecations[name]) {
            warn(msg);
            deprecations[name] = true;
        }
    }

    hooks.suppressDeprecationWarnings = false;
    hooks.deprecationHandler = null;

    function isFunction(input) {
        return input instanceof Function || Object.prototype.toString.call(input) === '[object Function]';
    }

    function set(config) {
        var prop, i;
        for (i in config) {
            prop = config[i];
            if (isFunction(prop)) {
                this[i] = prop;
            } else {
                this['_' + i] = prop;
            }
        }
        this._config = config;
        // Lenient ordinal parsing accepts just a number in addition to
        // number + (possibly) stuff coming from _dayOfMonthOrdinalParse.
        // TODO: Remove "ordinalParse" fallback in next major release.
        this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + '|' + (/\d{1,2}/).source);
    }

    function mergeConfigs(parentConfig, childConfig) {
        var res = extend({}, parentConfig), prop;
        for (prop in childConfig) {
            if (hasOwnProp(childConfig, prop)) {
                if (isObject(parentConfig[prop]) && isObject(childConfig[prop])) {
                    res[prop] = {};
                    extend(res[prop], parentConfig[prop]);
                    extend(res[prop], childConfig[prop]);
                } else if (childConfig[prop] != null) {
                    res[prop] = childConfig[prop];
                } else {
                    delete res[prop];
                }
            }
        }
        for (prop in parentConfig) {
            if (hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop])) {
                // make sure changes to properties don't modify parent config
                res[prop] = extend({}, res[prop]);
            }
        }
        return res;
    }

    function Locale(config) {
        if (config != null) {
            this.set(config);
        }
    }

    var keys;

    if (Object.keys) {
        keys = Object.keys;
    } else {
        keys = function(obj) {
            var i, res = [];
            for (i in obj) {
                if (hasOwnProp(obj, i)) {
                    res.push(i);
                }
            }
            return res;
        }
        ;
    }

    var defaultCalendar = {
        sameDay: '[Today at] LT',
        nextDay: '[Tomorrow at] LT',
        nextWeek: 'dddd [at] LT',
        lastDay: '[Yesterday at] LT',
        lastWeek: '[Last] dddd [at] LT',
        sameElse: 'L'
    };

    function calendar(key, mom, now) {
        var output = this._calendar[key] || this._calendar['sameElse'];
        return isFunction(output) ? output.call(mom, now) : output;
    }

    var defaultLongDateFormat = {
        LTS: 'h:mm:ss A',
        LT: 'h:mm A',
        L: 'MM/DD/YYYY',
        LL: 'MMMM D, YYYY',
        LLL: 'MMMM D, YYYY h:mm A',
        LLLL: 'dddd, MMMM D, YYYY h:mm A'
    };

    function longDateFormat(key) {
        var format = this._longDateFormat[key]
          , formatUpper = this._longDateFormat[key.toUpperCase()];

        if (format || !formatUpper) {
            return format;
        }

        this._longDateFormat[key] = formatUpper.replace(/MMMM|MM|DD|dddd/g, function(val) {
            return val.slice(1);
        });

        return this._longDateFormat[key];
    }

    var defaultInvalidDate = 'Invalid date';

    function invalidDate() {
        return this._invalidDate;
    }

    var defaultOrdinal = '%d';
    var defaultDayOfMonthOrdinalParse = /\d{1,2}/;

    function ordinal(number) {
        return this._ordinal.replace('%d', number);
    }

    var defaultRelativeTime = {
        future: 'in %s',
        past: '%s ago',
        s: 'a few seconds',
        ss: '%d seconds',
        m: 'a minute',
        mm: '%d minutes',
        h: 'an hour',
        hh: '%d hours',
        d: 'a day',
        dd: '%d days',
        M: 'a month',
        MM: '%d months',
        y: 'a year',
        yy: '%d years'
    };

    function relativeTime(number, withoutSuffix, string, isFuture) {
        var output = this._relativeTime[string];
        return (isFunction(output)) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number);
    }

    function pastFuture(diff, output) {
        var format = this._relativeTime[diff > 0 ? 'future' : 'past'];
        return isFunction(format) ? format(output) : format.replace(/%s/i, output);
    }

    var aliases = {};

    function addUnitAlias(unit, shorthand) {
        var lowerCase = unit.toLowerCase();
        aliases[lowerCase] = aliases[lowerCase + 's'] = aliases[shorthand] = unit;
    }

    function normalizeUnits(units) {
        return typeof units === 'string' ? aliases[units] || aliases[units.toLowerCase()] : undefined;
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedInput = {}, normalizedProp, prop;

        for (prop in inputObject) {
            if (hasOwnProp(inputObject, prop)) {
                normalizedProp = normalizeUnits(prop);
                if (normalizedProp) {
                    normalizedInput[normalizedProp] = inputObject[prop];
                }
            }
        }

        return normalizedInput;
    }

    var priorities = {};

    function addUnitPriority(unit, priority) {
        priorities[unit] = priority;
    }

    function getPrioritizedUnits(unitsObj) {
        var units = [];
        for (var u in unitsObj) {
            units.push({
                unit: u,
                priority: priorities[u]
            });
        }
        units.sort(function(a, b) {
            return a.priority - b.priority;
        });
        return units;
    }

    function zeroFill(number, targetLength, forceSign) {
        var absNumber = '' + Math.abs(number)
          , zerosToFill = targetLength - absNumber.length
          , sign = number >= 0;
        return (sign ? (forceSign ? '+' : '') : '-') + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber;
    }

    var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g;

    var localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g;

    var formatFunctions = {};

    var formatTokenFunctions = {};

    // token:    'M'
    // padded:   ['MM', 2]
    // ordinal:  'Mo'
    // callback: function () { this.month() + 1 }
    function addFormatToken(token, padded, ordinal, callback) {
        var func = callback;
        if (typeof callback === 'string') {
            func = function() {
                return this[callback]();
            }
            ;
        }
        if (token) {
            formatTokenFunctions[token] = func;
        }
        if (padded) {
            formatTokenFunctions[padded[0]] = function() {
                return zeroFill(func.apply(this, arguments), padded[1], padded[2]);
            }
            ;
        }
        if (ordinal) {
            formatTokenFunctions[ordinal] = function() {
                return this.localeData().ordinal(func.apply(this, arguments), token);
            }
            ;
        }
    }

    function removeFormattingTokens(input) {
        if (input.match(/\[[\s\S]/)) {
            return input.replace(/^\[|\]$/g, '');
        }
        return input.replace(/\\/g, '');
    }

    function makeFormatFunction(format) {
        var array = format.match(formattingTokens), i, length;

        for (i = 0,
        length = array.length; i < length; i++) {
            if (formatTokenFunctions[array[i]]) {
                array[i] = formatTokenFunctions[array[i]];
            } else {
                array[i] = removeFormattingTokens(array[i]);
            }
        }

        return function(mom) {
            var output = '', i;
            for (i = 0; i < length; i++) {
                output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
            }
            return output;
        }
        ;
    }

    // format date using native date object
    function formatMoment(m, format) {
        if (!m.isValid()) {
            return m.localeData().invalidDate();
        }

        format = expandFormat(format, m.localeData());
        formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format);

        return formatFunctions[format](m);
    }

    function expandFormat(format, locale) {
        var i = 5;

        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input;
        }

        localFormattingTokens.lastIndex = 0;
        while (i >= 0 && localFormattingTokens.test(format)) {
            format = format.replace(localFormattingTokens, replaceLongDateFormatTokens);
            localFormattingTokens.lastIndex = 0;
            i -= 1;
        }

        return format;
    }

    var match1 = /\d/;
    //       0 - 9
    var match2 = /\d\d/;
    //      00 - 99
    var match3 = /\d{3}/;
    //     000 - 999
    var match4 = /\d{4}/;
    //    0000 - 9999
    var match6 = /[+-]?\d{6}/;
    // -999999 - 999999
    var match1to2 = /\d\d?/;
    //       0 - 99
    var match3to4 = /\d\d\d\d?/;
    //     999 - 9999
    var match5to6 = /\d\d\d\d\d\d?/;
    //   99999 - 999999
    var match1to3 = /\d{1,3}/;
    //       0 - 999
    var match1to4 = /\d{1,4}/;
    //       0 - 9999
    var match1to6 = /[+-]?\d{1,6}/;
    // -999999 - 999999

    var matchUnsigned = /\d+/;
    //       0 - inf
    var matchSigned = /[+-]?\d+/;
    //    -inf - inf

    var matchOffset = /Z|[+-]\d\d:?\d\d/gi;
    // +00:00 -00:00 +0000 -0000 or Z
    var matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi;
    // +00 -00 +00:00 -00:00 +0000 -0000 or Z

    var matchTimestamp = /[+-]?\d+(\.\d{1,3})?/;
    // 123456789 123456789.123

    // any word (or two) characters or numbers including two/three word month in arabic.
    // includes scottish gaelic two word and hyphenated months
    var matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

    var regexes = {};

    function addRegexToken(token, regex, strictRegex) {
        regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
            return (isStrict && strictRegex) ? strictRegex : regex;
        }
        ;
    }

    function getParseRegexForToken(token, config) {
        if (!hasOwnProp(regexes, token)) {
            return new RegExp(unescapeFormat(token));
        }

        return regexes[token](config._strict, config._locale);
    }

    // Code from http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript
    function unescapeFormat(s) {
        return regexEscape(s.replace('\\', '').replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function(matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4;
        }));
    }

    function regexEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
    }

    var tokens = {};

    function addParseToken(token, callback) {
        var i, func = callback;
        if (typeof token === 'string') {
            token = [token];
        }
        if (isNumber(callback)) {
            func = function(input, array) {
                array[callback] = toInt(input);
            }
            ;
        }
        for (i = 0; i < token.length; i++) {
            tokens[token[i]] = func;
        }
    }

    function addWeekParseToken(token, callback) {
        addParseToken(token, function(input, array, config, token) {
            config._w = config._w || {};
            callback(input, config._w, config, token);
        });
    }

    function addTimeToArrayFromToken(token, input, config) {
        if (input != null && hasOwnProp(tokens, token)) {
            tokens[token](input, config._a, config, token);
        }
    }

    var YEAR = 0;
    var MONTH = 1;
    var DATE = 2;
    var HOUR = 3;
    var MINUTE = 4;
    var SECOND = 5;
    var MILLISECOND = 6;
    var WEEK = 7;
    var WEEKDAY = 8;

    // FORMATTING

    addFormatToken('Y', 0, 0, function() {
        var y = this.year();
        return y <= 9999 ? '' + y : '+' + y;
    });

    addFormatToken(0, ['YY', 2], 0, function() {
        return this.year() % 100;
    });

    addFormatToken(0, ['YYYY', 4], 0, 'year');
    addFormatToken(0, ['YYYYY', 5], 0, 'year');
    addFormatToken(0, ['YYYYYY', 6, true], 0, 'year');

    // ALIASES

    addUnitAlias('year', 'y');

    // PRIORITIES

    addUnitPriority('year', 1);

    // PARSING

    addRegexToken('Y', matchSigned);
    addRegexToken('YY', match1to2, match2);
    addRegexToken('YYYY', match1to4, match4);
    addRegexToken('YYYYY', match1to6, match6);
    addRegexToken('YYYYYY', match1to6, match6);

    addParseToken(['YYYYY', 'YYYYYY'], YEAR);
    addParseToken('YYYY', function(input, array) {
        array[YEAR] = input.length === 2 ? hooks.parseTwoDigitYear(input) : toInt(input);
    });
    addParseToken('YY', function(input, array) {
        array[YEAR] = hooks.parseTwoDigitYear(input);
    });
    addParseToken('Y', function(input, array) {
        array[YEAR] = parseInt(input, 10);
    });

    // HELPERS

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365;
    }

    function isLeapYear(year) {
        return (year % 4 === 0 && year % 100 !== 0) || year % 400 === 0;
    }

    // HOOKS

    hooks.parseTwoDigitYear = function(input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2000);
    }
    ;

    // MOMENTS

    var getSetYear = makeGetSet('FullYear', true);

    function getIsLeapYear() {
        return isLeapYear(this.year());
    }

    function makeGetSet(unit, keepTime) {
        return function(value) {
            if (value != null) {
                set$1(this, unit, value);
                hooks.updateOffset(this, keepTime);
                return this;
            } else {
                return get(this, unit);
            }
        }
        ;
    }

    function get(mom, unit) {
        return mom.isValid() ? mom._d['get' + (mom._isUTC ? 'UTC' : '') + unit]() : NaN;
    }

    function set$1(mom, unit, value) {
        if (mom.isValid() && !isNaN(value)) {
            if (unit === 'FullYear' && isLeapYear(mom.year()) && mom.month() === 1 && mom.date() === 29) {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value, mom.month(), daysInMonth(value, mom.month()));
            } else {
                mom._d['set' + (mom._isUTC ? 'UTC' : '') + unit](value);
            }
        }
    }

    // MOMENTS

    function stringGet(units) {
        units = normalizeUnits(units);
        if (isFunction(this[units])) {
            return this[units]();
        }
        return this;
    }

    function stringSet(units, value) {
        if (typeof units === 'object') {
            units = normalizeObjectUnits(units);
            var prioritized = getPrioritizedUnits(units);
            for (var i = 0; i < prioritized.length; i++) {
                this[prioritized[i].unit](units[prioritized[i].unit]);
            }
        } else {
            units = normalizeUnits(units);
            if (isFunction(this[units])) {
                return this[units](value);
            }
        }
        return this;
    }

    function mod(n, x) {
        return ((n % x) + x) % x;
    }

    var indexOf;

    if (Array.prototype.indexOf) {
        indexOf = Array.prototype.indexOf;
    } else {
        indexOf = function(o) {
            // I know
            var i;
            for (i = 0; i < this.length; ++i) {
                if (this[i] === o) {
                    return i;
                }
            }
            return -1;
        }
        ;
    }

    function daysInMonth(year, month) {
        if (isNaN(year) || isNaN(month)) {
            return NaN;
        }
        var modMonth = mod(month, 12);
        year += (month - modMonth) / 12;
        return modMonth === 1 ? (isLeapYear(year) ? 29 : 28) : (31 - modMonth % 7 % 2);
    }

    // FORMATTING

    addFormatToken('M', ['MM', 2], 'Mo', function() {
        return this.month() + 1;
    });

    addFormatToken('MMM', 0, 0, function(format) {
        return this.localeData().monthsShort(this, format);
    });

    addFormatToken('MMMM', 0, 0, function(format) {
        return this.localeData().months(this, format);
    });

    // ALIASES

    addUnitAlias('month', 'M');

    // PRIORITY

    addUnitPriority('month', 8);

    // PARSING

    addRegexToken('M', match1to2);
    addRegexToken('MM', match1to2, match2);
    addRegexToken('MMM', function(isStrict, locale) {
        return locale.monthsShortRegex(isStrict);
    });
    addRegexToken('MMMM', function(isStrict, locale) {
        return locale.monthsRegex(isStrict);
    });

    addParseToken(['M', 'MM'], function(input, array) {
        array[MONTH] = toInt(input) - 1;
    });

    addParseToken(['MMM', 'MMMM'], function(input, array, config, token) {
        var month = config._locale.monthsParse(input, token, config._strict);
        // if we didn't find a month name, mark the date as invalid.
        if (month != null) {
            array[MONTH] = month;
        } else {
            getParsingFlags(config).invalidMonth = input;
        }
    });

    // LOCALES

    var MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/;
    var defaultLocaleMonths = 'January_February_March_April_May_June_July_August_September_October_November_December'.split('_');
    function localeMonths(m, format) {
        if (!m) {
            return isArray(this._months) ? this._months : this._months['standalone'];
        }
        return isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? 'format' : 'standalone'][m.month()];
    }

    var defaultLocaleMonthsShort = 'Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec'.split('_');
    function localeMonthsShort(m, format) {
        if (!m) {
            return isArray(this._monthsShort) ? this._monthsShort : this._monthsShort['standalone'];
        }
        return isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? 'format' : 'standalone'][m.month()];
    }

    function handleStrictParse(monthName, format, strict) {
        var i, ii, mom, llc = monthName.toLocaleLowerCase();
        if (!this._monthsParse) {
            // this is not used
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
            for (i = 0; i < 12; ++i) {
                mom = createUTC([2000, i]);
                this._shortMonthsParse[i] = this.monthsShort(mom, '').toLocaleLowerCase();
                this._longMonthsParse[i] = this.months(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'MMM') {
                ii = indexOf.call(this._shortMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._longMonthsParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._longMonthsParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortMonthsParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeMonthsParse(monthName, format, strict) {
        var i, mom, regex;

        if (this._monthsParseExact) {
            return handleStrictParse.call(this, monthName, format, strict);
        }

        if (!this._monthsParse) {
            this._monthsParse = [];
            this._longMonthsParse = [];
            this._shortMonthsParse = [];
        }

        // TODO: add sorting
        // Sorting makes sure if one month (or abbr) is a prefix of another
        // see sorting in computeMonthsParse
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            if (strict && !this._longMonthsParse[i]) {
                this._longMonthsParse[i] = new RegExp('^' + this.months(mom, '').replace('.', '') + '$','i');
                this._shortMonthsParse[i] = new RegExp('^' + this.monthsShort(mom, '').replace('.', '') + '$','i');
            }
            if (!strict && !this._monthsParse[i]) {
                regex = '^' + this.months(mom, '') + '|^' + this.monthsShort(mom, '');
                this._monthsParse[i] = new RegExp(regex.replace('.', ''),'i');
            }
            // test the regex
            if (strict && format === 'MMMM' && this._longMonthsParse[i].test(monthName)) {
                return i;
            } else if (strict && format === 'MMM' && this._shortMonthsParse[i].test(monthName)) {
                return i;
            } else if (!strict && this._monthsParse[i].test(monthName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function setMonth(mom, value) {
        var dayOfMonth;

        if (!mom.isValid()) {
            // No op
            return mom;
        }

        if (typeof value === 'string') {
            if (/^\d+$/.test(value)) {
                value = toInt(value);
            } else {
                value = mom.localeData().monthsParse(value);
                // TODO: Another silent failure?
                if (!isNumber(value)) {
                    return mom;
                }
            }
        }

        dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value));
        mom._d['set' + (mom._isUTC ? 'UTC' : '') + 'Month'](value, dayOfMonth);
        return mom;
    }

    function getSetMonth(value) {
        if (value != null) {
            setMonth(this, value);
            hooks.updateOffset(this, true);
            return this;
        } else {
            return get(this, 'Month');
        }
    }

    function getDaysInMonth() {
        return daysInMonth(this.year(), this.month());
    }

    var defaultMonthsShortRegex = matchWord;
    function monthsShortRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsShortStrictRegex;
            } else {
                return this._monthsShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsShortRegex')) {
                this._monthsShortRegex = defaultMonthsShortRegex;
            }
            return this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex;
        }
    }

    var defaultMonthsRegex = matchWord;
    function monthsRegex(isStrict) {
        if (this._monthsParseExact) {
            if (!hasOwnProp(this, '_monthsRegex')) {
                computeMonthsParse.call(this);
            }
            if (isStrict) {
                return this._monthsStrictRegex;
            } else {
                return this._monthsRegex;
            }
        } else {
            if (!hasOwnProp(this, '_monthsRegex')) {
                this._monthsRegex = defaultMonthsRegex;
            }
            return this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex;
        }
    }

    function computeMonthsParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var shortPieces = [], longPieces = [], mixedPieces = [], i, mom;
        for (i = 0; i < 12; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, i]);
            shortPieces.push(this.monthsShort(mom, ''));
            longPieces.push(this.months(mom, ''));
            mixedPieces.push(this.months(mom, ''));
            mixedPieces.push(this.monthsShort(mom, ''));
        }
        // Sorting makes sure if one month (or abbr) is a prefix of another it
        // will match the longer piece.
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 12; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
        }
        for (i = 0; i < 24; i++) {
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._monthsRegex = new RegExp('^(' + mixedPieces.join('|') + ')','i');
        this._monthsShortRegex = this._monthsRegex;
        this._monthsStrictRegex = new RegExp('^(' + longPieces.join('|') + ')','i');
        this._monthsShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')','i');
    }

    function createDate(y, m, d, h, M, s, ms) {
        // can't just apply() to create a date:
        // https://stackoverflow.com/q/181348
        var date = new Date(y,m,d,h,M,s,ms);

        // the date constructor remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getFullYear())) {
            date.setFullYear(y);
        }
        return date;
    }

    function createUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));

        // the Date.UTC function remaps years 0-99 to 1900-1999
        if (y < 100 && y >= 0 && isFinite(date.getUTCFullYear())) {
            date.setUTCFullYear(y);
        }
        return date;
    }

    // start-of-first-week - start-of-year
    function firstWeekOffset(year, dow, doy) {
        var // first-week day -- which january is always in the first week (4 for iso, 1 for other)
        fwd = 7 + dow - doy
          , // first-week day local weekday -- which local weekday is fwd
        fwdlw = (7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7;

        return -fwdlw + fwd - 1;
    }

    // https://en.wikipedia.org/wiki/ISO_week_date#Calculating_a_date_given_the_year.2C_week_number_and_weekday
    function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
        var localWeekday = (7 + weekday - dow) % 7, weekOffset = firstWeekOffset(year, dow, doy), dayOfYear = 1 + 7 * (week - 1) + localWeekday + weekOffset, resYear, resDayOfYear;

        if (dayOfYear <= 0) {
            resYear = year - 1;
            resDayOfYear = daysInYear(resYear) + dayOfYear;
        } else if (dayOfYear > daysInYear(year)) {
            resYear = year + 1;
            resDayOfYear = dayOfYear - daysInYear(year);
        } else {
            resYear = year;
            resDayOfYear = dayOfYear;
        }

        return {
            year: resYear,
            dayOfYear: resDayOfYear
        };
    }

    function weekOfYear(mom, dow, doy) {
        var weekOffset = firstWeekOffset(mom.year(), dow, doy), week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1, resWeek, resYear;

        if (week < 1) {
            resYear = mom.year() - 1;
            resWeek = week + weeksInYear(resYear, dow, doy);
        } else if (week > weeksInYear(mom.year(), dow, doy)) {
            resWeek = week - weeksInYear(mom.year(), dow, doy);
            resYear = mom.year() + 1;
        } else {
            resYear = mom.year();
            resWeek = week;
        }

        return {
            week: resWeek,
            year: resYear
        };
    }

    function weeksInYear(year, dow, doy) {
        var weekOffset = firstWeekOffset(year, dow, doy)
          , weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
        return (daysInYear(year) - weekOffset + weekOffsetNext) / 7;
    }

    // FORMATTING

    addFormatToken('w', ['ww', 2], 'wo', 'week');
    addFormatToken('W', ['WW', 2], 'Wo', 'isoWeek');

    // ALIASES

    addUnitAlias('week', 'w');
    addUnitAlias('isoWeek', 'W');

    // PRIORITIES

    addUnitPriority('week', 5);
    addUnitPriority('isoWeek', 5);

    // PARSING

    addRegexToken('w', match1to2);
    addRegexToken('ww', match1to2, match2);
    addRegexToken('W', match1to2);
    addRegexToken('WW', match1to2, match2);

    addWeekParseToken(['w', 'ww', 'W', 'WW'], function(input, week, config, token) {
        week[token.substr(0, 1)] = toInt(input);
    });

    // HELPERS

    // LOCALES

    function localeWeek(mom) {
        return weekOfYear(mom, this._week.dow, this._week.doy).week;
    }

    var defaultLocaleWeek = {
        dow: 0,
        // Sunday is the first day of the week.
        doy: 6 // The week that contains Jan 1st is the first week of the year.
    };

    function localeFirstDayOfWeek() {
        return this._week.dow;
    }

    function localeFirstDayOfYear() {
        return this._week.doy;
    }

    // MOMENTS

    function getSetWeek(input) {
        var week = this.localeData().week(this);
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    function getSetISOWeek(input) {
        var week = weekOfYear(this, 1, 4).week;
        return input == null ? week : this.add((input - week) * 7, 'd');
    }

    // FORMATTING

    addFormatToken('d', 0, 'do', 'day');

    addFormatToken('dd', 0, 0, function(format) {
        return this.localeData().weekdaysMin(this, format);
    });

    addFormatToken('ddd', 0, 0, function(format) {
        return this.localeData().weekdaysShort(this, format);
    });

    addFormatToken('dddd', 0, 0, function(format) {
        return this.localeData().weekdays(this, format);
    });

    addFormatToken('e', 0, 0, 'weekday');
    addFormatToken('E', 0, 0, 'isoWeekday');

    // ALIASES

    addUnitAlias('day', 'd');
    addUnitAlias('weekday', 'e');
    addUnitAlias('isoWeekday', 'E');

    // PRIORITY
    addUnitPriority('day', 11);
    addUnitPriority('weekday', 11);
    addUnitPriority('isoWeekday', 11);

    // PARSING

    addRegexToken('d', match1to2);
    addRegexToken('e', match1to2);
    addRegexToken('E', match1to2);
    addRegexToken('dd', function(isStrict, locale) {
        return locale.weekdaysMinRegex(isStrict);
    });
    addRegexToken('ddd', function(isStrict, locale) {
        return locale.weekdaysShortRegex(isStrict);
    });
    addRegexToken('dddd', function(isStrict, locale) {
        return locale.weekdaysRegex(isStrict);
    });

    addWeekParseToken(['dd', 'ddd', 'dddd'], function(input, week, config, token) {
        var weekday = config._locale.weekdaysParse(input, token, config._strict);
        // if we didn't get a weekday name, mark the date as invalid
        if (weekday != null) {
            week.d = weekday;
        } else {
            getParsingFlags(config).invalidWeekday = input;
        }
    });

    addWeekParseToken(['d', 'e', 'E'], function(input, week, config, token) {
        week[token] = toInt(input);
    });

    // HELPERS

    function parseWeekday(input, locale) {
        if (typeof input !== 'string') {
            return input;
        }

        if (!isNaN(input)) {
            return parseInt(input, 10);
        }

        input = locale.weekdaysParse(input);
        if (typeof input === 'number') {
            return input;
        }

        return null;
    }

    function parseIsoWeekday(input, locale) {
        if (typeof input === 'string') {
            return locale.weekdaysParse(input) % 7 || 7;
        }
        return isNaN(input) ? null : input;
    }

    // LOCALES

    var defaultLocaleWeekdays = 'Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday'.split('_');
    function localeWeekdays(m, format) {
        if (!m) {
            return isArray(this._weekdays) ? this._weekdays : this._weekdays['standalone'];
        }
        return isArray(this._weekdays) ? this._weekdays[m.day()] : this._weekdays[this._weekdays.isFormat.test(format) ? 'format' : 'standalone'][m.day()];
    }

    var defaultLocaleWeekdaysShort = 'Sun_Mon_Tue_Wed_Thu_Fri_Sat'.split('_');
    function localeWeekdaysShort(m) {
        return (m) ? this._weekdaysShort[m.day()] : this._weekdaysShort;
    }

    var defaultLocaleWeekdaysMin = 'Su_Mo_Tu_We_Th_Fr_Sa'.split('_');
    function localeWeekdaysMin(m) {
        return (m) ? this._weekdaysMin[m.day()] : this._weekdaysMin;
    }

    function handleStrictParse$1(weekdayName, format, strict) {
        var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._minWeekdaysParse = [];

            for (i = 0; i < 7; ++i) {
                mom = createUTC([2000, 1]).day(i);
                this._minWeekdaysParse[i] = this.weekdaysMin(mom, '').toLocaleLowerCase();
                this._shortWeekdaysParse[i] = this.weekdaysShort(mom, '').toLocaleLowerCase();
                this._weekdaysParse[i] = this.weekdays(mom, '').toLocaleLowerCase();
            }
        }

        if (strict) {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        } else {
            if (format === 'dddd') {
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else if (format === 'ddd') {
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._minWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            } else {
                ii = indexOf.call(this._minWeekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._weekdaysParse, llc);
                if (ii !== -1) {
                    return ii;
                }
                ii = indexOf.call(this._shortWeekdaysParse, llc);
                return ii !== -1 ? ii : null;
            }
        }
    }

    function localeWeekdaysParse(weekdayName, format, strict) {
        var i, mom, regex;

        if (this._weekdaysParseExact) {
            return handleStrictParse$1.call(this, weekdayName, format, strict);
        }

        if (!this._weekdaysParse) {
            this._weekdaysParse = [];
            this._minWeekdaysParse = [];
            this._shortWeekdaysParse = [];
            this._fullWeekdaysParse = [];
        }

        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already

            mom = createUTC([2000, 1]).day(i);
            if (strict && !this._fullWeekdaysParse[i]) {
                this._fullWeekdaysParse[i] = new RegExp('^' + this.weekdays(mom, '').replace('.', '\.?') + '$','i');
                this._shortWeekdaysParse[i] = new RegExp('^' + this.weekdaysShort(mom, '').replace('.', '\.?') + '$','i');
                this._minWeekdaysParse[i] = new RegExp('^' + this.weekdaysMin(mom, '').replace('.', '\.?') + '$','i');
            }
            if (!this._weekdaysParse[i]) {
                regex = '^' + this.weekdays(mom, '') + '|^' + this.weekdaysShort(mom, '') + '|^' + this.weekdaysMin(mom, '');
                this._weekdaysParse[i] = new RegExp(regex.replace('.', ''),'i');
            }
            // test the regex
            if (strict && format === 'dddd' && this._fullWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'ddd' && this._shortWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (strict && format === 'dd' && this._minWeekdaysParse[i].test(weekdayName)) {
                return i;
            } else if (!strict && this._weekdaysParse[i].test(weekdayName)) {
                return i;
            }
        }
    }

    // MOMENTS

    function getSetDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
        if (input != null) {
            input = parseWeekday(input, this.localeData());
            return this.add(input - day, 'd');
        } else {
            return day;
        }
    }

    function getSetLocaleDayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
        return input == null ? weekday : this.add(input - weekday, 'd');
    }

    function getSetISODayOfWeek(input) {
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }

        // behaves the same as moment#day except
        // as a getter, returns 7 instead of 0 (1-7 range instead of 0-6)
        // as a setter, sunday should belong to the previous week.

        if (input != null) {
            var weekday = parseIsoWeekday(input, this.localeData());
            return this.day(this.day() % 7 ? weekday : weekday - 7);
        } else {
            return this.day() || 7;
        }
    }

    var defaultWeekdaysRegex = matchWord;
    function weekdaysRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysStrictRegex;
            } else {
                return this._weekdaysRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                this._weekdaysRegex = defaultWeekdaysRegex;
            }
            return this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex;
        }
    }

    var defaultWeekdaysShortRegex = matchWord;
    function weekdaysShortRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysShortStrictRegex;
            } else {
                return this._weekdaysShortRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysShortRegex')) {
                this._weekdaysShortRegex = defaultWeekdaysShortRegex;
            }
            return this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex;
        }
    }

    var defaultWeekdaysMinRegex = matchWord;
    function weekdaysMinRegex(isStrict) {
        if (this._weekdaysParseExact) {
            if (!hasOwnProp(this, '_weekdaysRegex')) {
                computeWeekdaysParse.call(this);
            }
            if (isStrict) {
                return this._weekdaysMinStrictRegex;
            } else {
                return this._weekdaysMinRegex;
            }
        } else {
            if (!hasOwnProp(this, '_weekdaysMinRegex')) {
                this._weekdaysMinRegex = defaultWeekdaysMinRegex;
            }
            return this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex;
        }
    }

    function computeWeekdaysParse() {
        function cmpLenRev(a, b) {
            return b.length - a.length;
        }

        var minPieces = [], shortPieces = [], longPieces = [], mixedPieces = [], i, mom, minp, shortp, longp;
        for (i = 0; i < 7; i++) {
            // make the regex if we don't have it already
            mom = createUTC([2000, 1]).day(i);
            minp = this.weekdaysMin(mom, '');
            shortp = this.weekdaysShort(mom, '');
            longp = this.weekdays(mom, '');
            minPieces.push(minp);
            shortPieces.push(shortp);
            longPieces.push(longp);
            mixedPieces.push(minp);
            mixedPieces.push(shortp);
            mixedPieces.push(longp);
        }
        // Sorting makes sure if one weekday (or abbr) is a prefix of another it
        // will match the longer piece.
        minPieces.sort(cmpLenRev);
        shortPieces.sort(cmpLenRev);
        longPieces.sort(cmpLenRev);
        mixedPieces.sort(cmpLenRev);
        for (i = 0; i < 7; i++) {
            shortPieces[i] = regexEscape(shortPieces[i]);
            longPieces[i] = regexEscape(longPieces[i]);
            mixedPieces[i] = regexEscape(mixedPieces[i]);
        }

        this._weekdaysRegex = new RegExp('^(' + mixedPieces.join('|') + ')','i');
        this._weekdaysShortRegex = this._weekdaysRegex;
        this._weekdaysMinRegex = this._weekdaysRegex;

        this._weekdaysStrictRegex = new RegExp('^(' + longPieces.join('|') + ')','i');
        this._weekdaysShortStrictRegex = new RegExp('^(' + shortPieces.join('|') + ')','i');
        this._weekdaysMinStrictRegex = new RegExp('^(' + minPieces.join('|') + ')','i');
    }

    // FORMATTING

    function hFormat() {
        return this.hours() % 12 || 12;
    }

    function kFormat() {
        return this.hours() || 24;
    }

    addFormatToken('H', ['HH', 2], 0, 'hour');
    addFormatToken('h', ['hh', 2], 0, hFormat);
    addFormatToken('k', ['kk', 2], 0, kFormat);

    addFormatToken('hmm', 0, 0, function() {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2);
    });

    addFormatToken('hmmss', 0, 0, function() {
        return '' + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    addFormatToken('Hmm', 0, 0, function() {
        return '' + this.hours() + zeroFill(this.minutes(), 2);
    });

    addFormatToken('Hmmss', 0, 0, function() {
        return '' + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2);
    });

    function meridiem(token, lowercase) {
        addFormatToken(token, 0, 0, function() {
            return this.localeData().meridiem(this.hours(), this.minutes(), lowercase);
        });
    }

    meridiem('a', true);
    meridiem('A', false);

    // ALIASES

    addUnitAlias('hour', 'h');

    // PRIORITY
    addUnitPriority('hour', 13);

    // PARSING

    function matchMeridiem(isStrict, locale) {
        return locale._meridiemParse;
    }

    addRegexToken('a', matchMeridiem);
    addRegexToken('A', matchMeridiem);
    addRegexToken('H', match1to2);
    addRegexToken('h', match1to2);
    addRegexToken('k', match1to2);
    addRegexToken('HH', match1to2, match2);
    addRegexToken('hh', match1to2, match2);
    addRegexToken('kk', match1to2, match2);

    addRegexToken('hmm', match3to4);
    addRegexToken('hmmss', match5to6);
    addRegexToken('Hmm', match3to4);
    addRegexToken('Hmmss', match5to6);

    addParseToken(['H', 'HH'], HOUR);
    addParseToken(['k', 'kk'], function(input, array, config) {
        var kInput = toInt(input);
        array[HOUR] = kInput === 24 ? 0 : kInput;
    });
    addParseToken(['a', 'A'], function(input, array, config) {
        config._isPm = config._locale.isPM(input);
        config._meridiem = input;
    });
    addParseToken(['h', 'hh'], function(input, array, config) {
        array[HOUR] = toInt(input);
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmm', function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('hmmss', function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
        getParsingFlags(config).bigHour = true;
    });
    addParseToken('Hmm', function(input, array, config) {
        var pos = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos));
        array[MINUTE] = toInt(input.substr(pos));
    });
    addParseToken('Hmmss', function(input, array, config) {
        var pos1 = input.length - 4;
        var pos2 = input.length - 2;
        array[HOUR] = toInt(input.substr(0, pos1));
        array[MINUTE] = toInt(input.substr(pos1, 2));
        array[SECOND] = toInt(input.substr(pos2));
    });

    // LOCALES

    function localeIsPM(input) {
        // IE8 Quirks Mode & IE7 Standards Mode do not allow accessing strings like arrays
        // Using charAt should be more compatible.
        return ((input + '').toLowerCase().charAt(0) === 'p');
    }

    var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i;
    function localeMeridiem(hours, minutes, isLower) {
        if (hours > 11) {
            return isLower ? 'pm' : 'PM';
        } else {
            return isLower ? 'am' : 'AM';
        }
    }

    // MOMENTS

    // Setting the hour should keep the time, because the user explicitly
    // specified which hour he wants. So trying to maintain the same hour (in
    // a new timezone) makes sense. Adding/subtracting hours does not follow
    // this rule.
    var getSetHour = makeGetSet('Hours', true);

    var baseConfig = {
        calendar: defaultCalendar,
        longDateFormat: defaultLongDateFormat,
        invalidDate: defaultInvalidDate,
        ordinal: defaultOrdinal,
        dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
        relativeTime: defaultRelativeTime,

        months: defaultLocaleMonths,
        monthsShort: defaultLocaleMonthsShort,

        week: defaultLocaleWeek,

        weekdays: defaultLocaleWeekdays,
        weekdaysMin: defaultLocaleWeekdaysMin,
        weekdaysShort: defaultLocaleWeekdaysShort,

        meridiemParse: defaultLocaleMeridiemParse
    };

    // internal storage for locale config files
    var locales = {};
    var localeFamilies = {};
    var globalLocale;

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace('_', '-') : key;
    }

    // pick the locale from the array
    // try ['en-au', 'en-gb'] as 'en-au', 'en-gb', 'en', as in move through the list trying each
    // substring from most specific to least, but move to the next array item if it's a more specific variant than the current root
    function chooseLocale(names) {
        var i = 0, j, next, locale, split;

        while (i < names.length) {
            split = normalizeLocale(names[i]).split('-');
            j = split.length;
            next = normalizeLocale(names[i + 1]);
            next = next ? next.split('-') : null;
            while (j > 0) {
                locale = loadLocale(split.slice(0, j).join('-'));
                if (locale) {
                    return locale;
                }
                if (next && next.length >= j && compareArrays(split, next, true) >= j - 1) {
                    //the next array item is better than a shallower substring of this one
                    break;
                }
                j--;
            }
            i++;
        }
        return globalLocale;
    }

    function loadLocale(name) {
        var oldLocale = null;
        // TODO: Find a better way to register and load all the locales in Node
        if (!locales[name] && (typeof module !== 'undefined') && module && module.exports) {
            try {
                oldLocale = globalLocale._abbr;
                var aliasedRequire = require;
                aliasedRequire('./locale/' + name);
                getSetGlobalLocale(oldLocale);
            } catch (e) {}
        }
        return locales[name];
    }

    // This function will load locale and then set the global locale.  If
    // no arguments are passed in, it will simply return the current global
    // locale key.
    function getSetGlobalLocale(key, values) {
        var data;
        if (key) {
            if (isUndefined(values)) {
                data = getLocale(key);
            } else {
                data = defineLocale(key, values);
            }

            if (data) {
                // moment.duration._locale = moment._locale = data;
                globalLocale = data;
            } else {
                if ((typeof console !== 'undefined') && console.warn) {
                    //warn user if arguments are passed but the locale could not be set
                    console.warn('Locale ' + key + ' not found. Did you forget to load it?');
                }
            }
        }

        return globalLocale._abbr;
    }

    function defineLocale(name, config) {
        if (config !== null) {
            var locale, parentConfig = baseConfig;
            config.abbr = name;
            if (locales[name] != null) {
                deprecateSimple('defineLocaleOverride', 'use moment.updateLocale(localeName, config) to change ' + 'an existing locale. moment.defineLocale(localeName, ' + 'config) should only be used for creating a new locale ' + 'See http://momentjs.com/guides/#/warnings/define-locale/ for more info.');
                parentConfig = locales[name]._config;
            } else if (config.parentLocale != null) {
                if (locales[config.parentLocale] != null) {
                    parentConfig = locales[config.parentLocale]._config;
                } else {
                    locale = loadLocale(config.parentLocale);
                    if (locale != null) {
                        parentConfig = locale._config;
                    } else {
                        if (!localeFamilies[config.parentLocale]) {
                            localeFamilies[config.parentLocale] = [];
                        }
                        localeFamilies[config.parentLocale].push({
                            name: name,
                            config: config
                        });
                        return null;
                    }
                }
            }
            locales[name] = new Locale(mergeConfigs(parentConfig, config));

            if (localeFamilies[name]) {
                localeFamilies[name].forEach(function(x) {
                    defineLocale(x.name, x.config);
                });
            }

            // backwards compat for now: also set the locale
            // make sure we set the locale AFTER all child locales have been
            // created, so we won't end up with the child locale set.
            getSetGlobalLocale(name);

            return locales[name];
        } else {
            // useful for testing
            delete locales[name];
            return null;
        }
    }

    function updateLocale(name, config) {
        if (config != null) {
            var locale, tmpLocale, parentConfig = baseConfig;
            // MERGE
            tmpLocale = loadLocale(name);
            if (tmpLocale != null) {
                parentConfig = tmpLocale._config;
            }
            config = mergeConfigs(parentConfig, config);
            locale = new Locale(config);
            locale.parentLocale = locales[name];
            locales[name] = locale;

            // backwards compat for now: also set the locale
            getSetGlobalLocale(name);
        } else {
            // pass null for config to unupdate, useful for tests
            if (locales[name] != null) {
                if (locales[name].parentLocale != null) {
                    locales[name] = locales[name].parentLocale;
                } else if (locales[name] != null) {
                    delete locales[name];
                }
            }
        }
        return locales[name];
    }

    // returns locale data
    function getLocale(key) {
        var locale;

        if (key && key._locale && key._locale._abbr) {
            key = key._locale._abbr;
        }

        if (!key) {
            return globalLocale;
        }

        if (!isArray(key)) {
            //short-circuit everything else
            locale = loadLocale(key);
            if (locale) {
                return locale;
            }
            key = [key];
        }

        return chooseLocale(key);
    }

    function listLocales() {
        return keys(locales);
    }

    function checkOverflow(m) {
        var overflow;
        var a = m._a;

        if (a && getParsingFlags(m).overflow === -2) {
            overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || (a[HOUR] === 24 && (a[MINUTE] !== 0 || a[SECOND] !== 0 || a[MILLISECOND] !== 0)) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1;

            if (getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE)) {
                overflow = DATE;
            }
            if (getParsingFlags(m)._overflowWeeks && overflow === -1) {
                overflow = WEEK;
            }
            if (getParsingFlags(m)._overflowWeekday && overflow === -1) {
                overflow = WEEKDAY;
            }

            getParsingFlags(m).overflow = overflow;
        }

        return m;
    }

    // Pick the first defined of two or three arguments.
    function defaults(a, b, c) {
        if (a != null) {
            return a;
        }
        if (b != null) {
            return b;
        }
        return c;
    }

    function currentDateArray(config) {
        // hooks is actually the exported moment object
        var nowValue = new Date(hooks.now());
        if (config._useUTC) {
            return [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()];
        }
        return [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()];
    }

    // convert an array to a date.
    // the array should mirror the parameters below
    // note: all values past the year are optional and will default to the lowest possible value.
    // [year, month, day , hour, minute, second, millisecond]
    function configFromArray(config) {
        var i, date, input = [], currentDate, expectedWeekday, yearToUse;

        if (config._d) {
            return;
        }

        currentDate = currentDateArray(config);

        //compute day of the year from weeks and weekdays
        if (config._w && config._a[DATE] == null && config._a[MONTH] == null) {
            dayOfYearFromWeekInfo(config);
        }

        //if the day of the year is set, figure out what it is
        if (config._dayOfYear != null) {
            yearToUse = defaults(config._a[YEAR], currentDate[YEAR]);

            if (config._dayOfYear > daysInYear(yearToUse) || config._dayOfYear === 0) {
                getParsingFlags(config)._overflowDayOfYear = true;
            }

            date = createUTCDate(yearToUse, 0, config._dayOfYear);
            config._a[MONTH] = date.getUTCMonth();
            config._a[DATE] = date.getUTCDate();
        }

        // Default to current date.
        // * if no year, month, day of month are given, default to today
        // * if day of month is given, default month and year
        // * if month is given, default only year
        // * if year is given, don't default anything
        for (i = 0; i < 3 && config._a[i] == null; ++i) {
            config._a[i] = input[i] = currentDate[i];
        }

        // Zero out whatever was not defaulted, including time
        for (; i < 7; i++) {
            config._a[i] = input[i] = (config._a[i] == null) ? (i === 2 ? 1 : 0) : config._a[i];
        }

        // Check for 24:00:00.000
        if (config._a[HOUR] === 24 && config._a[MINUTE] === 0 && config._a[SECOND] === 0 && config._a[MILLISECOND] === 0) {
            config._nextDay = true;
            config._a[HOUR] = 0;
        }

        config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input);
        expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay();

        // Apply timezone offset from input. The actual utcOffset can be changed
        // with parseZone.
        if (config._tzm != null) {
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);
        }

        if (config._nextDay) {
            config._a[HOUR] = 24;
        }

        // check for mismatching day of week
        if (config._w && typeof config._w.d !== 'undefined' && config._w.d !== expectedWeekday) {
            getParsingFlags(config).weekdayMismatch = true;
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow;

        w = config._w;
        if (w.GG != null || w.W != null || w.E != null) {
            dow = 1;
            doy = 4;

            // TODO: We need to take the current isoWeekYear, but that depends on
            // how we interpret now (local, utc, fixed offset). So create
            // a now version of current config (take local/utc/offset flags, and
            // create now).
            weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year);
            week = defaults(w.W, 1);
            weekday = defaults(w.E, 1);
            if (weekday < 1 || weekday > 7) {
                weekdayOverflow = true;
            }
        } else {
            dow = config._locale._week.dow;
            doy = config._locale._week.doy;

            var curWeek = weekOfYear(createLocal(), dow, doy);

            weekYear = defaults(w.gg, config._a[YEAR], curWeek.year);

            // Default to current week.
            week = defaults(w.w, curWeek.week);

            if (w.d != null) {
                // weekday -- low day numbers are considered next week
                weekday = w.d;
                if (weekday < 0 || weekday > 6) {
                    weekdayOverflow = true;
                }
            } else if (w.e != null) {
                // local weekday -- counting starts from begining of week
                weekday = w.e + dow;
                if (w.e < 0 || w.e > 6) {
                    weekdayOverflow = true;
                }
            } else {
                // default to begining of week
                weekday = dow;
            }
        }
        if (week < 1 || week > weeksInYear(weekYear, dow, doy)) {
            getParsingFlags(config)._overflowWeeks = true;
        } else if (weekdayOverflow != null) {
            getParsingFlags(config)._overflowWeekday = true;
        } else {
            temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy);
            config._a[YEAR] = temp.year;
            config._dayOfYear = temp.dayOfYear;
        }
    }

    // iso 8601 regex
    // 0000-00-00 0000-W00 or 0000-W00-0 + T + 00 or 00:00 or 00:00:00 or 00:00:00.000 + +00:00 or +0000 or +00)
    var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;
    var basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/;

    var tzRegex = /Z|[+-]\d\d(?::?\d\d)?/;

    var isoDates = [['YYYYYY-MM-DD', /[+-]\d{6}-\d\d-\d\d/], ['YYYY-MM-DD', /\d{4}-\d\d-\d\d/], ['GGGG-[W]WW-E', /\d{4}-W\d\d-\d/], ['GGGG-[W]WW', /\d{4}-W\d\d/, false], ['YYYY-DDD', /\d{4}-\d{3}/], ['YYYY-MM', /\d{4}-\d\d/, false], ['YYYYYYMMDD', /[+-]\d{10}/], ['YYYYMMDD', /\d{8}/], // YYYYMM is NOT allowed by the standard
    ['GGGG[W]WWE', /\d{4}W\d{3}/], ['GGGG[W]WW', /\d{4}W\d{2}/, false], ['YYYYDDD', /\d{7}/]];

    // iso time formats and regexes
    var isoTimes = [['HH:mm:ss.SSSS', /\d\d:\d\d:\d\d\.\d+/], ['HH:mm:ss,SSSS', /\d\d:\d\d:\d\d,\d+/], ['HH:mm:ss', /\d\d:\d\d:\d\d/], ['HH:mm', /\d\d:\d\d/], ['HHmmss.SSSS', /\d\d\d\d\d\d\.\d+/], ['HHmmss,SSSS', /\d\d\d\d\d\d,\d+/], ['HHmmss', /\d\d\d\d\d\d/], ['HHmm', /\d\d\d\d/], ['HH', /\d\d/]];

    var aspNetJsonRegex = /^\/?Date\((\-?\d+)/i;

    // date from iso format
    function configFromISO(config) {
        var i, l, string = config._i, match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string), allowTime, dateFormat, timeFormat, tzFormat;

        if (match) {
            getParsingFlags(config).iso = true;

            for (i = 0,
            l = isoDates.length; i < l; i++) {
                if (isoDates[i][1].exec(match[1])) {
                    dateFormat = isoDates[i][0];
                    allowTime = isoDates[i][2] !== false;
                    break;
                }
            }
            if (dateFormat == null) {
                config._isValid = false;
                return;
            }
            if (match[3]) {
                for (i = 0,
                l = isoTimes.length; i < l; i++) {
                    if (isoTimes[i][1].exec(match[3])) {
                        // match[2] should be 'T' or space
                        timeFormat = (match[2] || ' ') + isoTimes[i][0];
                        break;
                    }
                }
                if (timeFormat == null) {
                    config._isValid = false;
                    return;
                }
            }
            if (!allowTime && timeFormat != null) {
                config._isValid = false;
                return;
            }
            if (match[4]) {
                if (tzRegex.exec(match[4])) {
                    tzFormat = 'Z';
                } else {
                    config._isValid = false;
                    return;
                }
            }
            config._f = dateFormat + (timeFormat || '') + (tzFormat || '');
            configFromStringAndFormat(config);
        } else {
            config._isValid = false;
        }
    }

    // RFC 2822 regex: For details see https://tools.ietf.org/html/rfc2822#section-3.3
    var rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/;

    function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
        var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];

        if (secondStr) {
            result.push(parseInt(secondStr, 10));
        }

        return result;
    }

    function untruncateYear(yearStr) {
        var year = parseInt(yearStr, 10);
        if (year <= 49) {
            return 2000 + year;
        } else if (year <= 999) {
            return 1900 + year;
        }
        return year;
    }

    function preprocessRFC2822(s) {
        // Remove comments and folding whitespace and replace multiple-spaces with a single space
        return s.replace(/\([^)]*\)|[\n\t]/g, ' ').replace(/(\s\s+)/g, ' ').trim();
    }

    function checkWeekday(weekdayStr, parsedInput, config) {
        if (weekdayStr) {
            // TODO: Replace the vanilla JS Date object with an indepentent day-of-week check.
            var weekdayProvided = defaultLocaleWeekdaysShort.indexOf(weekdayStr)
              , weekdayActual = new Date(parsedInput[0],parsedInput[1],parsedInput[2]).getDay();
            if (weekdayProvided !== weekdayActual) {
                getParsingFlags(config).weekdayMismatch = true;
                config._isValid = false;
                return false;
            }
        }
        return true;
    }

    var obsOffsets = {
        UT: 0,
        GMT: 0,
        EDT: -4 * 60,
        EST: -5 * 60,
        CDT: -5 * 60,
        CST: -6 * 60,
        MDT: -6 * 60,
        MST: -7 * 60,
        PDT: -7 * 60,
        PST: -8 * 60
    };

    function calculateOffset(obsOffset, militaryOffset, numOffset) {
        if (obsOffset) {
            return obsOffsets[obsOffset];
        } else if (militaryOffset) {
            // the only allowed military tz is Z
            return 0;
        } else {
            var hm = parseInt(numOffset, 10);
            var m = hm % 100
              , h = (hm - m) / 100;
            return h * 60 + m;
        }
    }

    // date and time from ref 2822 format
    function configFromRFC2822(config) {
        var match = rfc2822.exec(preprocessRFC2822(config._i));
        if (match) {
            var parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]);
            if (!checkWeekday(match[1], parsedArray, config)) {
                return;
            }

            config._a = parsedArray;
            config._tzm = calculateOffset(match[8], match[9], match[10]);

            config._d = createUTCDate.apply(null, config._a);
            config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm);

            getParsingFlags(config).rfc2822 = true;
        } else {
            config._isValid = false;
        }
    }

    // date from iso format or fallback
    function configFromString(config) {
        var matched = aspNetJsonRegex.exec(config._i);

        if (matched !== null) {
            config._d = new Date(+matched[1]);
            return;
        }

        configFromISO(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        configFromRFC2822(config);
        if (config._isValid === false) {
            delete config._isValid;
        } else {
            return;
        }

        // Final attempt, use Input Fallback
        hooks.createFromInputFallback(config);
    }

    hooks.createFromInputFallback = deprecate('value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), ' + 'which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are ' + 'discouraged and will be removed in an upcoming major release. Please refer to ' + 'http://momentjs.com/guides/#/warnings/js-date/ for more info.', function(config) {
        config._d = new Date(config._i + (config._useUTC ? ' UTC' : ''));
    });

    // constant that refers to the ISO standard
    hooks.ISO_8601 = function() {}
    ;

    // constant that refers to the RFC 2822 form
    hooks.RFC_2822 = function() {}
    ;

    // date from string and format string
    function configFromStringAndFormat(config) {
        // TODO: Move this to another part of the creation flow to prevent circular deps
        if (config._f === hooks.ISO_8601) {
            configFromISO(config);
            return;
        }
        if (config._f === hooks.RFC_2822) {
            configFromRFC2822(config);
            return;
        }
        config._a = [];
        getParsingFlags(config).empty = true;

        // This array is used to make a Date, either with `new Date` or `Date.UTC`
        var string = '' + config._i, i, parsedInput, tokens, token, skipped, stringLength = string.length, totalParsedInputLength = 0;

        tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [];

        for (i = 0; i < tokens.length; i++) {
            token = tokens[i];
            parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0];
            // console.log('token', token, 'parsedInput', parsedInput,
            //         'regex', getParseRegexForToken(token, config));
            if (parsedInput) {
                skipped = string.substr(0, string.indexOf(parsedInput));
                if (skipped.length > 0) {
                    getParsingFlags(config).unusedInput.push(skipped);
                }
                string = string.slice(string.indexOf(parsedInput) + parsedInput.length);
                totalParsedInputLength += parsedInput.length;
            }
            // don't parse if it's not a known token
            if (formatTokenFunctions[token]) {
                if (parsedInput) {
                    getParsingFlags(config).empty = false;
                } else {
                    getParsingFlags(config).unusedTokens.push(token);
                }
                addTimeToArrayFromToken(token, parsedInput, config);
            } else if (config._strict && !parsedInput) {
                getParsingFlags(config).unusedTokens.push(token);
            }
        }

        // add remaining unparsed input length to the string
        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength;
        if (string.length > 0) {
            getParsingFlags(config).unusedInput.push(string);
        }

        // clear _12h flag if hour is <= 12
        if (config._a[HOUR] <= 12 && getParsingFlags(config).bigHour === true && config._a[HOUR] > 0) {
            getParsingFlags(config).bigHour = undefined;
        }

        getParsingFlags(config).parsedDateParts = config._a.slice(0);
        getParsingFlags(config).meridiem = config._meridiem;
        // handle meridiem
        config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem);

        configFromArray(config);
        checkOverflow(config);
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;

        if (meridiem == null) {
            // nothing to do
            return hour;
        }
        if (locale.meridiemHour != null) {
            return locale.meridiemHour(hour, meridiem);
        } else if (locale.isPM != null) {
            // Fallback
            isPm = locale.isPM(meridiem);
            if (isPm && hour < 12) {
                hour += 12;
            }
            if (!isPm && hour === 12) {
                hour = 0;
            }
            return hour;
        } else {
            // this is not supposed to happen
            return hour;
        }
    }

    // date from string and array of format strings
    function configFromStringAndArray(config) {
        var tempConfig, bestMoment,
        scoreToBeat, i, currentScore;

        if (config._f.length === 0) {
            getParsingFlags(config).invalidFormat = true;
            config._d = new Date(NaN);
            return;
        }

        for (i = 0; i < config._f.length; i++) {
            currentScore = 0;
            tempConfig = copyConfig({}, config);
            if (config._useUTC != null) {
                tempConfig._useUTC = config._useUTC;
            }
            tempConfig._f = config._f[i];
            configFromStringAndFormat(tempConfig);

            if (!isValid(tempConfig)) {
                continue;
            }

            // if there is any input that was not parsed add a penalty for that format
            currentScore += getParsingFlags(tempConfig).charsLeftOver;

            //or tokens
            currentScore += getParsingFlags(tempConfig).unusedTokens.length * 10;

            getParsingFlags(tempConfig).score = currentScore;

            if (scoreToBeat == null || currentScore < scoreToBeat) {
                scoreToBeat = currentScore;
                bestMoment = tempConfig;
            }
        }

        extend(config, bestMoment || tempConfig);
    }

    function configFromObject(config) {
        if (config._d) {
            return;
        }

        var i = normalizeObjectUnits(config._i);
        config._a = map([i.year, i.month, i.day || i.date, i.hour, i.minute, i.second, i.millisecond], function(obj) {
            return obj && parseInt(obj, 10);
        });

        configFromArray(config);
    }

    function createFromConfig(config) {
        var res = new Moment(checkOverflow(prepareConfig(config)));
        if (res._nextDay) {
            // Adding is smart enough around DST
            res.add(1, 'd');
            res._nextDay = undefined;
        }

        return res;
    }

    function prepareConfig(config) {
        var input = config._i
          , format = config._f;

        config._locale = config._locale || getLocale(config._l);

        if (input === null || (format === undefined && input === '')) {
            return createInvalid({
                nullInput: true
            });
        }

        if (typeof input === 'string') {
            config._i = input = config._locale.preparse(input);
        }

        if (isMoment(input)) {
            return new Moment(checkOverflow(input));
        } else if (isDate(input)) {
            config._d = input;
        } else if (isArray(format)) {
            configFromStringAndArray(config);
        } else if (format) {
            configFromStringAndFormat(config);
        } else {
            configFromInput(config);
        }

        if (!isValid(config)) {
            config._d = null;
        }

        return config;
    }

    function configFromInput(config) {
        var input = config._i;
        if (isUndefined(input)) {
            config._d = new Date(hooks.now());
        } else if (isDate(input)) {
            config._d = new Date(input.valueOf());
        } else if (typeof input === 'string') {
            configFromString(config);
        } else if (isArray(input)) {
            config._a = map(input.slice(0), function(obj) {
                return parseInt(obj, 10);
            });
            configFromArray(config);
        } else if (isObject(input)) {
            configFromObject(config);
        } else if (isNumber(input)) {
            // from milliseconds
            config._d = new Date(input);
        } else {
            hooks.createFromInputFallback(config);
        }
    }

    function createLocalOrUTC(input, format, locale, strict, isUTC) {
        var c = {};

        if (locale === true || locale === false) {
            strict = locale;
            locale = undefined;
        }

        if ((isObject(input) && isObjectEmpty(input)) || (isArray(input) && input.length === 0)) {
            input = undefined;
        }
        // object construction must be done this way.
        // https://github.com/moment/moment/issues/1423
        c._isAMomentObject = true;
        c._useUTC = c._isUTC = isUTC;
        c._l = locale;
        c._i = input;
        c._f = format;
        c._strict = strict;

        return createFromConfig(c);
    }

    function createLocal(input, format, locale, strict) {
        return createLocalOrUTC(input, format, locale, strict, false);
    }

    var prototypeMin = deprecate('moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/', function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other < this ? this : other;
        } else {
            return createInvalid();
        }
    });

    var prototypeMax = deprecate('moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/', function() {
        var other = createLocal.apply(null, arguments);
        if (this.isValid() && other.isValid()) {
            return other > this ? this : other;
        } else {
            return createInvalid();
        }
    });

    // Pick a moment m from moments so that m[fn](other) is true for all
    // other. This relies on the function fn to be transitive.
    //
    // moments should either be an array of moment objects or an array, whose
    // first element is an array of moment objects.
    function pickBy(fn, moments) {
        var res, i;
        if (moments.length === 1 && isArray(moments[0])) {
            moments = moments[0];
        }
        if (!moments.length) {
            return createLocal();
        }
        res = moments[0];
        for (i = 1; i < moments.length; ++i) {
            if (!moments[i].isValid() || moments[i][fn](res)) {
                res = moments[i];
            }
        }
        return res;
    }

    // TODO: Use [].sort instead?
    function min() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isBefore', args);
    }

    function max() {
        var args = [].slice.call(arguments, 0);

        return pickBy('isAfter', args);
    }

    var now = function() {
        return Date.now ? Date.now() : +(new Date());
    };

    var ordering = ['year', 'quarter', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond'];

    function isDurationValid(m) {
        for (var key in m) {
            if (!(indexOf.call(ordering, key) !== -1 && (m[key] == null || !isNaN(m[key])))) {
                return false;
            }
        }

        var unitHasDecimal = false;
        for (var i = 0; i < ordering.length; ++i) {
            if (m[ordering[i]]) {
                if (unitHasDecimal) {
                    return false;
                    // only allow non-integers for smallest unit
                }
                if (parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]])) {
                    unitHasDecimal = true;
                }
            }
        }

        return true;
    }

    function isValid$1() {
        return this._isValid;
    }

    function createInvalid$1() {
        return createDuration(NaN);
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration)
          , years = normalizedInput.year || 0
          , quarters = normalizedInput.quarter || 0
          , months = normalizedInput.month || 0
          , weeks = normalizedInput.week || 0
          , days = normalizedInput.day || 0
          , hours = normalizedInput.hour || 0
          , minutes = normalizedInput.minute || 0
          , seconds = normalizedInput.second || 0
          , milliseconds = normalizedInput.millisecond || 0;

        this._isValid = isDurationValid(normalizedInput);

        // representation for dateAddRemove
        this._milliseconds = +milliseconds + seconds * 1e3 + // 1000
        minutes * 6e4 + // 1000 * 60
        hours * 1000 * 60 * 60;
        //using 1000 * 60 * 60 instead of 36e5 to avoid floating point rounding errors https://github.com/moment/moment/issues/2978
        // Because of dateAddRemove treats 24 hours as different from a
        // day when working around DST, we need to store them separately
        this._days = +days + weeks * 7;
        // It is impossible to translate months into days without knowing
        // which months you are are talking about, so we have to store
        // it separately.
        this._months = +months + quarters * 3 + years * 12;

        this._data = {};

        this._locale = getLocale();

        this._bubble();
    }

    function isDuration(obj) {
        return obj instanceof Duration;
    }

    function absRound(number) {
        if (number < 0) {
            return Math.round(-1 * number) * -1;
        } else {
            return Math.round(number);
        }
    }

    // FORMATTING

    function offset(token, separator) {
        addFormatToken(token, 0, 0, function() {
            var offset = this.utcOffset();
            var sign = '+';
            if (offset < 0) {
                offset = -offset;
                sign = '-';
            }
            return sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~(offset) % 60, 2);
        });
    }

    offset('Z', ':');
    offset('ZZ', '');

    // PARSING

    addRegexToken('Z', matchShortOffset);
    addRegexToken('ZZ', matchShortOffset);
    addParseToken(['Z', 'ZZ'], function(input, array, config) {
        config._useUTC = true;
        config._tzm = offsetFromString(matchShortOffset, input);
    });

    // HELPERS

    // timezone chunker
    // '+10:00' > ['10',  '00']
    // '-1530'  > ['-15', '30']
    var chunkOffset = /([\+\-]|\d\d)/gi;

    function offsetFromString(matcher, string) {
        var matches = (string || '').match(matcher);

        if (matches === null) {
            return null;
        }

        var chunk = matches[matches.length - 1] || [];
        var parts = (chunk + '').match(chunkOffset) || ['-', 0, 0];
        var minutes = +(parts[1] * 60) + toInt(parts[2]);

        return minutes === 0 ? 0 : parts[0] === '+' ? minutes : -minutes;
    }

    // Return a moment from input, that is local/utc/zone equivalent to model.
    function cloneWithOffset(input, model) {
        var res, diff;
        if (model._isUTC) {
            res = model.clone();
            diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf();
            // Use low-level api, because this fn is low-level api.
            res._d.setTime(res._d.valueOf() + diff);
            hooks.updateOffset(res, false);
            return res;
        } else {
            return createLocal(input).local();
        }
    }

    function getDateOffset(m) {
        // On Firefox.24 Date#getTimezoneOffset returns a floating point.
        // https://github.com/moment/moment/pull/1871
        return -Math.round(m._d.getTimezoneOffset() / 15) * 15;
    }

    // HOOKS

    // This function will be called whenever a moment is mutated.
    // It is intended to keep the offset in sync with the timezone.
    hooks.updateOffset = function() {}
    ;

    // MOMENTS

    // keepLocalTime = true means only change the timezone, without
    // affecting the local hour. So 5:31:26 +0300 --[utcOffset(2, true)]-->
    // 5:31:26 +0200 It is possible that 5:31:26 doesn't exist with offset
    // +0200, so we adjust the time as needed, to be valid.
    //
    // Keeping the time actually adds/subtracts (one hour)
    // from the actual represented time. That is why we call updateOffset
    // a second time. In case it wants us to change the offset again
    // _changeInProgress == true case, then we have to adjust, because
    // there is no such time in the given timezone.
    function getSetOffset(input, keepLocalTime, keepMinutes) {
        var offset = this._offset || 0, localAdjust;
        if (!this.isValid()) {
            return input != null ? this : NaN;
        }
        if (input != null) {
            if (typeof input === 'string') {
                input = offsetFromString(matchShortOffset, input);
                if (input === null) {
                    return this;
                }
            } else if (Math.abs(input) < 16 && !keepMinutes) {
                input = input * 60;
            }
            if (!this._isUTC && keepLocalTime) {
                localAdjust = getDateOffset(this);
            }
            this._offset = input;
            this._isUTC = true;
            if (localAdjust != null) {
                this.add(localAdjust, 'm');
            }
            if (offset !== input) {
                if (!keepLocalTime || this._changeInProgress) {
                    addSubtract(this, createDuration(input - offset, 'm'), 1, false);
                } else if (!this._changeInProgress) {
                    this._changeInProgress = true;
                    hooks.updateOffset(this, true);
                    this._changeInProgress = null;
                }
            }
            return this;
        } else {
            return this._isUTC ? offset : getDateOffset(this);
        }
    }

    function getSetZone(input, keepLocalTime) {
        if (input != null) {
            if (typeof input !== 'string') {
                input = -input;
            }

            this.utcOffset(input, keepLocalTime);

            return this;
        } else {
            return -this.utcOffset();
        }
    }

    function setOffsetToUTC(keepLocalTime) {
        return this.utcOffset(0, keepLocalTime);
    }

    function setOffsetToLocal(keepLocalTime) {
        if (this._isUTC) {
            this.utcOffset(0, keepLocalTime);
            this._isUTC = false;

            if (keepLocalTime) {
                this.subtract(getDateOffset(this), 'm');
            }
        }
        return this;
    }

    function setOffsetToParsedOffset() {
        if (this._tzm != null) {
            this.utcOffset(this._tzm, false, true);
        } else if (typeof this._i === 'string') {
            var tZone = offsetFromString(matchOffset, this._i);
            if (tZone != null) {
                this.utcOffset(tZone);
            } else {
                this.utcOffset(0, true);
            }
        }
        return this;
    }

    function hasAlignedHourOffset(input) {
        if (!this.isValid()) {
            return false;
        }
        input = input ? createLocal(input).utcOffset() : 0;

        return (this.utcOffset() - input) % 60 === 0;
    }

    function isDaylightSavingTime() {
        return (this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset());
    }

    function isDaylightSavingTimeShifted() {
        if (!isUndefined(this._isDSTShifted)) {
            return this._isDSTShifted;
        }

        var c = {};

        copyConfig(c, this);
        c = prepareConfig(c);

        if (c._a) {
            var other = c._isUTC ? createUTC(c._a) : createLocal(c._a);
            this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0;
        } else {
            this._isDSTShifted = false;
        }

        return this._isDSTShifted;
    }

    function isLocal() {
        return this.isValid() ? !this._isUTC : false;
    }

    function isUtcOffset() {
        return this.isValid() ? this._isUTC : false;
    }

    function isUtc() {
        return this.isValid() ? this._isUTC && this._offset === 0 : false;
    }

    // ASP.NET json date format regex
    var aspNetRegex = /^(\-|\+)?(?:(\d*)[. ])?(\d+)\:(\d+)(?:\:(\d+)(\.\d*)?)?$/;

    // from http://docs.closure-library.googlecode.com/git/closure_goog_date_date.js.source.html
    // somewhat more in line with 4.4.3.2 2004 spec, but allows decimal anywhere
    // and further modified to allow for strings containing both week and day
    var isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

    function createDuration(input, key) {
        var duration = input, // matching against regexp is expensive, do it on demand
        match = null, sign, ret, diffRes;

        if (isDuration(input)) {
            duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            };
        } else if (isNumber(input)) {
            duration = {};
            if (key) {
                duration[key] = input;
            } else {
                duration.milliseconds = input;
            }
        } else if (!!(match = aspNetRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : 1;
            duration = {
                y: 0,
                d: toInt(match[DATE]) * sign,
                h: toInt(match[HOUR]) * sign,
                m: toInt(match[MINUTE]) * sign,
                s: toInt(match[SECOND]) * sign,
                ms: toInt(absRound(match[MILLISECOND] * 1000)) * sign // the millisecond decimal point is included in the match
            };
        } else if (!!(match = isoRegex.exec(input))) {
            sign = (match[1] === '-') ? -1 : (match[1] === '+') ? 1 : 1;
            duration = {
                y: parseIso(match[2], sign),
                M: parseIso(match[3], sign),
                w: parseIso(match[4], sign),
                d: parseIso(match[5], sign),
                h: parseIso(match[6], sign),
                m: parseIso(match[7], sign),
                s: parseIso(match[8], sign)
            };
        } else if (duration == null) {
            // checks for null or undefined
            duration = {};
        } else if (typeof duration === 'object' && ('from'in duration || 'to'in duration)) {
            diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to));

            duration = {};
            duration.ms = diffRes.milliseconds;
            duration.M = diffRes.months;
        }

        ret = new Duration(duration);

        if (isDuration(input) && hasOwnProp(input, '_locale')) {
            ret._locale = input._locale;
        }

        return ret;
    }

    createDuration.fn = Duration.prototype;
    createDuration.invalid = createInvalid$1;

    function parseIso(inp, sign) {
        // We'd normally use ~~inp for this, but unfortunately it also
        // converts floats to ints.
        // inp may be undefined, so careful calling replace on it.
        var res = inp && parseFloat(inp.replace(',', '.'));
        // apply sign while we're at it
        return (isNaN(res) ? 0 : res) * sign;
    }

    function positiveMomentsDifference(base, other) {
        var res = {
            milliseconds: 0,
            months: 0
        };

        res.months = other.month() - base.month() + (other.year() - base.year()) * 12;
        if (base.clone().add(res.months, 'M').isAfter(other)) {
            --res.months;
        }

        res.milliseconds = +other - +(base.clone().add(res.months, 'M'));

        return res;
    }

    function momentsDifference(base, other) {
        var res;
        if (!(base.isValid() && other.isValid())) {
            return {
                milliseconds: 0,
                months: 0
            };
        }

        other = cloneWithOffset(other, base);
        if (base.isBefore(other)) {
            res = positiveMomentsDifference(base, other);
        } else {
            res = positiveMomentsDifference(other, base);
            res.milliseconds = -res.milliseconds;
            res.months = -res.months;
        }

        return res;
    }

    // TODO: remove 'name' arg after deprecation is removed
    function createAdder(direction, name) {
        return function(val, period) {
            var dur, tmp;
            //invert the arguments, but complain about it
            if (period !== null && !isNaN(+period)) {
                deprecateSimple(name, 'moment().' + name + '(period, number) is deprecated. Please use moment().' + name + '(number, period). ' + 'See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info.');
                tmp = val;
                val = period;
                period = tmp;
            }

            val = typeof val === 'string' ? +val : val;
            dur = createDuration(val, period);
            addSubtract(this, dur, direction);
            return this;
        }
        ;
    }

    function addSubtract(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds
          , days = absRound(duration._days)
          , months = absRound(duration._months);

        if (!mom.isValid()) {
            // No op
            return;
        }

        updateOffset = updateOffset == null ? true : updateOffset;

        if (months) {
            setMonth(mom, get(mom, 'Month') + months * isAdding);
        }
        if (days) {
            set$1(mom, 'Date', get(mom, 'Date') + days * isAdding);
        }
        if (milliseconds) {
            mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding);
        }
        if (updateOffset) {
            hooks.updateOffset(mom, days || months);
        }
    }

    var add = createAdder(1, 'add');
    var subtract = createAdder(-1, 'subtract');

    function getCalendarFormat(myMoment, now) {
        var diff = myMoment.diff(now, 'days', true);
        return diff < -6 ? 'sameElse' : diff < -1 ? 'lastWeek' : diff < 0 ? 'lastDay' : diff < 1 ? 'sameDay' : diff < 2 ? 'nextDay' : diff < 7 ? 'nextWeek' : 'sameElse';
    }

    function calendar$1(time, formats) {
        // We want to compare the start of today, vs this.
        // Getting start-of-today depends on whether we're local/utc/offset or not.
        var now = time || createLocal()
          , sod = cloneWithOffset(now, this).startOf('day')
          , format = hooks.calendarFormat(this, sod) || 'sameElse';

        var output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);

        return this.format(output || this.localeData().calendar(format, this, createLocal(now)));
    }

    function clone() {
        return new Moment(this);
    }

    function isAfter(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() > localInput.valueOf();
        } else {
            return localInput.valueOf() < this.clone().startOf(units).valueOf();
        }
    }

    function isBefore(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input);
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(!isUndefined(units) ? units : 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() < localInput.valueOf();
        } else {
            return this.clone().endOf(units).valueOf() < localInput.valueOf();
        }
    }

    function isBetween(from, to, units, inclusivity) {
        inclusivity = inclusivity || '()';
        return (inclusivity[0] === '(' ? this.isAfter(from, units) : !this.isBefore(from, units)) && (inclusivity[1] === ')' ? this.isBefore(to, units) : !this.isAfter(to, units));
    }

    function isSame(input, units) {
        var localInput = isMoment(input) ? input : createLocal(input), inputMs;
        if (!(this.isValid() && localInput.isValid())) {
            return false;
        }
        units = normalizeUnits(units || 'millisecond');
        if (units === 'millisecond') {
            return this.valueOf() === localInput.valueOf();
        } else {
            inputMs = localInput.valueOf();
            return this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf();
        }
    }

    function isSameOrAfter(input, units) {
        return this.isSame(input, units) || this.isAfter(input, units);
    }

    function isSameOrBefore(input, units) {
        return this.isSame(input, units) || this.isBefore(input, units);
    }

    function diff(input, units, asFloat) {
        var that, zoneDelta, output;

        if (!this.isValid()) {
            return NaN;
        }

        that = cloneWithOffset(input, this);

        if (!that.isValid()) {
            return NaN;
        }

        zoneDelta = (that.utcOffset() - this.utcOffset()) * 6e4;

        units = normalizeUnits(units);

        switch (units) {
        case 'year':
            output = monthDiff(this, that) / 12;
            break;
        case 'month':
            output = monthDiff(this, that);
            break;
        case 'quarter':
            output = monthDiff(this, that) / 3;
            break;
        case 'second':
            output = (this - that) / 1e3;
            break;
            // 1000
        case 'minute':
            output = (this - that) / 6e4;
            break;
            // 1000 * 60
        case 'hour':
            output = (this - that) / 36e5;
            break;
            // 1000 * 60 * 60
        case 'day':
            output = (this - that - zoneDelta) / 864e5;
            break;
            // 1000 * 60 * 60 * 24, negate dst
        case 'week':
            output = (this - that - zoneDelta) / 6048e5;
            break;
            // 1000 * 60 * 60 * 24 * 7, negate dst
        default:
            output = this - that;
        }

        return asFloat ? output : absFloor(output);
    }

    function monthDiff(a, b) {
        // difference in months
        var wholeMonthDiff = ((b.year() - a.year()) * 12) + (b.month() - a.month()), // b is in (anchor - 1 month, anchor + 1 month)
        anchor = a.clone().add(wholeMonthDiff, 'months'), anchor2, adjust;

        if (b - anchor < 0) {
            anchor2 = a.clone().add(wholeMonthDiff - 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor - anchor2);
        } else {
            anchor2 = a.clone().add(wholeMonthDiff + 1, 'months');
            // linear across the month
            adjust = (b - anchor) / (anchor2 - anchor);
        }

        //check for negative zero, return zero if negative zero
        return -(wholeMonthDiff + adjust) || 0;
    }

    hooks.defaultFormat = 'YYYY-MM-DDTHH:mm:ssZ';
    hooks.defaultFormatUtc = 'YYYY-MM-DDTHH:mm:ss[Z]';

    function toString() {
        return this.clone().locale('en').format('ddd MMM DD YYYY HH:mm:ss [GMT]ZZ');
    }

    function toISOString(keepOffset) {
        if (!this.isValid()) {
            return null;
        }
        var utc = keepOffset !== true;
        var m = utc ? this.clone().utc() : this;
        if (m.year() < 0 || m.year() > 9999) {
            return formatMoment(m, utc ? 'YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYYYY-MM-DD[T]HH:mm:ss.SSSZ');
        }
        if (isFunction(Date.prototype.toISOString)) {
            // native implementation is ~50x faster, use it when we can
            if (utc) {
                return this.toDate().toISOString();
            } else {
                return new Date(this.valueOf() + this.utcOffset() * 60 * 1000).toISOString().replace('Z', formatMoment(m, 'Z'));
            }
        }
        return formatMoment(m, utc ? 'YYYY-MM-DD[T]HH:mm:ss.SSS[Z]' : 'YYYY-MM-DD[T]HH:mm:ss.SSSZ');
    }

    /**
 * Return a human readable representation of a moment that can
 * also be evaluated to get a new moment which is the same
 *
 * @link https://nodejs.org/dist/latest/docs/api/util.html#util_custom_inspect_function_on_objects
 */
    function inspect() {
        if (!this.isValid()) {
            return 'moment.invalid(/* ' + this._i + ' */)';
        }
        var func = 'moment';
        var zone = '';
        if (!this.isLocal()) {
            func = this.utcOffset() === 0 ? 'moment.utc' : 'moment.parseZone';
            zone = 'Z';
        }
        var prefix = '[' + func + '("]';
        var year = (0 <= this.year() && this.year() <= 9999) ? 'YYYY' : 'YYYYYY';
        var datetime = '-MM-DD[T]HH:mm:ss.SSS';
        var suffix = zone + '[")]';

        return this.format(prefix + year + datetime + suffix);
    }

    function format(inputString) {
        if (!inputString) {
            inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat;
        }
        var output = formatMoment(this, inputString);
        return this.localeData().postformat(output);
    }

    function from(time, withoutSuffix) {
        if (this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())) {
            return createDuration({
                to: this,
                from: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function fromNow(withoutSuffix) {
        return this.from(createLocal(), withoutSuffix);
    }

    function to(time, withoutSuffix) {
        if (this.isValid() && ((isMoment(time) && time.isValid()) || createLocal(time).isValid())) {
            return createDuration({
                from: this,
                to: time
            }).locale(this.locale()).humanize(!withoutSuffix);
        } else {
            return this.localeData().invalidDate();
        }
    }

    function toNow(withoutSuffix) {
        return this.to(createLocal(), withoutSuffix);
    }

    // If passed a locale key, it will set the locale for this
    // instance.  Otherwise, it will return the locale configuration
    // variables for this instance.
    function locale(key) {
        var newLocaleData;

        if (key === undefined) {
            return this._locale._abbr;
        } else {
            newLocaleData = getLocale(key);
            if (newLocaleData != null) {
                this._locale = newLocaleData;
            }
            return this;
        }
    }

    var lang = deprecate('moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.', function(key) {
        if (key === undefined) {
            return this.localeData();
        } else {
            return this.locale(key);
        }
    });

    function localeData() {
        return this._locale;
    }

    function startOf(units) {
        units = normalizeUnits(units);
        // the following switch intentionally omits break keywords
        // to utilize falling through the cases.
        switch (units) {
        case 'year':
            this.month(0);
            /* falls through */
        case 'quarter':
        case 'month':
            this.date(1);
            /* falls through */
        case 'week':
        case 'isoWeek':
        case 'day':
        case 'date':
            this.hours(0);
            /* falls through */
        case 'hour':
            this.minutes(0);
            /* falls through */
        case 'minute':
            this.seconds(0);
            /* falls through */
        case 'second':
            this.milliseconds(0);
        }

        // weeks are a special case
        if (units === 'week') {
            this.weekday(0);
        }
        if (units === 'isoWeek') {
            this.isoWeekday(1);
        }

        // quarters are also special
        if (units === 'quarter') {
            this.month(Math.floor(this.month() / 3) * 3);
        }

        return this;
    }

    function endOf(units) {
        units = normalizeUnits(units);
        if (units === undefined || units === 'millisecond') {
            return this;
        }

        // 'date' is an alias for 'day', so it should be considered as such.
        if (units === 'date') {
            units = 'day';
        }

        return this.startOf(units).add(1, (units === 'isoWeek' ? 'week' : units)).subtract(1, 'ms');
    }

    function valueOf() {
        return this._d.valueOf() - ((this._offset || 0) * 60000);
    }

    function unix() {
        return Math.floor(this.valueOf() / 1000);
    }

    function toDate() {
        return new Date(this.valueOf());
    }

    function toArray() {
        var m = this;
        return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()];
    }

    function toObject() {
        var m = this;
        return {
            years: m.year(),
            months: m.month(),
            date: m.date(),
            hours: m.hours(),
            minutes: m.minutes(),
            seconds: m.seconds(),
            milliseconds: m.milliseconds()
        };
    }

    function toJSON() {
        // new Date(NaN).toJSON() === null
        return this.isValid() ? this.toISOString() : null;
    }

    function isValid$2() {
        return isValid(this);
    }

    function parsingFlags() {
        return extend({}, getParsingFlags(this));
    }

    function invalidAt() {
        return getParsingFlags(this).overflow;
    }

    function creationData() {
        return {
            input: this._i,
            format: this._f,
            locale: this._locale,
            isUTC: this._isUTC,
            strict: this._strict
        };
    }

    // FORMATTING

    addFormatToken(0, ['gg', 2], 0, function() {
        return this.weekYear() % 100;
    });

    addFormatToken(0, ['GG', 2], 0, function() {
        return this.isoWeekYear() % 100;
    });

    function addWeekYearFormatToken(token, getter) {
        addFormatToken(0, [token, token.length], 0, getter);
    }

    addWeekYearFormatToken('gggg', 'weekYear');
    addWeekYearFormatToken('ggggg', 'weekYear');
    addWeekYearFormatToken('GGGG', 'isoWeekYear');
    addWeekYearFormatToken('GGGGG', 'isoWeekYear');

    // ALIASES

    addUnitAlias('weekYear', 'gg');
    addUnitAlias('isoWeekYear', 'GG');

    // PRIORITY

    addUnitPriority('weekYear', 1);
    addUnitPriority('isoWeekYear', 1);

    // PARSING

    addRegexToken('G', matchSigned);
    addRegexToken('g', matchSigned);
    addRegexToken('GG', match1to2, match2);
    addRegexToken('gg', match1to2, match2);
    addRegexToken('GGGG', match1to4, match4);
    addRegexToken('gggg', match1to4, match4);
    addRegexToken('GGGGG', match1to6, match6);
    addRegexToken('ggggg', match1to6, match6);

    addWeekParseToken(['gggg', 'ggggg', 'GGGG', 'GGGGG'], function(input, week, config, token) {
        week[token.substr(0, 2)] = toInt(input);
    });

    addWeekParseToken(['gg', 'GG'], function(input, week, config, token) {
        week[token] = hooks.parseTwoDigitYear(input);
    });

    // MOMENTS

    function getSetWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy);
    }

    function getSetISOWeekYear(input) {
        return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4);
    }

    function getISOWeeksInYear() {
        return weeksInYear(this.year(), 1, 4);
    }

    function getWeeksInYear() {
        var weekInfo = this.localeData()._week;
        return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy);
    }

    function getSetWeekYearHelper(input, week, weekday, dow, doy) {
        var weeksTarget;
        if (input == null) {
            return weekOfYear(this, dow, doy).year;
        } else {
            weeksTarget = weeksInYear(input, dow, doy);
            if (week > weeksTarget) {
                week = weeksTarget;
            }
            return setWeekAll.call(this, input, week, weekday, dow, doy);
        }
    }

    function setWeekAll(weekYear, week, weekday, dow, doy) {
        var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy)
          , date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);

        this.year(date.getUTCFullYear());
        this.month(date.getUTCMonth());
        this.date(date.getUTCDate());
        return this;
    }

    // FORMATTING

    addFormatToken('Q', 0, 'Qo', 'quarter');

    // ALIASES

    addUnitAlias('quarter', 'Q');

    // PRIORITY

    addUnitPriority('quarter', 7);

    // PARSING

    addRegexToken('Q', match1);
    addParseToken('Q', function(input, array) {
        array[MONTH] = (toInt(input) - 1) * 3;
    });

    // MOMENTS

    function getSetQuarter(input) {
        return input == null ? Math.ceil((this.month() + 1) / 3) : this.month((input - 1) * 3 + this.month() % 3);
    }

    // FORMATTING

    addFormatToken('D', ['DD', 2], 'Do', 'date');

    // ALIASES

    addUnitAlias('date', 'D');

    // PRIOROITY
    addUnitPriority('date', 9);

    // PARSING

    addRegexToken('D', match1to2);
    addRegexToken('DD', match1to2, match2);
    addRegexToken('Do', function(isStrict, locale) {
        // TODO: Remove "ordinalParse" fallback in next major release.
        return isStrict ? (locale._dayOfMonthOrdinalParse || locale._ordinalParse) : locale._dayOfMonthOrdinalParseLenient;
    });

    addParseToken(['D', 'DD'], DATE);
    addParseToken('Do', function(input, array) {
        array[DATE] = toInt(input.match(match1to2)[0]);
    });

    // MOMENTS

    var getSetDayOfMonth = makeGetSet('Date', true);

    // FORMATTING

    addFormatToken('DDD', ['DDDD', 3], 'DDDo', 'dayOfYear');

    // ALIASES

    addUnitAlias('dayOfYear', 'DDD');

    // PRIORITY
    addUnitPriority('dayOfYear', 4);

    // PARSING

    addRegexToken('DDD', match1to3);
    addRegexToken('DDDD', match3);
    addParseToken(['DDD', 'DDDD'], function(input, array, config) {
        config._dayOfYear = toInt(input);
    });

    // HELPERS

    // MOMENTS

    function getSetDayOfYear(input) {
        var dayOfYear = Math.round((this.clone().startOf('day') - this.clone().startOf('year')) / 864e5) + 1;
        return input == null ? dayOfYear : this.add((input - dayOfYear), 'd');
    }

    // FORMATTING

    addFormatToken('m', ['mm', 2], 0, 'minute');

    // ALIASES

    addUnitAlias('minute', 'm');

    // PRIORITY

    addUnitPriority('minute', 14);

    // PARSING

    addRegexToken('m', match1to2);
    addRegexToken('mm', match1to2, match2);
    addParseToken(['m', 'mm'], MINUTE);

    // MOMENTS

    var getSetMinute = makeGetSet('Minutes', false);

    // FORMATTING

    addFormatToken('s', ['ss', 2], 0, 'second');

    // ALIASES

    addUnitAlias('second', 's');

    // PRIORITY

    addUnitPriority('second', 15);

    // PARSING

    addRegexToken('s', match1to2);
    addRegexToken('ss', match1to2, match2);
    addParseToken(['s', 'ss'], SECOND);

    // MOMENTS

    var getSetSecond = makeGetSet('Seconds', false);

    // FORMATTING

    addFormatToken('S', 0, 0, function() {
        return ~~(this.millisecond() / 100);
    });

    addFormatToken(0, ['SS', 2], 0, function() {
        return ~~(this.millisecond() / 10);
    });

    addFormatToken(0, ['SSS', 3], 0, 'millisecond');
    addFormatToken(0, ['SSSS', 4], 0, function() {
        return this.millisecond() * 10;
    });
    addFormatToken(0, ['SSSSS', 5], 0, function() {
        return this.millisecond() * 100;
    });
    addFormatToken(0, ['SSSSSS', 6], 0, function() {
        return this.millisecond() * 1000;
    });
    addFormatToken(0, ['SSSSSSS', 7], 0, function() {
        return this.millisecond() * 10000;
    });
    addFormatToken(0, ['SSSSSSSS', 8], 0, function() {
        return this.millisecond() * 100000;
    });
    addFormatToken(0, ['SSSSSSSSS', 9], 0, function() {
        return this.millisecond() * 1000000;
    });

    // ALIASES

    addUnitAlias('millisecond', 'ms');

    // PRIORITY

    addUnitPriority('millisecond', 16);

    // PARSING

    addRegexToken('S', match1to3, match1);
    addRegexToken('SS', match1to3, match2);
    addRegexToken('SSS', match1to3, match3);

    var token;
    for (token = 'SSSS'; token.length <= 9; token += 'S') {
        addRegexToken(token, matchUnsigned);
    }

    function parseMs(input, array) {
        array[MILLISECOND] = toInt(('0.' + input) * 1000);
    }

    for (token = 'S'; token.length <= 9; token += 'S') {
        addParseToken(token, parseMs);
    }
    // MOMENTS

    var getSetMillisecond = makeGetSet('Milliseconds', false);

    // FORMATTING

    addFormatToken('z', 0, 0, 'zoneAbbr');
    addFormatToken('zz', 0, 0, 'zoneName');

    // MOMENTS

    function getZoneAbbr() {
        return this._isUTC ? 'UTC' : '';
    }

    function getZoneName() {
        return this._isUTC ? 'Coordinated Universal Time' : '';
    }

    var proto = Moment.prototype;

    proto.add = add;
    proto.calendar = calendar$1;
    proto.clone = clone;
    proto.diff = diff;
    proto.endOf = endOf;
    proto.format = format;
    proto.from = from;
    proto.fromNow = fromNow;
    proto.to = to;
    proto.toNow = toNow;
    proto.get = stringGet;
    proto.invalidAt = invalidAt;
    proto.isAfter = isAfter;
    proto.isBefore = isBefore;
    proto.isBetween = isBetween;
    proto.isSame = isSame;
    proto.isSameOrAfter = isSameOrAfter;
    proto.isSameOrBefore = isSameOrBefore;
    proto.isValid = isValid$2;
    proto.lang = lang;
    proto.locale = locale;
    proto.localeData = localeData;
    proto.max = prototypeMax;
    proto.min = prototypeMin;
    proto.parsingFlags = parsingFlags;
    proto.set = stringSet;
    proto.startOf = startOf;
    proto.subtract = subtract;
    proto.toArray = toArray;
    proto.toObject = toObject;
    proto.toDate = toDate;
    proto.toISOString = toISOString;
    proto.inspect = inspect;
    proto.toJSON = toJSON;
    proto.toString = toString;
    proto.unix = unix;
    proto.valueOf = valueOf;
    proto.creationData = creationData;
    proto.year = getSetYear;
    proto.isLeapYear = getIsLeapYear;
    proto.weekYear = getSetWeekYear;
    proto.isoWeekYear = getSetISOWeekYear;
    proto.quarter = proto.quarters = getSetQuarter;
    proto.month = getSetMonth;
    proto.daysInMonth = getDaysInMonth;
    proto.week = proto.weeks = getSetWeek;
    proto.isoWeek = proto.isoWeeks = getSetISOWeek;
    proto.weeksInYear = getWeeksInYear;
    proto.isoWeeksInYear = getISOWeeksInYear;
    proto.date = getSetDayOfMonth;
    proto.day = proto.days = getSetDayOfWeek;
    proto.weekday = getSetLocaleDayOfWeek;
    proto.isoWeekday = getSetISODayOfWeek;
    proto.dayOfYear = getSetDayOfYear;
    proto.hour = proto.hours = getSetHour;
    proto.minute = proto.minutes = getSetMinute;
    proto.second = proto.seconds = getSetSecond;
    proto.millisecond = proto.milliseconds = getSetMillisecond;
    proto.utcOffset = getSetOffset;
    proto.utc = setOffsetToUTC;
    proto.local = setOffsetToLocal;
    proto.parseZone = setOffsetToParsedOffset;
    proto.hasAlignedHourOffset = hasAlignedHourOffset;
    proto.isDST = isDaylightSavingTime;
    proto.isLocal = isLocal;
    proto.isUtcOffset = isUtcOffset;
    proto.isUtc = isUtc;
    proto.isUTC = isUtc;
    proto.zoneAbbr = getZoneAbbr;
    proto.zoneName = getZoneName;
    proto.dates = deprecate('dates accessor is deprecated. Use date instead.', getSetDayOfMonth);
    proto.months = deprecate('months accessor is deprecated. Use month instead', getSetMonth);
    proto.years = deprecate('years accessor is deprecated. Use year instead', getSetYear);
    proto.zone = deprecate('moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/', getSetZone);
    proto.isDSTShifted = deprecate('isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information', isDaylightSavingTimeShifted);

    function createUnix(input) {
        return createLocal(input * 1000);
    }

    function createInZone() {
        return createLocal.apply(null, arguments).parseZone();
    }

    function preParsePostFormat(string) {
        return string;
    }

    var proto$1 = Locale.prototype;

    proto$1.calendar = calendar;
    proto$1.longDateFormat = longDateFormat;
    proto$1.invalidDate = invalidDate;
    proto$1.ordinal = ordinal;
    proto$1.preparse = preParsePostFormat;
    proto$1.postformat = preParsePostFormat;
    proto$1.relativeTime = relativeTime;
    proto$1.pastFuture = pastFuture;
    proto$1.set = set;

    proto$1.months = localeMonths;
    proto$1.monthsShort = localeMonthsShort;
    proto$1.monthsParse = localeMonthsParse;
    proto$1.monthsRegex = monthsRegex;
    proto$1.monthsShortRegex = monthsShortRegex;
    proto$1.week = localeWeek;
    proto$1.firstDayOfYear = localeFirstDayOfYear;
    proto$1.firstDayOfWeek = localeFirstDayOfWeek;

    proto$1.weekdays = localeWeekdays;
    proto$1.weekdaysMin = localeWeekdaysMin;
    proto$1.weekdaysShort = localeWeekdaysShort;
    proto$1.weekdaysParse = localeWeekdaysParse;

    proto$1.weekdaysRegex = weekdaysRegex;
    proto$1.weekdaysShortRegex = weekdaysShortRegex;
    proto$1.weekdaysMinRegex = weekdaysMinRegex;

    proto$1.isPM = localeIsPM;
    proto$1.meridiem = localeMeridiem;

    function get$1(format, index, field, setter) {
        var locale = getLocale();
        var utc = createUTC().set(setter, index);
        return locale[field](utc, format);
    }

    function listMonthsImpl(format, index, field) {
        if (isNumber(format)) {
            index = format;
            format = undefined;
        }

        format = format || '';

        if (index != null) {
            return get$1(format, index, field, 'month');
        }

        var i;
        var out = [];
        for (i = 0; i < 12; i++) {
            out[i] = get$1(format, i, field, 'month');
        }
        return out;
    }

    // ()
    // (5)
    // (fmt, 5)
    // (fmt)
    // (true)
    // (true, 5)
    // (true, fmt, 5)
    // (true, fmt)
    function listWeekdaysImpl(localeSorted, format, index, field) {
        if (typeof localeSorted === 'boolean') {
            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        } else {
            format = localeSorted;
            index = format;
            localeSorted = false;

            if (isNumber(format)) {
                index = format;
                format = undefined;
            }

            format = format || '';
        }

        var locale = getLocale()
          , shift = localeSorted ? locale._week.dow : 0;

        if (index != null) {
            return get$1(format, (index + shift) % 7, field, 'day');
        }

        var i;
        var out = [];
        for (i = 0; i < 7; i++) {
            out[i] = get$1(format, (i + shift) % 7, field, 'day');
        }
        return out;
    }

    function listMonths(format, index) {
        return listMonthsImpl(format, index, 'months');
    }

    function listMonthsShort(format, index) {
        return listMonthsImpl(format, index, 'monthsShort');
    }

    function listWeekdays(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdays');
    }

    function listWeekdaysShort(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysShort');
    }

    function listWeekdaysMin(localeSorted, format, index) {
        return listWeekdaysImpl(localeSorted, format, index, 'weekdaysMin');
    }

    getSetGlobalLocale('en', {
        dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
        ordinal: function(number) {
            var b = number % 10
              , output = (toInt(number % 100 / 10) === 1) ? 'th' : (b === 1) ? 'st' : (b === 2) ? 'nd' : (b === 3) ? 'rd' : 'th';
            return number + output;
        }
    });

    // Side effect imports

    hooks.lang = deprecate('moment.lang is deprecated. Use moment.locale instead.', getSetGlobalLocale);
    hooks.langData = deprecate('moment.langData is deprecated. Use moment.localeData instead.', getLocale);

    var mathAbs = Math.abs;

    function abs() {
        var data = this._data;

        this._milliseconds = mathAbs(this._milliseconds);
        this._days = mathAbs(this._days);
        this._months = mathAbs(this._months);

        data.milliseconds = mathAbs(data.milliseconds);
        data.seconds = mathAbs(data.seconds);
        data.minutes = mathAbs(data.minutes);
        data.hours = mathAbs(data.hours);
        data.months = mathAbs(data.months);
        data.years = mathAbs(data.years);

        return this;
    }

    function addSubtract$1(duration, input, value, direction) {
        var other = createDuration(input, value);

        duration._milliseconds += direction * other._milliseconds;
        duration._days += direction * other._days;
        duration._months += direction * other._months;

        return duration._bubble();
    }

    // supports only 2.0-style add(1, 's') or add(duration)
    function add$1(input, value) {
        return addSubtract$1(this, input, value, 1);
    }

    // supports only 2.0-style subtract(1, 's') or subtract(duration)
    function subtract$1(input, value) {
        return addSubtract$1(this, input, value, -1);
    }

    function absCeil(number) {
        if (number < 0) {
            return Math.floor(number);
        } else {
            return Math.ceil(number);
        }
    }

    function bubble() {
        var milliseconds = this._milliseconds;
        var days = this._days;
        var months = this._months;
        var data = this._data;
        var seconds, minutes, hours, years, monthsFromDays;

        // if we have a mix of positive and negative values, bubble down first
        // check: https://github.com/moment/moment/issues/2166
        if (!((milliseconds >= 0 && days >= 0 && months >= 0) || (milliseconds <= 0 && days <= 0 && months <= 0))) {
            milliseconds += absCeil(monthsToDays(months) + days) * 864e5;
            days = 0;
            months = 0;
        }

        // The following code bubbles up values, see the tests for
        // examples of what that means.
        data.milliseconds = milliseconds % 1000;

        seconds = absFloor(milliseconds / 1000);
        data.seconds = seconds % 60;

        minutes = absFloor(seconds / 60);
        data.minutes = minutes % 60;

        hours = absFloor(minutes / 60);
        data.hours = hours % 24;

        days += absFloor(hours / 24);

        // convert days to months
        monthsFromDays = absFloor(daysToMonths(days));
        months += monthsFromDays;
        days -= absCeil(monthsToDays(monthsFromDays));

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        data.days = days;
        data.months = months;
        data.years = years;

        return this;
    }

    function daysToMonths(days) {
        // 400 years have 146097 days (taking into account leap year rules)
        // 400 years have 12 months === 4800
        return days * 4800 / 146097;
    }

    function monthsToDays(months) {
        // the reverse of daysToMonths
        return months * 146097 / 4800;
    }

    function as(units) {
        if (!this.isValid()) {
            return NaN;
        }
        var days;
        var months;
        var milliseconds = this._milliseconds;

        units = normalizeUnits(units);

        if (units === 'month' || units === 'year') {
            days = this._days + milliseconds / 864e5;
            months = this._months + daysToMonths(days);
            return units === 'month' ? months : months / 12;
        } else {
            // handle milliseconds separately because of floating point math errors (issue #1867)
            days = this._days + Math.round(monthsToDays(this._months));
            switch (units) {
            case 'week':
                return days / 7 + milliseconds / 6048e5;
            case 'day':
                return days + milliseconds / 864e5;
            case 'hour':
                return days * 24 + milliseconds / 36e5;
            case 'minute':
                return days * 1440 + milliseconds / 6e4;
            case 'second':
                return days * 86400 + milliseconds / 1000;
                // Math.floor prevents floating point math errors here
            case 'millisecond':
                return Math.floor(days * 864e5) + milliseconds;
            default:
                throw new Error('Unknown unit ' + units);
            }
        }
    }

    // TODO: Use this.as('ms')?
    function valueOf$1() {
        if (!this.isValid()) {
            return NaN;
        }
        return (this._milliseconds + this._days * 864e5 + (this._months % 12) * 2592e6 + toInt(this._months / 12) * 31536e6);
    }

    function makeAs(alias) {
        return function() {
            return this.as(alias);
        }
        ;
    }

    var asMilliseconds = makeAs('ms');
    var asSeconds = makeAs('s');
    var asMinutes = makeAs('m');
    var asHours = makeAs('h');
    var asDays = makeAs('d');
    var asWeeks = makeAs('w');
    var asMonths = makeAs('M');
    var asYears = makeAs('y');

    function clone$1() {
        return createDuration(this);
    }

    function get$2(units) {
        units = normalizeUnits(units);
        return this.isValid() ? this[units + 's']() : NaN;
    }

    function makeGetter(name) {
        return function() {
            return this.isValid() ? this._data[name] : NaN;
        }
        ;
    }

    var milliseconds = makeGetter('milliseconds');
    var seconds = makeGetter('seconds');
    var minutes = makeGetter('minutes');
    var hours = makeGetter('hours');
    var days = makeGetter('days');
    var months = makeGetter('months');
    var years = makeGetter('years');

    function weeks() {
        return absFloor(this.days() / 7);
    }

    var round = Math.round;
    var thresholds = {
        ss: 44,
        // a few seconds to seconds
        s: 45,
        // seconds to minute
        m: 45,
        // minutes to hour
        h: 22,
        // hours to day
        d: 26,
        // days to month
        M: 11 // months to year
    };

    // helper function for moment.fn.from, moment.fn.fromNow, and moment.duration.fn.humanize
    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture);
    }

    function relativeTime$1(posNegDuration, withoutSuffix, locale) {
        var duration = createDuration(posNegDuration).abs();
        var seconds = round(duration.as('s'));
        var minutes = round(duration.as('m'));
        var hours = round(duration.as('h'));
        var days = round(duration.as('d'));
        var months = round(duration.as('M'));
        var years = round(duration.as('y'));

        var a = seconds <= thresholds.ss && ['s', seconds] || seconds < thresholds.s && ['ss', seconds] || minutes <= 1 && ['m'] || minutes < thresholds.m && ['mm', minutes] || hours <= 1 && ['h'] || hours < thresholds.h && ['hh', hours] || days <= 1 && ['d'] || days < thresholds.d && ['dd', days] || months <= 1 && ['M'] || months < thresholds.M && ['MM', months] || years <= 1 && ['y'] || ['yy', years];

        a[2] = withoutSuffix;
        a[3] = +posNegDuration > 0;
        a[4] = locale;
        return substituteTimeAgo.apply(null, a);
    }

    // This function allows you to set the rounding function for relative time strings
    function getSetRelativeTimeRounding(roundingFunction) {
        if (roundingFunction === undefined) {
            return round;
        }
        if (typeof (roundingFunction) === 'function') {
            round = roundingFunction;
            return true;
        }
        return false;
    }

    // This function allows you to set a threshold for relative time strings
    function getSetRelativeTimeThreshold(threshold, limit) {
        if (thresholds[threshold] === undefined) {
            return false;
        }
        if (limit === undefined) {
            return thresholds[threshold];
        }
        thresholds[threshold] = limit;
        if (threshold === 's') {
            thresholds.ss = limit - 1;
        }
        return true;
    }

    function humanize(withSuffix) {
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var locale = this.localeData();
        var output = relativeTime$1(this, !withSuffix, locale);

        if (withSuffix) {
            output = locale.pastFuture(+this, output);
        }

        return locale.postformat(output);
    }

    var abs$1 = Math.abs;

    function sign(x) {
        return ((x > 0) - (x < 0)) || +x;
    }

    function toISOString$1() {
        // for ISO strings we do not use the normal bubbling rules:
        //  * milliseconds bubble up until they become hours
        //  * days do not bubble at all
        //  * months bubble up until they become years
        // This is because there is no context-free conversion between hours and days
        // (think of clock changes)
        // and also not between days and months (28-31 days per month)
        if (!this.isValid()) {
            return this.localeData().invalidDate();
        }

        var seconds = abs$1(this._milliseconds) / 1000;
        var days = abs$1(this._days);
        var months = abs$1(this._months);
        var minutes, hours, years;

        // 3600 seconds -> 60 minutes -> 1 hour
        minutes = absFloor(seconds / 60);
        hours = absFloor(minutes / 60);
        seconds %= 60;
        minutes %= 60;

        // 12 months -> 1 year
        years = absFloor(months / 12);
        months %= 12;

        // inspired by https://github.com/dordille/moment-isoduration/blob/master/moment.isoduration.js
        var Y = years;
        var M = months;
        var D = days;
        var h = hours;
        var m = minutes;
        var s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, '') : '';
        var total = this.asSeconds();

        if (!total) {
            // this is the same as C#'s (Noda) and python (isodate)...
            // but not other JS (goog.date)
            return 'P0D';
        }

        var totalSign = total < 0 ? '-' : '';
        var ymSign = sign(this._months) !== sign(total) ? '-' : '';
        var daysSign = sign(this._days) !== sign(total) ? '-' : '';
        var hmsSign = sign(this._milliseconds) !== sign(total) ? '-' : '';

        return totalSign + 'P' + (Y ? ymSign + Y + 'Y' : '') + (M ? ymSign + M + 'M' : '') + (D ? daysSign + D + 'D' : '') + ((h || m || s) ? 'T' : '') + (h ? hmsSign + h + 'H' : '') + (m ? hmsSign + m + 'M' : '') + (s ? hmsSign + s + 'S' : '');
    }

    var proto$2 = Duration.prototype;

    proto$2.isValid = isValid$1;
    proto$2.abs = abs;
    proto$2.add = add$1;
    proto$2.subtract = subtract$1;
    proto$2.as = as;
    proto$2.asMilliseconds = asMilliseconds;
    proto$2.asSeconds = asSeconds;
    proto$2.asMinutes = asMinutes;
    proto$2.asHours = asHours;
    proto$2.asDays = asDays;
    proto$2.asWeeks = asWeeks;
    proto$2.asMonths = asMonths;
    proto$2.asYears = asYears;
    proto$2.valueOf = valueOf$1;
    proto$2._bubble = bubble;
    proto$2.clone = clone$1;
    proto$2.get = get$2;
    proto$2.milliseconds = milliseconds;
    proto$2.seconds = seconds;
    proto$2.minutes = minutes;
    proto$2.hours = hours;
    proto$2.days = days;
    proto$2.weeks = weeks;
    proto$2.months = months;
    proto$2.years = years;
    proto$2.humanize = humanize;
    proto$2.toISOString = toISOString$1;
    proto$2.toString = toISOString$1;
    proto$2.toJSON = toISOString$1;
    proto$2.locale = locale;
    proto$2.localeData = localeData;

    proto$2.toIsoString = deprecate('toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)', toISOString$1);
    proto$2.lang = lang;

    // Side effect imports

    // FORMATTING

    addFormatToken('X', 0, 0, 'unix');
    addFormatToken('x', 0, 0, 'valueOf');

    // PARSING

    addRegexToken('x', matchSigned);
    addRegexToken('X', matchTimestamp);
    addParseToken('X', function(input, array, config) {
        config._d = new Date(parseFloat(input, 10) * 1000);
    });
    addParseToken('x', function(input, array, config) {
        config._d = new Date(toInt(input));
    });

    // Side effect imports

    hooks.version = '2.21.0';

    setHookCallback(createLocal);

    hooks.fn = proto;
    hooks.min = min;
    hooks.max = max;
    hooks.now = now;
    hooks.utc = createUTC;
    hooks.unix = createUnix;
    hooks.months = listMonths;
    hooks.isDate = isDate;
    hooks.locale = getSetGlobalLocale;
    hooks.invalid = createInvalid;
    hooks.duration = createDuration;
    hooks.isMoment = isMoment;
    hooks.weekdays = listWeekdays;
    hooks.parseZone = createInZone;
    hooks.localeData = getLocale;
    hooks.isDuration = isDuration;
    hooks.monthsShort = listMonthsShort;
    hooks.weekdaysMin = listWeekdaysMin;
    hooks.defineLocale = defineLocale;
    hooks.updateLocale = updateLocale;
    hooks.locales = listLocales;
    hooks.weekdaysShort = listWeekdaysShort;
    hooks.normalizeUnits = normalizeUnits;
    hooks.relativeTimeRounding = getSetRelativeTimeRounding;
    hooks.relativeTimeThreshold = getSetRelativeTimeThreshold;
    hooks.calendarFormat = getCalendarFormat;
    hooks.prototype = proto;

    // currently HTML5 input type only supports 24-hour formats
    hooks.HTML5_FMT = {
        DATETIME_LOCAL: 'YYYY-MM-DDTHH:mm',
        // <input type="datetime-local" />
        DATETIME_LOCAL_SECONDS: 'YYYY-MM-DDTHH:mm:ss',
        // <input type="datetime-local" step="1" />
        DATETIME_LOCAL_MS: 'YYYY-MM-DDTHH:mm:ss.SSS',
        // <input type="datetime-local" step="0.001" />
        DATE: 'YYYY-MM-DD',
        // <input type="date" />
        TIME: 'HH:mm',
        // <input type="time" />
        TIME_SECONDS: 'HH:mm:ss',
        // <input type="time" step="1" />
        TIME_MS: 'HH:mm:ss.SSS',
        // <input type="time" step="0.001" />
        WEEK: 'YYYY-[W]WW',
        // <input type="week" />
        MONTH: 'YYYY-MM'// <input type="month" />
    };

    return hooks;

}
)));

/*!
 * Pikaday
 *
 * Copyright © 2014 David Bushell | BSD & MIT license | https://github.com/dbushell/Pikaday
 */

(function(root, factory) {
    'use strict';

    var moment;
    if (typeof exports === 'object') {
        // CommonJS module
        // Load moment.js as an optional dependency
        try {
            moment = require('moment');
        } catch (e) {}
        module.exports = factory(moment);
    } else if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module.
        define(function(req) {
            // Load moment.js as an optional dependency
            var id = 'moment';
            try {
                moment = req(id);
            } catch (e) {}
            return factory(moment);
        });
    } else {
        root.Pikaday = factory(root.moment);
    }
}(this, function(moment) {
    'use strict';

    /**
     * feature detection and helper functions
     */
    var hasMoment = typeof moment === 'function'
      ,
    hasEventListeners = !!window.addEventListener
      ,
    document = window.document
      ,
    sto = window.setTimeout
      ,
    addEvent = function(el, e, callback, capture) {
        if (hasEventListeners) {
            el.addEventListener(e, callback, !!capture);
        } else {
            el.attachEvent('on' + e, callback);
        }
    }
      ,
    removeEvent = function(el, e, callback, capture) {
        if (hasEventListeners) {
            el.removeEventListener(e, callback, !!capture);
        } else {
            el.detachEvent('on' + e, callback);
        }
    }
      ,
    trim = function(str) {
        return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
    }
      ,
    hasClass = function(el, cn) {
        return (' ' + el.className + ' ').indexOf(' ' + cn + ' ') !== -1;
    }
      ,
    addClass = function(el, cn) {
        if (!hasClass(el, cn)) {
            el.className = (el.className === '') ? cn : el.className + ' ' + cn;
        }
    }
      ,
    removeClass = function(el, cn) {
        el.className = trim((' ' + el.className + ' ').replace(' ' + cn + ' ', ' '));
    }
      ,
    isArray = function(obj) {
        return (/Array/).test(Object.prototype.toString.call(obj));
    }
      ,
    isDate = function(obj) {
        return (/Date/).test(Object.prototype.toString.call(obj)) && !isNaN(obj.getTime());
    }
      ,
    isWeekend = function(date) {
        var day = date.getDay();
        return day === 0 || day === 6;
    }
      ,
    isLeapYear = function(year) {
        // solution by Matti Virkkunen: http://stackoverflow.com/a/4881951
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
    }
      ,
    getDaysInMonth = function(year, month) {
        return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];
    }
      ,
    setToStartOfDay = function(date) {
        if (isDate(date))
            date.setHours(0, 0, 0, 0);
    }
      ,
    compareDates = function(a, b) {
        // weak date comparison (use setToStartOfDay(date) to ensure correct result)
        return a.getTime() === b.getTime();
    }
      ,
    extend = function(to, from, overwrite) {
        var prop, hasProp;
        for (prop in from) {
            hasProp = to[prop] !== undefined;
            if (hasProp && typeof from[prop] === 'object' && from[prop] !== null && from[prop].nodeName === undefined) {
                if (isDate(from[prop])) {
                    if (overwrite) {
                        to[prop] = new Date(from[prop].getTime());
                    }
                } else if (isArray(from[prop])) {
                    if (overwrite) {
                        to[prop] = from[prop].slice(0);
                    }
                } else {
                    to[prop] = extend({}, from[prop], overwrite);
                }
            } else if (overwrite || !hasProp) {
                to[prop] = from[prop];
            }
        }
        return to;
    }
      ,
    fireEvent = function(el, eventName, data) {
        var ev;

        if (document.createEvent) {
            ev = document.createEvent('HTMLEvents');
            ev.initEvent(eventName, true, false);
            ev = extend(ev, data);
            el.dispatchEvent(ev);
        } else if (document.createEventObject) {
            ev = document.createEventObject();
            ev = extend(ev, data);
            el.fireEvent('on' + eventName, ev);
        }
    }
      ,
    adjustCalendar = function(calendar) {
        if (calendar.month < 0) {
            calendar.year -= Math.ceil(Math.abs(calendar.month) / 12);
            calendar.month += 12;
        }
        if (calendar.month > 11) {
            calendar.year += Math.floor(Math.abs(calendar.month) / 12);
            calendar.month -= 12;
        }
        return calendar;
    }
      ,
    /**
     * defaults and localisation
     */
    defaults = {

        // bind the picker to a form field
        field: null,

        // automatically show/hide the picker on `field` focus (default `true` if `field` is set)
        bound: undefined,

        // position of the datepicker, relative to the field (default to bottom & left)
        // ('bottom' & 'left' keywords are not used, 'top' & 'right' are modifier on the bottom/left position)
        position: 'bottom left',

        // automatically fit in the viewport even if it means repositioning from the position option
        reposition: true,

        // the default output format for `.toString()` and `field` value
        format: 'YYYY-MM-DD',

        // the toString function which gets passed a current date object and format
        // and returns a string
        toString: null,

        // used to create date object from current input string
        parse: null,

        // the initial date to view when first opened
        defaultDate: null,

        // make the `defaultDate` the initial selected value
        setDefaultDate: false,

        // first day of week (0: Sunday, 1: Monday etc)
        firstDay: 0,

        // the default flag for moment's strict date parsing
        formatStrict: false,

        // the minimum/earliest date that can be selected
        minDate: null,
        // the maximum/latest date that can be selected
        maxDate: null,

        // number of years either side, or array of upper/lower range
        yearRange: 10,

        // show week numbers at head of row
        showWeekNumber: false,

        // Week picker mode
        pickWholeWeek: false,

        // used internally (don't config outside)
        minYear: 0,
        maxYear: 9999,
        minMonth: undefined,
        maxMonth: undefined,

        startRange: null,
        endRange: null,

        isRTL: false,

        // Additional text to append to the year in the calendar title
        yearSuffix: '',

        // Render the month after year in the calendar title
        showMonthAfterYear: false,

        // Render days of the calendar grid that fall in the next or previous month
        showDaysInNextAndPreviousMonths: false,

        // Allows user to select days that fall in the next or previous month
        enableSelectionDaysInNextAndPreviousMonths: false,

        // how many months are visible
        numberOfMonths: 1,

        // when numberOfMonths is used, this will help you to choose where the main calendar will be (default `left`, can be set to `right`)
        // only used for the first display or when a selected date is not visible
        mainCalendar: 'left',

        // Specify a DOM element to render the calendar in
        container: undefined,

        // Blur field when date is selected
        blurFieldOnSelect: true,

        // internationalization
        i18n: {
            previousMonth: 'Previous Month',
            nextMonth: 'Next Month',
            months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
            weekdays: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
            weekdaysShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
        },

        // Theme Classname
        theme: null,

        // events array
        events: [],

        // callback function
        onSelect: null,
        onOpen: null,
        onClose: null,
        onDraw: null
    }
      ,
    /**
     * templating functions to abstract HTML rendering
     */
    renderDayName = function(opts, day, abbr) {
        day += opts.firstDay;
        while (day >= 7) {
            day -= 7;
        }
        return abbr ? opts.i18n.weekdaysShort[day] : opts.i18n.weekdays[day];
    }
      ,
    renderDay = function(opts) {
        var arr = [];
        var ariaSelected = 'false';
        if (opts.isEmpty) {
            if (opts.showDaysInNextAndPreviousMonths) {
                arr.push('is-outside-current-month');

                if (!opts.enableSelectionDaysInNextAndPreviousMonths) {
                    arr.push('is-selection-disabled');
                }

            } else {
                return '<td class="is-empty"></td>';
            }
        }
        if (opts.isDisabled) {
            arr.push('is-disabled');
        }
        if (opts.isToday) {
            arr.push('is-today');
        }
        if (opts.isSelected) {
            arr.push('is-selected');
            ariaSelected = 'true';
        }
        if (opts.hasEvent) {
            arr.push('has-event');
        }
        if (opts.isInRange) {
            arr.push('is-inrange');
        }
        if (opts.isStartRange) {
            arr.push('is-startrange');
        }
        if (opts.isEndRange) {
            arr.push('is-endrange');
        }
        return '<td data-day="' + opts.day + '" class="' + arr.join(' ') + '" aria-selected="' + ariaSelected + '">' + '<button class="pika-button pika-day" type="button" ' + 'data-pika-year="' + opts.year + '" data-pika-month="' + opts.month + '" data-pika-day="' + opts.day + '">' + opts.day + '</button>' + '</td>';
    }
      ,
    renderWeek = function(d, m, y) {
        // Lifted from http://javascript.about.com/library/blweekyear.htm, lightly modified.
        var onejan = new Date(y,0,1)
          , weekNum = Math.ceil((((new Date(y,m,d) - onejan) / 86400000) + onejan.getDay() + 1) / 7);
        return '<td class="pika-week">' + weekNum + '</td>';
    }
      ,
    renderRow = function(days, isRTL, pickWholeWeek, isRowSelected) {
        return '<tr class="pika-row' + (pickWholeWeek ? ' pick-whole-week' : '') + (isRowSelected ? ' is-selected' : '') + '">' + (isRTL ? days.reverse() : days).join('') + '</tr>';
    }
      ,
    renderBody = function(rows) {
        return '<tbody>' + rows.join('') + '</tbody>';
    }
      ,
    renderHead = function(opts) {
        var i, arr = [];
        if (opts.showWeekNumber) {
            arr.push('<th></th>');
        }
        for (i = 0; i < 7; i++) {
            arr.push('<th scope="col"><abbr title="' + renderDayName(opts, i) + '">' + renderDayName(opts, i, true) + '</abbr></th>');
        }
        return '<thead><tr>' + (opts.isRTL ? arr.reverse() : arr).join('') + '</tr></thead>';
    }
      ,
    renderTitle = function(instance, c, year, month, refYear, randId) {
        var i, j, arr, opts = instance._o, isMinYear = year === opts.minYear, isMaxYear = year === opts.maxYear, html = '<div id="' + randId + '" class="pika-title" role="heading" aria-live="assertive">', monthHtml, yearHtml, prev = true, next = true;

        for (arr = [],
        i = 0; i < 12; i++) {
            arr.push('<option value="' + (year === refYear ? i - c : 12 + i - c) + '"' + (i === month ? ' selected="selected"' : '') + ((isMinYear && i < opts.minMonth) || (isMaxYear && i > opts.maxMonth) ? 'disabled="disabled"' : '') + '>' + opts.i18n.months[i] + '</option>');
        }

        monthHtml = '<div class="pika-label">' + opts.i18n.months[month] + '<select class="pika-select pika-select-month" tabindex="-1">' + arr.join('') + '</select></div>';

        if (isArray(opts.yearRange)) {
            i = opts.yearRange[0];
            j = opts.yearRange[1] + 1;
        } else {
            i = year - opts.yearRange;
            j = 1 + year + opts.yearRange;
        }

        for (arr = []; i < j && i <= opts.maxYear; i++) {
            if (i >= opts.minYear) {
                arr.push('<option value="' + i + '"' + (i === year ? ' selected="selected"' : '') + '>' + (i) + '</option>');
            }
        }
        yearHtml = '<div class="pika-label">' + year + opts.yearSuffix + '<select class="pika-select pika-select-year" tabindex="-1">' + arr.join('') + '</select></div>';

        if (opts.showMonthAfterYear) {
            html += yearHtml + monthHtml;
        } else {
            html += monthHtml + yearHtml;
        }

        if (isMinYear && (month === 0 || opts.minMonth >= month)) {
            prev = false;
        }

        if (isMaxYear && (month === 11 || opts.maxMonth <= month)) {
            next = false;
        }

        if (c === 0) {
            html += '<button class="pika-prev' + (prev ? '' : ' is-disabled') + '" type="button">' + opts.i18n.previousMonth + '</button>';
        }
        if (c === (instance._o.numberOfMonths - 1)) {
            html += '<button class="pika-next' + (next ? '' : ' is-disabled') + '" type="button">' + opts.i18n.nextMonth + '</button>';
        }

        return html += '</div>';
    }
      ,
    renderTable = function(opts, data, randId) {
        return '<table cellpadding="0" cellspacing="0" class="pika-table" role="grid" aria-labelledby="' + randId + '">' + renderHead(opts) + renderBody(data) + '</table>';
    }
      ,
    /**
     * Pikaday constructor
     */
    Pikaday = function(options) {
        var self = this
          , opts = self.config(options);

        self._onMouseDown = function(e) {
            if (!self._v) {
                return;
            }
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }

            if (!hasClass(target, 'is-disabled')) {
                if (hasClass(target, 'pika-button') && !hasClass(target, 'is-empty') && !hasClass(target.parentNode, 'is-disabled')) {
                    self.setDate(new Date(target.getAttribute('data-pika-year'),target.getAttribute('data-pika-month'),target.getAttribute('data-pika-day')));
                    if (opts.bound) {
                        sto(function() {
                            self.hide();
                            if (opts.blurFieldOnSelect && opts.field) {
                                opts.field.blur();
                            }
                        }, 100);
                    }
                } else if (hasClass(target, 'pika-prev')) {
                    self.prevMonth();
                } else if (hasClass(target, 'pika-next')) {
                    self.nextMonth();
                }
            }
            if (!hasClass(target, 'pika-select')) {
                // if this is touch event prevent mouse events emulation
                if (e.preventDefault) {
                    e.preventDefault();
                } else {
                    e.returnValue = false;
                    return false;
                }
            } else {
                self._c = true;
            }
        }
        ;

        self._onChange = function(e) {
            e = e || window.event;
            var target = e.target || e.srcElement;
            if (!target) {
                return;
            }
            if (hasClass(target, 'pika-select-month')) {
                self.gotoMonth(target.value);
            } else if (hasClass(target, 'pika-select-year')) {
                self.gotoYear(target.value);
            }
        }
        ;

        self._onKeyChange = function(e) {
            e = e || window.event;

            if (self.isVisible()) {

                switch (e.keyCode) {
                case 13:
                case 27:
                    if (opts.field) {
                        opts.field.blur();
                    }
                    break;
                case 37:
                    e.preventDefault();
                    self.adjustDate('subtract', 1);
                    break;
                case 38:
                    self.adjustDate('subtract', 7);
                    break;
                case 39:
                    self.adjustDate('add', 1);
                    break;
                case 40:
                    self.adjustDate('add', 7);
                    break;
                }
            }
        }
        ;

        self._onInputChange = function(e) {
            var date;

            if (e.firedBy === self) {
                return;
            }
            if (opts.parse) {
                date = opts.parse(opts.field.value, opts.format);
            } else if (hasMoment) {
                date = moment(opts.field.value, opts.format, opts.formatStrict);
                date = (date && date.isValid()) ? date.toDate() : null;
            } else {
                date = new Date(Date.parse(opts.field.value));
            }
            if (isDate(date)) {
                self.setDate(date);
            }
            if (!self._v) {
                self.show();
            }
        }
        ;

        self._onInputFocus = function() {
            self.show();
        }
        ;

        self._onInputClick = function() {
            self.show();
        }
        ;

        self._onInputBlur = function() {
            // IE allows pika div to gain focus; catch blur the input field
            var pEl = document.activeElement;
            do {
                if (hasClass(pEl, 'pika-single')) {
                    return;
                }
            } while ((pEl = pEl.parentNode));
            if (!self._c) {
                self._b = sto(function() {
                    self.hide();
                }, 50);
            }
            self._c = false;
        }
        ;

        self._onClick = function(e) {
            e = e || window.event;
            var target = e.target || e.srcElement
              , pEl = target;
            if (!target) {
                return;
            }
            if (!hasEventListeners && hasClass(target, 'pika-select')) {
                if (!target.onchange) {
                    target.setAttribute('onchange', 'return;');
                    addEvent(target, 'change', self._onChange);
                }
            }
            do {
                if (hasClass(pEl, 'pika-single') || pEl === opts.trigger) {
                    return;
                }
            } while ((pEl = pEl.parentNode));if (self._v && target !== opts.trigger && pEl !== opts.trigger) {
                self.hide();
            }
        }
        ;

        self.el = document.createElement('div');
        self.el.className = 'pika-single' + (opts.isRTL ? ' is-rtl' : '') + (opts.theme ? ' ' + opts.theme : '');

        addEvent(self.el, 'mousedown', self._onMouseDown, true);
        addEvent(self.el, 'touchend', self._onMouseDown, true);
        addEvent(self.el, 'change', self._onChange);
        addEvent(document, 'keydown', self._onKeyChange);

        if (opts.field) {
            if (opts.container) {
                opts.container.appendChild(self.el);
            } else if (opts.bound) {
                document.body.appendChild(self.el);
            } else {
                opts.field.parentNode.insertBefore(self.el, opts.field.nextSibling);
            }
            addEvent(opts.field, 'change', self._onInputChange);

            if (!opts.defaultDate) {
                if (hasMoment && opts.field.value) {
                    opts.defaultDate = moment(opts.field.value, opts.format).toDate();
                } else {
                    opts.defaultDate = new Date(Date.parse(opts.field.value));
                }
                opts.setDefaultDate = true;
            }
        }

        var defDate = opts.defaultDate;

        if (isDate(defDate)) {
            if (opts.setDefaultDate) {
                self.setDate(defDate, true);
            } else {
                self.gotoDate(defDate);
            }
        } else {
            self.gotoDate(new Date());
        }

        if (opts.bound) {
            this.hide();
            self.el.className += ' is-bound';
            addEvent(opts.trigger, 'click', self._onInputClick);
            addEvent(opts.trigger, 'focus', self._onInputFocus);
            addEvent(opts.trigger, 'blur', self._onInputBlur);
        } else {
            this.show();
        }
    };

    /**
     * public Pikaday API
     */
    Pikaday.prototype = {

        /**
         * configure functionality
         */
        config: function(options) {
            if (!this._o) {
                this._o = extend({}, defaults, true);
            }

            var opts = extend(this._o, options, true);

            opts.isRTL = !!opts.isRTL;

            opts.field = (opts.field && opts.field.nodeName) ? opts.field : null;

            opts.theme = (typeof opts.theme) === 'string' && opts.theme ? opts.theme : null;

            opts.bound = !!(opts.bound !== undefined ? opts.field && opts.bound : opts.field);

            opts.trigger = (opts.trigger && opts.trigger.nodeName) ? opts.trigger : opts.field;

            opts.disableWeekends = !!opts.disableWeekends;

            opts.disableDayFn = (typeof opts.disableDayFn) === 'function' ? opts.disableDayFn : null;

            var nom = parseInt(opts.numberOfMonths, 10) || 1;
            opts.numberOfMonths = nom > 4 ? 4 : nom;

            if (!isDate(opts.minDate)) {
                opts.minDate = false;
            }
            if (!isDate(opts.maxDate)) {
                opts.maxDate = false;
            }
            if ((opts.minDate && opts.maxDate) && opts.maxDate < opts.minDate) {
                opts.maxDate = opts.minDate = false;
            }
            if (opts.minDate) {
                this.setMinDate(opts.minDate);
            }
            if (opts.maxDate) {
                this.setMaxDate(opts.maxDate);
            }

            if (isArray(opts.yearRange)) {
                var fallback = new Date().getFullYear() - 10;
                opts.yearRange[0] = parseInt(opts.yearRange[0], 10) || fallback;
                opts.yearRange[1] = parseInt(opts.yearRange[1], 10) || fallback;
            } else {
                opts.yearRange = Math.abs(parseInt(opts.yearRange, 10)) || defaults.yearRange;
                if (opts.yearRange > 100) {
                    opts.yearRange = 100;
                }
            }

            return opts;
        },

        /**
         * return a formatted string of the current selection (using Moment.js if available)
         */
        toString: function(format) {
            format = format || this._o.format;
            if (!isDate(this._d)) {
                return '';
            }
            if (this._o.toString) {
                return this._o.toString(this._d, format);
            }
            if (hasMoment) {
                return moment(this._d).format(format);
            }
            return this._d.toDateString();
        },

        /**
         * return a Moment.js object of the current selection (if available)
         */
        getMoment: function() {
            return hasMoment ? moment(this._d) : null;
        },

        /**
         * set the current selection from a Moment.js object (if available)
         */
        setMoment: function(date, preventOnSelect) {
            if (hasMoment && moment.isMoment(date)) {
                this.setDate(date.toDate(), preventOnSelect);
            }
        },

        /**
         * return a Date object of the current selection
         */
        getDate: function() {
            return isDate(this._d) ? new Date(this._d.getTime()) : null;
        },

        /**
         * set the current selection
         */
        setDate: function(date, preventOnSelect) {
            if (!date) {
                this._d = null;

                if (this._o.field) {
                    this._o.field.value = '';
                    fireEvent(this._o.field, 'change', {
                        firedBy: this
                    });
                }

                return this.draw();
            }
            if (typeof date === 'string') {
                date = new Date(Date.parse(date));
            }
            if (!isDate(date)) {
                return;
            }

            var min = this._o.minDate
              , max = this._o.maxDate;

            if (isDate(min) && date < min) {
                date = min;
            } else if (isDate(max) && date > max) {
                date = max;
            }

            this._d = new Date(date.getTime());
            setToStartOfDay(this._d);
            this.gotoDate(this._d);

            if (this._o.field) {
                this._o.field.value = this.toString();
                fireEvent(this._o.field, 'change', {
                    firedBy: this
                });
            }
            if (!preventOnSelect && typeof this._o.onSelect === 'function') {
                this._o.onSelect.call(this, this.getDate());
            }
        },

        /**
         * change view to a specific date
         */
        gotoDate: function(date) {
            var newCalendar = true;

            if (!isDate(date)) {
                return;
            }

            if (this.calendars) {
                var firstVisibleDate = new Date(this.calendars[0].year,this.calendars[0].month,1)
                  , lastVisibleDate = new Date(this.calendars[this.calendars.length - 1].year,this.calendars[this.calendars.length - 1].month,1)
                  , visibleDate = date.getTime();
                // get the end of the month
                lastVisibleDate.setMonth(lastVisibleDate.getMonth() + 1);
                lastVisibleDate.setDate(lastVisibleDate.getDate() - 1);
                newCalendar = (visibleDate < firstVisibleDate.getTime() || lastVisibleDate.getTime() < visibleDate);
            }

            if (newCalendar) {
                this.calendars = [{
                    month: date.getMonth(),
                    year: date.getFullYear()
                }];
                if (this._o.mainCalendar === 'right') {
                    this.calendars[0].month += 1 - this._o.numberOfMonths;
                }
            }

            this.adjustCalendars();
        },

        adjustDate: function(sign, days) {

            var day = this.getDate() || new Date();
            var difference = parseInt(days) * 24 * 60 * 60 * 1000;

            var newDay;

            if (sign === 'add') {
                newDay = new Date(day.valueOf() + difference);
            } else if (sign === 'subtract') {
                newDay = new Date(day.valueOf() - difference);
            }

            this.setDate(newDay);
        },

        adjustCalendars: function() {
            this.calendars[0] = adjustCalendar(this.calendars[0]);
            for (var c = 1; c < this._o.numberOfMonths; c++) {
                this.calendars[c] = adjustCalendar({
                    month: this.calendars[0].month + c,
                    year: this.calendars[0].year
                });
            }
            this.draw();
        },

        gotoToday: function() {
            this.gotoDate(new Date());
        },

        /**
         * change view to a specific month (zero-index, e.g. 0: January)
         */
        gotoMonth: function(month) {
            if (!isNaN(month)) {
                this.calendars[0].month = parseInt(month, 10);
                this.adjustCalendars();
            }
        },

        nextMonth: function() {
            this.calendars[0].month++;
            this.adjustCalendars();
        },

        prevMonth: function() {
            this.calendars[0].month--;
            this.adjustCalendars();
        },

        /**
         * change view to a specific full year (e.g. "2012")
         */
        gotoYear: function(year) {
            if (!isNaN(year)) {
                this.calendars[0].year = parseInt(year, 10);
                this.adjustCalendars();
            }
        },

        /**
         * change the minDate
         */
        setMinDate: function(value) {
            if (value instanceof Date) {
                setToStartOfDay(value);
                this._o.minDate = value;
                this._o.minYear = value.getFullYear();
                this._o.minMonth = value.getMonth();
            } else {
                this._o.minDate = defaults.minDate;
                this._o.minYear = defaults.minYear;
                this._o.minMonth = defaults.minMonth;
                this._o.startRange = defaults.startRange;
            }

            this.draw();
        },

        /**
         * change the maxDate
         */
        setMaxDate: function(value) {
            if (value instanceof Date) {
                setToStartOfDay(value);
                this._o.maxDate = value;
                this._o.maxYear = value.getFullYear();
                this._o.maxMonth = value.getMonth();
            } else {
                this._o.maxDate = defaults.maxDate;
                this._o.maxYear = defaults.maxYear;
                this._o.maxMonth = defaults.maxMonth;
                this._o.endRange = defaults.endRange;
            }

            this.draw();
        },

        setStartRange: function(value) {
            this._o.startRange = value;
        },

        setEndRange: function(value) {
            this._o.endRange = value;
        },

        /**
         * refresh the HTML
         */
        draw: function(force) {
            if (!this._v && !force) {
                return;
            }
            var opts = this._o, minYear = opts.minYear, maxYear = opts.maxYear, minMonth = opts.minMonth, maxMonth = opts.maxMonth, html = '', randId;

            if (this._y <= minYear) {
                this._y = minYear;
                if (!isNaN(minMonth) && this._m < minMonth) {
                    this._m = minMonth;
                }
            }
            if (this._y >= maxYear) {
                this._y = maxYear;
                if (!isNaN(maxMonth) && this._m > maxMonth) {
                    this._m = maxMonth;
                }
            }

            randId = 'pika-title-' + Math.random().toString(36).replace(/[^a-z]+/g, '').substr(0, 2);

            for (var c = 0; c < opts.numberOfMonths; c++) {
                html += '<div class="pika-lendar">' + renderTitle(this, c, this.calendars[c].year, this.calendars[c].month, this.calendars[0].year, randId) + this.render(this.calendars[c].year, this.calendars[c].month, randId) + '</div>';
            }

            this.el.innerHTML = html;

            if (opts.bound) {
                if (opts.field.type !== 'hidden') {
                    sto(function() {
                        opts.trigger.focus();
                    }, 1);
                }
            }

            if (typeof this._o.onDraw === 'function') {
                this._o.onDraw(this);
            }

            if (opts.bound) {
                // let the screen reader user know to use arrow keys
                opts.field.setAttribute('aria-label', 'Use the arrow keys to pick a date');
            }
        },

        adjustPosition: function() {
            var field, pEl, width, height, viewportWidth, viewportHeight, scrollTop, left, top, clientRect;

            if (this._o.container)
                return;

            this.el.style.position = 'absolute';

            field = this._o.trigger;
            pEl = field;
            width = this.el.offsetWidth;
            height = this.el.offsetHeight;
            viewportWidth = window.innerWidth || document.documentElement.clientWidth;
            viewportHeight = window.innerHeight || document.documentElement.clientHeight;
            scrollTop = window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop;

            if (typeof field.getBoundingClientRect === 'function') {
                clientRect = field.getBoundingClientRect();
                left = clientRect.left + window.pageXOffset;
                top = clientRect.bottom + window.pageYOffset;
            } else {
                left = pEl.offsetLeft;
                top = pEl.offsetTop + pEl.offsetHeight;
                while ((pEl = pEl.offsetParent)) {
                    left += pEl.offsetLeft;
                    top += pEl.offsetTop;
                }
            }

            // default position is bottom & left
            if ((this._o.reposition && left + width > viewportWidth) || (this._o.position.indexOf('right') > -1 && left - width + field.offsetWidth > 0)) {
                left = left - width + field.offsetWidth;
            }
            if ((this._o.reposition && top + height > viewportHeight + scrollTop) || (this._o.position.indexOf('top') > -1 && top - height - field.offsetHeight > 0)) {
                top = top - height - field.offsetHeight;
            }

            this.el.style.left = left + 'px';
            this.el.style.top = top + 'px';
        },

        /**
         * render HTML for a particular month
         */
        render: function(year, month, randId) {
            var opts = this._o
              , now = new Date()
              , days = getDaysInMonth(year, month)
              , before = new Date(year,month,1).getDay()
              , data = []
              , row = [];
            setToStartOfDay(now);
            if (opts.firstDay > 0) {
                before -= opts.firstDay;
                if (before < 0) {
                    before += 7;
                }
            }
            var previousMonth = month === 0 ? 11 : month - 1
              , nextMonth = month === 11 ? 0 : month + 1
              , yearOfPreviousMonth = month === 0 ? year - 1 : year
              , yearOfNextMonth = month === 11 ? year + 1 : year
              , daysInPreviousMonth = getDaysInMonth(yearOfPreviousMonth, previousMonth);
            var cells = days + before
              , after = cells;
            while (after > 7) {
                after -= 7;
            }
            cells += 7 - after;
            var isWeekSelected = false;
            for (var i = 0, r = 0; i < cells; i++) {
                var day = new Date(year,month,1 + (i - before))
                  , isSelected = isDate(this._d) ? compareDates(day, this._d) : false
                  , isToday = compareDates(day, now)
                  , hasEvent = opts.events.indexOf(day.toDateString()) !== -1 ? true : false
                  , isEmpty = i < before || i >= (days + before)
                  , dayNumber = 1 + (i - before)
                  , monthNumber = month
                  , yearNumber = year
                  , isStartRange = opts.startRange && compareDates(opts.startRange, day)
                  , isEndRange = opts.endRange && compareDates(opts.endRange, day)
                  , isInRange = opts.startRange && opts.endRange && opts.startRange < day && day < opts.endRange
                  , isDisabled = (opts.minDate && day < opts.minDate) || (opts.maxDate && day > opts.maxDate) || (opts.disableWeekends && isWeekend(day)) || (opts.disableDayFn && opts.disableDayFn(day));

                if (isEmpty) {
                    if (i < before) {
                        dayNumber = daysInPreviousMonth + dayNumber;
                        monthNumber = previousMonth;
                        yearNumber = yearOfPreviousMonth;
                    } else {
                        dayNumber = dayNumber - days;
                        monthNumber = nextMonth;
                        yearNumber = yearOfNextMonth;
                    }
                }

                var dayConfig = {
                    day: dayNumber,
                    month: monthNumber,
                    year: yearNumber,
                    hasEvent: hasEvent,
                    isSelected: isSelected,
                    isToday: isToday,
                    isDisabled: isDisabled,
                    isEmpty: isEmpty,
                    isStartRange: isStartRange,
                    isEndRange: isEndRange,
                    isInRange: isInRange,
                    showDaysInNextAndPreviousMonths: opts.showDaysInNextAndPreviousMonths,
                    enableSelectionDaysInNextAndPreviousMonths: opts.enableSelectionDaysInNextAndPreviousMonths
                };

                if (opts.pickWholeWeek && isSelected) {
                    isWeekSelected = true;
                }

                row.push(renderDay(dayConfig));

                if (++r === 7) {
                    if (opts.showWeekNumber) {
                        row.unshift(renderWeek(i - before, month, year));
                    }
                    data.push(renderRow(row, opts.isRTL, opts.pickWholeWeek, isWeekSelected));
                    row = [];
                    r = 0;
                    isWeekSelected = false;
                }
            }
            return renderTable(opts, data, randId);
        },

        isVisible: function() {
            return this._v;
        },

        show: function() {
            if (!this.isVisible()) {
                this._v = true;
                this.draw();
                removeClass(this.el, 'is-hidden');
                if (this._o.bound) {
                    addEvent(document, 'click', this._onClick);
                    this.adjustPosition();
                }
                if (typeof this._o.onOpen === 'function') {
                    this._o.onOpen.call(this);
                }
            }
        },

        hide: function() {
            var v = this._v;
            if (v !== false) {
                if (this._o.bound) {
                    removeEvent(document, 'click', this._onClick);
                }
                this.el.style.position = 'static';
                // reset
                this.el.style.left = 'auto';
                this.el.style.top = 'auto';
                addClass(this.el, 'is-hidden');
                this._v = false;
                if (v !== undefined && typeof this._o.onClose === 'function') {
                    this._o.onClose.call(this);
                }
            }
        },

        /**
         * GAME OVER
         */
        destroy: function() {
            this.hide();
            removeEvent(this.el, 'mousedown', this._onMouseDown, true);
            removeEvent(this.el, 'touchend', this._onMouseDown, true);
            removeEvent(this.el, 'change', this._onChange);
            removeEvent(document, 'keydown', this._onKeyChange);
            if (this._o.field) {
                removeEvent(this._o.field, 'change', this._onInputChange);
                if (this._o.bound) {
                    removeEvent(this._o.trigger, 'click', this._onInputClick);
                    removeEvent(this._o.trigger, 'focus', this._onInputFocus);
                    removeEvent(this._o.trigger, 'blur', this._onInputBlur);
                }
            }
            if (this.el.parentNode) {
                this.el.parentNode.removeChild(this.el);
            }
        }

    };

    return Pikaday;

}));

var megamenus = {};
var lastMegamenu = {
    menu: false,
    timeout: false
};

function hideMegamenu() {
    try {
        lastMegamenu.menu.hide();
        clearInterval(lastMegamenu.timeout);
    } catch (e) {}
}

jQuery(document).ready(function() {
    var desktopResponder = function() {
        for (var toggle in megamenus) {
            var menu = jQuery($(megamenus[toggle]));
            toggle = jQuery($(toggle));
            var page = jQuery('body');

            toggle.mouseover(function() {
                hideMegamenu();
                var currentMenu = jQuery($(megamenus[this.id]));
                var up = currentMenu.children('.up-arrow');

                // Don't allow escape off left
                var ml = currentMenu.offset().left;
                var pl = page.offset().left;
                var mw = currentMenu.width();
                var pw = page.width();

                if (ml < pl)
                    currentMenu.css('left', pl);

                // Don't allow escape off right
                if (ml + mw > pl + pw) {
                    currentMenu.css('left', (pl + pw) - (mw));
                }

                currentMenu.show();
                up.css('left', jQuery(this).offset().left + jQuery(this).width() / 2 - up.width() / 2 - currentMenu.offset().left);
            });

            toggle.mouseout(function() {
                lastMegamenu.menu = jQuery('.megamenu:visible');
                lastMegamenu.timeout = setTimeout('hideMegamenu()', 500);
            });

            menu.mouseout(function() {
                lastMegamenu.menu = jQuery(this);
                lastMegamenu.timeout = setTimeout('hideMegamenu()', 500);
            });

            menu.mouseover(function() {
                clearTimeout(lastMegamenu.timeout);
            });
        }
    };

    var megamenuResponsivity = new responsivity({
        listeners: {
            desktop: [desktopResponder],
            mobile: []
        },
        mobileBreakpoint: 700
    });

    megamenuResponsivity.checkIsMobile(true);

});
/* Initialise the modal here, method should only be initialised and shown if modal popup is required
 *
 * @param Modal Container ID
 * @param Overlay ID
 */

var FolkModal = {
    id: '#modal',
    el: null,
    active: false,
    padding: 0,
    speed: 500,
    mask: {
        id: '#overlay',
        width: null,
        height: null,
        el: null
    },
    window: {
        width: null,
        height: null
    },
    close: {
        el: null,
        id: '#modal-close'
    },

    init: function(id, overlayId, closeId) {
        FolkModal.id = id;
        FolkModal.mask.id = overlayId;
        FolkModal.close.id = closeId;

        FolkModal.el = jQuery(id);
        FolkModal.mask.el = jQuery(overlayId);
        FolkModal.close.el = jQuery(closeId);

        FolkModal.mask.width = jQuery(document).width();
        FolkModal.mask.height = jQuery(document).height();
        FolkModal.window.width = jQuery(window).width();
        FolkModal.window.height = jQuery(window).height();

        FolkModal.mask.el.click(FolkModal.hide);
        FolkModal.close.el.click(FolkModal.hide);
        jQuery(window).resize(FolkModal.resize);
    },
    resize: function() {
        FolkModal.window.height = jQuery(window).height();
        FolkModal.window.width = jQuery(window).width()
        var modalTop = FolkModal.window.height / 2 - (FolkModal.el.height() + FolkModal.padding) / 2
        if (modalTop < 0) {
            modalTop = 0;
        }

        var modalLeft = FolkModal.window.width / 2 - (FolkModal.el.width() + FolkModal.padding) / 2
        if (modalLeft < 0) {
            modalLeft = 0;
        }

        FolkModal.el.css({
            'top': modalTop,
            'left': modalLeft
        });

        FolkModal.mask.el.css({
            'width': FolkModal.window.width,
            'height': FolkModal.window.height
        });
    },
    show: function() {
        FolkModal.active = true;
        FolkModal.mask.el.css({
            'width': FolkModal.mask.width,
            'height': FolkModal.mask.height
        });

        FolkModal.resize();

        FolkModal.mask.el.fadeIn(FolkModal.speed);
        FolkModal.el.fadeIn(FolkModal.speed);
    },
    hide: function() {
        if (FolkModal.mask.el.hasClass('prevent-close'))
            return false;

        FolkModal.el.fadeOut(FolkModal.speed / 2);
        FolkModal.mask.el.fadeOut(FolkModal.speed / 2);

        FolkModal.active = false;
    }
};
/*

Responsivity 0.1.1 by Aneurin "Anny" Barker Snook http://anny.fm
Creative Commons licensed (CC BY-SA 3.0) http://creativecommons.org/licenses/by-sa/3.0/deed.en_US

*/

function responsivity(args) {
    this.state = {
        listeners: {
            desktop: [],
            mobile: []
        },
        isMobile: false,
        mobileBreakpoint: 480,
        onResize: null
    };

    var i;
    for (i in args) {
        this.state[i] = args[i];
    }
}
;
responsivity.prototype.checkIsMobile = function(forceDispatch) {
    var dispatch;
    if (dispatch = (this.state.isMobile != window.innerWidth < this.state.mobileBreakpoint)) {
        this.state.isMobile = !this.state.isMobile;
    }
    if (dispatch || forceDispatch) {
        this.dispatch(this.state.isMobile ? 'mobile' : 'desktop');
    }
}
;

responsivity.prototype.bind = function(trigger, func) {
    this.state.listeners[trigger].push(func);
}
;

responsivity.prototype.dispatch = function(trigger) {
    var i;
    for (i in this.state.listeners[trigger]) {
        try {
            var f = this.state.listeners[trigger][i];
            f();
        } catch (e) {}
    }
}
;

responsivity.prototype.isMobile = function() {
    return this.state.isMobile;
}
;

responsivity.prototype.updateOnResize = function(update, forceDispatch, el) {
    if (!el)
        el = this;

    try {
        if (update) {
            this.state.onResize = function() {
                el.checkIsMobile(forceDispatch);
            }
            ;

            window.addEventListener('resize', this.state.onResize);
        } else {
            window.removeEventListener('resize', this.state.onResize);
        }
    } catch (e) {}
}
;

responsivity.prototype.hasTouch = function() {
    return 'ontouchstart'in document.documentElement;
}
;
/*!
 * jQuery Cookie Plugin v1.4.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function(factory) {
    if (typeof define === 'function' && define.amd) {
        // AMD
        define(['jquery'], factory);
    } else if (typeof exports === 'object') {
        // CommonJS
        factory(require('jquery'));
    } else {
        // Browser globals
        factory(jQuery);
    }
}(function($) {

    var pluses = /\+/g;

    function encode(s) {
        return config.raw ? s : encodeURIComponent(s);
    }

    function decode(s) {
        return config.raw ? s : decodeURIComponent(s);
    }

    function stringifyCookieValue(value) {
        return encode(config.json ? JSON.stringify(value) : String(value));
    }

    function parseCookieValue(s) {
        if (s.indexOf('"') === 0) {
            // This is a quoted cookie as according to RFC2068, unescape...
            s = s.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
        }

        try {
            // Replace server-side written pluses with spaces.
            // If we can't decode the cookie, ignore it, it's unusable.
            // If we can't parse the cookie, ignore it, it's unusable.
            s = decodeURIComponent(s.replace(pluses, ' '));
            return config.json ? JSON.parse(s) : s;
        } catch (e) {}
    }

    function read(s, converter) {
        var value = config.raw ? s : parseCookieValue(s);
        return $.isFunction(converter) ? converter(value) : value;
    }

    var config = $.cookie = function(key, value, options) {

        // Write

        if (value !== undefined && !$.isFunction(value)) {
            options = $.extend({}, config.defaults, options);

            if (typeof options.expires === 'number') {
                var days = options.expires
                  , t = options.expires = new Date();
                t.setTime(+t + days * 864e+5);
            }

            return (document.cookie = [encode(key), '=', stringifyCookieValue(value), options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
            options.path ? '; path=' + options.path : '', options.domain ? '; domain=' + options.domain : '', options.secure ? '; secure' : ''].join(''));
        }

        // Read

        var result = key ? undefined : {};

        // To prevent the for loop in the first place assign an empty array
        // in case there are no cookies at all. Also prevents odd result when
        // calling $.cookie().
        var cookies = document.cookie ? document.cookie.split('; ') : [];

        for (var i = 0, l = cookies.length; i < l; i++) {
            var parts = cookies[i].split('=');
            var name = decode(parts.shift());
            var cookie = parts.join('=');

            if (key && key === name) {
                // If second argument (value) is a function it's a converter...
                result = read(cookie, value);
                break;
            }

            // Prevent storing a cookie that we couldn't decode.
            if (!key && (cookie = read(cookie)) !== undefined) {
                result[name] = cookie;
            }
        }

        return result;
    }
    ;

    config.defaults = {};

    $.removeCookie = function(key, options) {
        if ($.cookie(key) === undefined) {
            return false;
        }

        // Must not alter options, thus extending a fresh object...
        $.cookie(key, '', $.extend({}, options, {
            expires: -1
        }));
        return !$.cookie(key);
    }
    ;

}));

/*!
 * jCarousel - Riding carousels with jQuery
 *   http://sorgalla.com/jcarousel/
 *
 * Copyright (c) 2006 Jan Sorgalla (http://sorgalla.com)
 * Dual licensed under the MIT (http://www.opensource.org/licenses/mit-license.php)
 * and GPL (http://www.opensource.org/licenses/gpl-license.php) licenses.
 *
 * Built on top of the jQuery library
 *   http://jquery.com
 *
 * Inspired by the "Carousel Component" by Bill Scott
 *   http://billwscott.com/carousel/
 */
(function(g) {
    var q = {
        vertical: !1,
        rtl: !1,
        start: 1,
        offset: 1,
        size: null,
        scroll: 3,
        visible: null,
        animation: "normal",
        easing: "swing",
        auto: 0,
        wrap: null,
        initCallback: null,
        setupCallback: null,
        reloadCallback: null,
        itemLoadCallback: null,
        itemFirstInCallback: null,
        itemFirstOutCallback: null,
        itemLastInCallback: null,
        itemLastOutCallback: null,
        itemVisibleInCallback: null,
        itemVisibleOutCallback: null,
        animationStepCallback: null,
        buttonNextHTML: "<div></div>",
        buttonPrevHTML: "<div></div>",
        buttonNextEvent: "click",
        buttonPrevEvent: "click",
        buttonNextCallback: null,
        buttonPrevCallback: null,
        itemFallbackDimension: null
    }
      , m = !1;
    g(window).bind("load.jcarousel", function() {
        m = !0
    });
    g.jcarousel = function(a, c) {
        this.options = g.extend({}, q, c || {});
        this.autoStopped = this.locked = !1;
        this.buttonPrevState = this.buttonNextState = this.buttonPrev = this.buttonNext = this.list = this.clip = this.container = null;
        if (!c || c.rtl === void 0)
            this.options.rtl = (g(a).attr("dir") || g("html").attr("dir") || "").toLowerCase() == "rtl";
        this.wh = !this.options.vertical ? "width" : "height";
        this.lt = !this.options.vertical ? this.options.rtl ? "right" : "left" : "top";
        for (var b = "", d = a.className.split(" "), f = 0; f < d.length; f++)
            if (d[f].indexOf("jcarousel-skin") != -1) {
                g(a).removeClass(d[f]);
                b = d[f];
                break
            }
        a.nodeName.toUpperCase() == "UL" || a.nodeName.toUpperCase() == "OL" ? (this.list = g(a),
        this.clip = this.list.parents(".jcarousel-clip"),
        this.container = this.list.parents(".jcarousel-container")) : (this.container = g(a),
        this.list = this.container.find("ul,ol").eq(0),
        this.clip = this.container.find(".jcarousel-clip"));
        if (this.clip.size() === 0)
            this.clip = this.list.wrap("<div></div>").parent();
        if (this.container.size() === 0)
            this.container = this.clip.wrap("<div></div>").parent();
        b !== "" && this.container.parent()[0].className.indexOf("jcarousel-skin") == -1 && this.container.wrap('<div class=" ' + b + '"></div>');
        this.buttonPrev = g(".jcarousel-prev", this.container);
        if (this.buttonPrev.size() === 0 && this.options.buttonPrevHTML !== null)
            this.buttonPrev = g(this.options.buttonPrevHTML).appendTo(this.container);
        this.buttonPrev.addClass(this.className("jcarousel-prev"));
        this.buttonNext = g(".jcarousel-next", this.container);
        if (this.buttonNext.size() === 0 && this.options.buttonNextHTML !== null)
            this.buttonNext = g(this.options.buttonNextHTML).appendTo(this.container);
        this.buttonNext.addClass(this.className("jcarousel-next"));
        this.clip.addClass(this.className("jcarousel-clip")).css({
            position: "relative"
        });
        this.list.addClass(this.className("jcarousel-list")).css({
            overflow: "hidden",
            position: "relative",
            top: 0,
            margin: 0,
            padding: 0
        }).css(this.options.rtl ? "right" : "left", 0);
        this.container.addClass(this.className("jcarousel-container")).css({
            position: "relative"
        });
        !this.options.vertical && this.options.rtl && this.container.addClass("jcarousel-direction-rtl").attr("dir", "rtl");
        var j = this.options.visible !== null ? Math.ceil(this.clipping() / this.options.visible) : null
          , b = this.list.children("li")
          , e = this;
        if (b.size() > 0) {
            var h = 0
              , i = this.options.offset;
            b.each(function() {
                e.format(this, i++);
                h += e.dimension(this, j)
            });
            this.list.css(this.wh, h + 100 + "px");
            if (!c || c.size === void 0)
                this.options.size = b.size()
        }
        this.container.css("display", "block");
        this.buttonNext.css("display", "block");
        this.buttonPrev.css("display", "block");
        this.funcNext = function() {
            e.next()
        }
        ;
        this.funcPrev = function() {
            e.prev()
        }
        ;
        this.funcResize = function() {
            e.resizeTimer && clearTimeout(e.resizeTimer);
            e.resizeTimer = setTimeout(function() {
                e.reload()
            }, 100)
        }
        ;
        this.options.initCallback !== null && this.options.initCallback(this, "init");
        !m && g.browser.safari ? (this.buttons(!1, !1),
        g(window).bind("load.jcarousel", function() {
            e.setup()
        })) : this.setup()
    }
    ;
    var f = g.jcarousel;
    f.fn = f.prototype = {
        jcarousel: "0.2.8"
    };
    f.fn.extend = f.extend = g.extend;
    f.fn.extend({
        setup: function() {
            this.prevLast = this.prevFirst = this.last = this.first = null;
            this.animating = !1;
            this.tail = this.resizeTimer = this.timer = null;
            this.inTail = !1;
            if (!this.locked) {
                this.list.css(this.lt, this.pos(this.options.offset) + "px");
                var a = this.pos(this.options.start, !0);
                this.prevFirst = this.prevLast = null;
                this.animate(a, !1);
                g(window).unbind("resize.jcarousel", this.funcResize).bind("resize.jcarousel", this.funcResize);
                this.options.setupCallback !== null && this.options.setupCallback(this)
            }
        },
        reset: function() {
            this.list.empty();
            this.list.css(this.lt, "0px");
            this.list.css(this.wh, "10px");
            this.options.initCallback !== null && this.options.initCallback(this, "reset");
            this.setup()
        },
        reload: function() {
            this.tail !== null && this.inTail && this.list.css(this.lt, f.intval(this.list.css(this.lt)) + this.tail);
            this.tail = null;
            this.inTail = !1;
            this.options.reloadCallback !== null && this.options.reloadCallback(this);
            if (this.options.visible !== null) {
                var a = this
                  , c = Math.ceil(this.clipping() / this.options.visible)
                  , b = 0
                  , d = 0;
                this.list.children("li").each(function(f) {
                    b += a.dimension(this, c);
                    f + 1 < a.first && (d = b)
                });
                this.list.css(this.wh, b + "px");
                this.list.css(this.lt, -d + "px")
            }
            this.scroll(this.first, !1)
        },
        lock: function() {
            this.locked = !0;
            this.buttons()
        },
        unlock: function() {
            this.locked = !1;
            this.buttons()
        },
        size: function(a) {
            if (a !== void 0)
                this.options.size = a,
                this.locked || this.buttons();
            return this.options.size
        },
        has: function(a, c) {
            if (c === void 0 || !c)
                c = a;
            if (this.options.size !== null && c > this.options.size)
                c = this.options.size;
            for (var b = a; b <= c; b++) {
                var d = this.get(b);
                if (!d.length || d.hasClass("jcarousel-item-placeholder"))
                    return !1
            }
            return !0
        },
        get: function(a) {
            return g(">.jcarousel-item-" + a, this.list)
        },
        add: function(a, c) {
            var b = this.get(a)
              , d = 0
              , p = g(c);
            if (b.length === 0)
                for (var j, e = f.intval(a), b = this.create(a); ; ) {
                    if (j = this.get(--e),
                    e <= 0 || j.length) {
                        e <= 0 ? this.list.prepend(b) : j.after(b);
                        break
                    }
                }
            else
                d = this.dimension(b);
            p.get(0).nodeName.toUpperCase() == "LI" ? (b.replaceWith(p),
            b = p) : b.empty().append(c);
            this.format(b.removeClass(this.className("jcarousel-item-placeholder")), a);
            p = this.options.visible !== null ? Math.ceil(this.clipping() / this.options.visible) : null;
            d = this.dimension(b, p) - d;
            a > 0 && a < this.first && this.list.css(this.lt, f.intval(this.list.css(this.lt)) - d + "px");
            this.list.css(this.wh, f.intval(this.list.css(this.wh)) + d + "px");
            return b
        },
        remove: function(a) {
            var c = this.get(a);
            if (c.length && !(a >= this.first && a <= this.last)) {
                var b = this.dimension(c);
                a < this.first && this.list.css(this.lt, f.intval(this.list.css(this.lt)) + b + "px");
                c.remove();
                this.list.css(this.wh, f.intval(this.list.css(this.wh)) - b + "px")
            }
        },
        next: function() {
            this.tail !== null && !this.inTail ? this.scrollTail(!1) : this.scroll((this.options.wrap == "both" || this.options.wrap == "last") && this.options.size !== null && this.last == this.options.size ? 1 : this.first + this.options.scroll)
        },
        prev: function() {
            this.tail !== null && this.inTail ? this.scrollTail(!0) : this.scroll((this.options.wrap == "both" || this.options.wrap == "first") && this.options.size !== null && this.first == 1 ? this.options.size : this.first - this.options.scroll)
        },
        scrollTail: function(a) {
            if (!this.locked && !this.animating && this.tail) {
                this.pauseAuto();
                var c = f.intval(this.list.css(this.lt))
                  , c = !a ? c - this.tail : c + this.tail;
                this.inTail = !a;
                this.prevFirst = this.first;
                this.prevLast = this.last;
                this.animate(c)
            }
        },
        scroll: function(a, c) {
            !this.locked && !this.animating && (this.pauseAuto(),
            this.animate(this.pos(a), c))
        },
        pos: function(a, c) {
            var b = f.intval(this.list.css(this.lt));
            if (this.locked || this.animating)
                return b;
            this.options.wrap != "circular" && (a = a < 1 ? 1 : this.options.size && a > this.options.size ? this.options.size : a);
            for (var d = this.first > a, g = this.options.wrap != "circular" && this.first <= 1 ? 1 : this.first, j = d ? this.get(g) : this.get(this.last), e = d ? g : g - 1, h = null, i = 0, k = !1, l = 0; d ? --e >= a : ++e < a; ) {
                h = this.get(e);
                k = !h.length;
                if (h.length === 0 && (h = this.create(e).addClass(this.className("jcarousel-item-placeholder")),
                j[d ? "before" : "after"](h),
                this.first !== null && this.options.wrap == "circular" && this.options.size !== null && (e <= 0 || e > this.options.size)))
                    j = this.get(this.index(e)),
                    j.length && (h = this.add(e, j.clone(!0)));
                j = h;
                l = this.dimension(h);
                k && (i += l);
                if (this.first !== null && (this.options.wrap == "circular" || e >= 1 && (this.options.size === null || e <= this.options.size)))
                    b = d ? b + l : b - l
            }
            for (var g = this.clipping(), m = [], o = 0, n = 0, j = this.get(a - 1), e = a; ++o; ) {
                h = this.get(e);
                k = !h.length;
                if (h.length === 0) {
                    h = this.create(e).addClass(this.className("jcarousel-item-placeholder"));
                    if (j.length === 0)
                        this.list.prepend(h);
                    else
                        j[d ? "before" : "after"](h);
                    if (this.first !== null && this.options.wrap == "circular" && this.options.size !== null && (e <= 0 || e > this.options.size))
                        j = this.get(this.index(e)),
                        j.length && (h = this.add(e, j.clone(!0)))
                }
                j = h;
                l = this.dimension(h);
                if (l === 0)
                    throw Error("jCarousel: No width/height set for items. This will cause an infinite loop. Aborting...");
                this.options.wrap != "circular" && this.options.size !== null && e > this.options.size ? m.push(h) : k && (i += l);
                n += l;
                if (n >= g)
                    break;
                e++
            }
            for (h = 0; h < m.length; h++)
                m[h].remove();
            i > 0 && (this.list.css(this.wh, this.dimension(this.list) + i + "px"),
            d && (b -= i,
            this.list.css(this.lt, f.intval(this.list.css(this.lt)) - i + "px")));
            i = a + o - 1;
            if (this.options.wrap != "circular" && this.options.size && i > this.options.size)
                i = this.options.size;
            if (e > i) {
                o = 0;
                e = i;
                for (n = 0; ++o; ) {
                    h = this.get(e--);
                    if (!h.length)
                        break;
                    n += this.dimension(h);
                    if (n >= g)
                        break
                }
            }
            e = i - o + 1;
            this.options.wrap != "circular" && e < 1 && (e = 1);
            if (this.inTail && d)
                b += this.tail,
                this.inTail = !1;
            this.tail = null;
            if (this.options.wrap != "circular" && i == this.options.size && i - o + 1 >= 1 && (d = f.intval(this.get(i).css(!this.options.vertical ? "marginRight" : "marginBottom")),
            n - d > g))
                this.tail = n - g - d;
            if (c && a === this.options.size && this.tail)
                b -= this.tail,
                this.inTail = !0;
            for (; a-- > e; )
                b += this.dimension(this.get(a));
            this.prevFirst = this.first;
            this.prevLast = this.last;
            this.first = e;
            this.last = i;
            return b
        },
        animate: function(a, c) {
            if (!this.locked && !this.animating) {
                this.animating = !0;
                var b = this
                  , d = function() {
                    b.animating = !1;
                    a === 0 && b.list.css(b.lt, 0);
                    !b.autoStopped && (b.options.wrap == "circular" || b.options.wrap == "both" || b.options.wrap == "last" || b.options.size === null || b.last < b.options.size || b.last == b.options.size && b.tail !== null && !b.inTail) && b.startAuto();
                    b.buttons();
                    b.notify("onAfterAnimation");
                    if (b.options.wrap == "circular" && b.options.size !== null)
                        for (var c = b.prevFirst; c <= b.prevLast; c++)
                            c !== null && !(c >= b.first && c <= b.last) && (c < 1 || c > b.options.size) && b.remove(c)
                };
                this.notify("onBeforeAnimation");
                if (!this.options.animation || c === !1)
                    this.list.css(this.lt, a + "px"),
                    d();
                else {
                    var f = !this.options.vertical ? this.options.rtl ? {
                        right: a
                    } : {
                        left: a
                    } : {
                        top: a
                    }
                      , d = {
                        duration: this.options.animation,
                        easing: this.options.easing,
                        complete: d
                    };
                    if (g.isFunction(this.options.animationStepCallback))
                        d.step = this.options.animationStepCallback;
                    this.list.animate(f, d)
                }
            }
        },
        startAuto: function(a) {
            if (a !== void 0)
                this.options.auto = a;
            if (this.options.auto === 0)
                return this.stopAuto();
            if (this.timer === null) {
                this.autoStopped = !1;
                var c = this;
                this.timer = window.setTimeout(function() {
                    c.next()
                }, this.options.auto * 1E3)
            }
        },
        stopAuto: function() {
            this.pauseAuto();
            this.autoStopped = !0
        },
        pauseAuto: function() {
            if (this.timer !== null)
                window.clearTimeout(this.timer),
                this.timer = null
        },
        buttons: function(a, c) {
            if (a == null && (a = !this.locked && this.options.size !== 0 && (this.options.wrap && this.options.wrap != "first" || this.options.size === null || this.last < this.options.size),
            !this.locked && (!this.options.wrap || this.options.wrap == "first") && this.options.size !== null && this.last >= this.options.size))
                a = this.tail !== null && !this.inTail;
            if (c == null && (c = !this.locked && this.options.size !== 0 && (this.options.wrap && this.options.wrap != "last" || this.first > 1),
            !this.locked && (!this.options.wrap || this.options.wrap == "last") && this.options.size !== null && this.first == 1))
                c = this.tail !== null && this.inTail;
            var b = this;
            this.buttonNext.size() > 0 ? (this.buttonNext.unbind(this.options.buttonNextEvent + ".jcarousel", this.funcNext),
            a && this.buttonNext.bind(this.options.buttonNextEvent + ".jcarousel", this.funcNext),
            this.buttonNext[a ? "removeClass" : "addClass"](this.className("jcarousel-next-disabled")).attr("disabled", a ? !1 : !0),
            this.options.buttonNextCallback !== null && this.buttonNext.data("jcarouselstate") != a && this.buttonNext.each(function() {
                b.options.buttonNextCallback(b, this, a)
            }).data("jcarouselstate", a)) : this.options.buttonNextCallback !== null && this.buttonNextState != a && this.options.buttonNextCallback(b, null, a);
            this.buttonPrev.size() > 0 ? (this.buttonPrev.unbind(this.options.buttonPrevEvent + ".jcarousel", this.funcPrev),
            c && this.buttonPrev.bind(this.options.buttonPrevEvent + ".jcarousel", this.funcPrev),
            this.buttonPrev[c ? "removeClass" : "addClass"](this.className("jcarousel-prev-disabled")).attr("disabled", c ? !1 : !0),
            this.options.buttonPrevCallback !== null && this.buttonPrev.data("jcarouselstate") != c && this.buttonPrev.each(function() {
                b.options.buttonPrevCallback(b, this, c)
            }).data("jcarouselstate", c)) : this.options.buttonPrevCallback !== null && this.buttonPrevState != c && this.options.buttonPrevCallback(b, null, c);
            this.buttonNextState = a;
            this.buttonPrevState = c
        },
        notify: function(a) {
            var c = this.prevFirst === null ? "init" : this.prevFirst < this.first ? "next" : "prev";
            this.callback("itemLoadCallback", a, c);
            this.prevFirst !== this.first && (this.callback("itemFirstInCallback", a, c, this.first),
            this.callback("itemFirstOutCallback", a, c, this.prevFirst));
            this.prevLast !== this.last && (this.callback("itemLastInCallback", a, c, this.last),
            this.callback("itemLastOutCallback", a, c, this.prevLast));
            this.callback("itemVisibleInCallback", a, c, this.first, this.last, this.prevFirst, this.prevLast);
            this.callback("itemVisibleOutCallback", a, c, this.prevFirst, this.prevLast, this.first, this.last)
        },
        callback: function(a, c, b, d, f, j, e) {
            if (!(this.options[a] == null || typeof this.options[a] != "object" && c != "onAfterAnimation")) {
                var h = typeof this.options[a] == "object" ? this.options[a][c] : this.options[a];
                if (g.isFunction(h)) {
                    var i = this;
                    if (d === void 0)
                        h(i, b, c);
                    else if (f === void 0)
                        this.get(d).each(function() {
                            h(i, this, d, b, c)
                        });
                    else
                        for (var a = function(a) {
                            i.get(a).each(function() {
                                h(i, this, a, b, c)
                            })
                        }, k = d; k <= f; k++)
                            k !== null && !(k >= j && k <= e) && a(k)
                }
            }
        },
        create: function(a) {
            return this.format("<li></li>", a)
        },
        format: function(a, c) {
            for (var a = g(a), b = a.get(0).className.split(" "), d = 0; d < b.length; d++)
                b[d].indexOf("jcarousel-") != -1 && a.removeClass(b[d]);
            a.addClass(this.className("jcarousel-item")).addClass(this.className("jcarousel-item-" + c)).css({
                "float": this.options.rtl ? "right" : "left",
                "list-style": "none"
            }).attr("jcarouselindex", c);
            return a
        },
        className: function(a) {
            return a + " " + a + (!this.options.vertical ? "-horizontal" : "-vertical")
        },
        dimension: function(a, c) {
            var b = g(a);
            if (c == null)
                return !this.options.vertical ? b.outerWidth(!0) || f.intval(this.options.itemFallbackDimension) : b.outerHeight(!0) || f.intval(this.options.itemFallbackDimension);
            else {
                var d = !this.options.vertical ? c - f.intval(b.css("marginLeft")) - f.intval(b.css("marginRight")) : c - f.intval(b.css("marginTop")) - f.intval(b.css("marginBottom"));
                g(b).css(this.wh, d + "px");
                return this.dimension(b)
            }
        },
        clipping: function() {
            return !this.options.vertical ? this.clip[0].offsetWidth - f.intval(this.clip.css("borderLeftWidth")) - f.intval(this.clip.css("borderRightWidth")) : this.clip[0].offsetHeight - f.intval(this.clip.css("borderTopWidth")) - f.intval(this.clip.css("borderBottomWidth"))
        },
        index: function(a, c) {
            if (c == null)
                c = this.options.size;
            return Math.round(((a - 1) / c - Math.floor((a - 1) / c)) * c) + 1
        }
    });
    f.extend({
        defaults: function(a) {
            return g.extend(q, a || {})
        },
        intval: function(a) {
            a = parseInt(a, 10);
            return isNaN(a) ? 0 : a
        },
        windowLoaded: function() {
            m = !0
        }
    });
    g.fn.jcarousel = function(a) {
        if (typeof a == "string") {
            var c = g(this).data("jcarousel")
              , b = Array.prototype.slice.call(arguments, 1);
            return c[a].apply(c, b)
        } else
            return this.each(function() {
                var b = g(this).data("jcarousel");
                b ? (a && g.extend(b.options, a),
                b.reload()) : g(this).data("jcarousel", new f(this,a))
            })
    }
}
)(jQuery);

/*
* jQuery Mobile v1.4.5
* http://jquerymobile.com
*
* Copyright 2010, 2014 jQuery Foundation, Inc. and other contributors
* Released under the MIT license.
* http://jquery.org/license
*
*/

(function(root, doc, factory) {
    if (typeof define === "function" && define.amd) {
        // AMD. Register as an anonymous module.
        define(["jquery"], function($) {
            factory($, root, doc);
            return $.mobile;
        });
    } else {
        // Browser globals
        factory(root.jQuery, root, doc);
    }
}(this, document, function(jQuery, window, document, undefined) {
    // This plugin is an experiment for abstracting away the touch and mouse
    // events so that developers don't have to worry about which method of input
    // the device their document is loaded on supports.
    //
    // The idea here is to allow the developer to register listeners for the
    // basic mouse events, such as mousedown, mousemove, mouseup, and click,
    // and the plugin will take care of registering the correct listeners
    // behind the scenes to invoke the listener at the fastest possible time
    // for that device, while still retaining the order of event firing in
    // the traditional mouse environment, should multiple handlers be registered
    // on the same element for different events.
    //
    // The current version exposes the following virtual events to jQuery bind methods:
    // "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel"

    (function($, window, document, undefined) {

        var dataPropertyName = "virtualMouseBindings", touchTargetPropertyName = "virtualTouchID", virtualEventNames = "vmouseover vmousedown vmousemove vmouseup vclick vmouseout vmousecancel".split(" "), touchEventProps = "clientX clientY pageX pageY screenX screenY".split(" "), mouseHookProps = $.event.mouseHooks ? $.event.mouseHooks.props : [], mouseEventProps = $.event.props.concat(mouseHookProps), activeDocHandlers = {}, resetTimerID = 0, startX = 0, startY = 0, didScroll = false, clickBlockList = [], blockMouseTriggers = false, blockTouchTriggers = false, eventCaptureSupported = "addEventListener"in document, $document = $(document), nextTouchID = 1, lastTouchID = 0, threshold, i;

        $.vmouse = {
            moveDistanceThreshold: 10,
            clickDistanceThreshold: 10,
            resetTimerDuration: 1500
        };

        function getNativeEvent(event) {

            while (event && typeof event.originalEvent !== "undefined") {
                event = event.originalEvent;
            }
            return event;
        }

        function createVirtualEvent(event, eventType) {

            var t = event.type, oe, props, ne, prop, ct, touch, i, j, len;

            event = $.Event(event);
            event.type = eventType;

            oe = event.originalEvent;
            props = $.event.props;

            // addresses separation of $.event.props in to $.event.mouseHook.props and Issue 3280
            // https://github.com/jquery/jquery-mobile/issues/3280
            if (t.search(/^(mouse|click)/) > -1) {
                props = mouseEventProps;
            }

            // copy original event properties over to the new event
            // this would happen if we could call $.event.fix instead of $.Event
            // but we don't have a way to force an event to be fixed multiple times
            if (oe) {
                for (i = props.length,
                prop; i; ) {
                    prop = props[--i];
                    event[prop] = oe[prop];
                }
            }

            // make sure that if the mouse and click virtual events are generated
            // without a .which one is defined
            if (t.search(/mouse(down|up)|click/) > -1 && !event.which) {
                event.which = 1;
            }

            if (t.search(/^touch/) !== -1) {
                ne = getNativeEvent(oe);
                t = ne.touches;
                ct = ne.changedTouches;
                touch = (t && t.length) ? t[0] : ((ct && ct.length) ? ct[0] : undefined);

                if (touch) {
                    for (j = 0,
                    len = touchEventProps.length; j < len; j++) {
                        prop = touchEventProps[j];
                        event[prop] = touch[prop];
                    }
                }
            }

            return event;
        }

        function getVirtualBindingFlags(element) {

            var flags = {}, b, k;

            while (element) {

                b = $.data(element, dataPropertyName);

                for (k in b) {
                    if (b[k]) {
                        flags[k] = flags.hasVirtualBinding = true;
                    }
                }
                element = element.parentNode;
            }
            return flags;
        }

        function getClosestElementWithVirtualBinding(element, eventType) {
            var b;
            while (element) {

                b = $.data(element, dataPropertyName);

                if (b && (!eventType || b[eventType])) {
                    return element;
                }
                element = element.parentNode;
            }
            return null;
        }

        function enableTouchBindings() {
            blockTouchTriggers = false;
        }

        function disableTouchBindings() {
            blockTouchTriggers = true;
        }

        function enableMouseBindings() {
            lastTouchID = 0;
            clickBlockList.length = 0;
            blockMouseTriggers = false;

            // When mouse bindings are enabled, our
            // touch bindings are disabled.
            disableTouchBindings();
        }

        function disableMouseBindings() {
            // When mouse bindings are disabled, our
            // touch bindings are enabled.
            enableTouchBindings();
        }

        function startResetTimer() {
            clearResetTimer();
            resetTimerID = setTimeout(function() {
                resetTimerID = 0;
                enableMouseBindings();
            }, $.vmouse.resetTimerDuration);
        }

        function clearResetTimer() {
            if (resetTimerID) {
                clearTimeout(resetTimerID);
                resetTimerID = 0;
            }
        }

        function triggerVirtualEvent(eventType, event, flags) {
            var ve;

            if ((flags && flags[eventType]) || (!flags && getClosestElementWithVirtualBinding(event.target, eventType))) {

                ve = createVirtualEvent(event, eventType);

                $(event.target).trigger(ve);
            }

            return ve;
        }

        function mouseEventCallback(event) {
            var touchID = $.data(event.target, touchTargetPropertyName), ve;

            if (!blockMouseTriggers && (!lastTouchID || lastTouchID !== touchID)) {
                ve = triggerVirtualEvent("v" + event.type, event);
                if (ve) {
                    if (ve.isDefaultPrevented()) {
                        event.preventDefault();
                    }
                    if (ve.isPropagationStopped()) {
                        event.stopPropagation();
                    }
                    if (ve.isImmediatePropagationStopped()) {
                        event.stopImmediatePropagation();
                    }
                }
            }
        }

        function handleTouchStart(event) {

            var touches = getNativeEvent(event).touches, target, flags, t;

            if (touches && touches.length === 1) {

                target = event.target;
                flags = getVirtualBindingFlags(target);

                if (flags.hasVirtualBinding) {

                    lastTouchID = nextTouchID++;
                    $.data(target, touchTargetPropertyName, lastTouchID);

                    clearResetTimer();

                    disableMouseBindings();
                    didScroll = false;

                    t = getNativeEvent(event).touches[0];
                    startX = t.pageX;
                    startY = t.pageY;

                    triggerVirtualEvent("vmouseover", event, flags);
                    triggerVirtualEvent("vmousedown", event, flags);
                }
            }
        }

        function handleScroll(event) {
            if (blockTouchTriggers) {
                return;
            }

            if (!didScroll) {
                triggerVirtualEvent("vmousecancel", event, getVirtualBindingFlags(event.target));
            }

            didScroll = true;
            startResetTimer();
        }

        function handleTouchMove(event) {
            if (blockTouchTriggers) {
                return;
            }

            var t = getNativeEvent(event).touches[0]
              , didCancel = didScroll
              , moveThreshold = $.vmouse.moveDistanceThreshold
              , flags = getVirtualBindingFlags(event.target);

            didScroll = didScroll || (Math.abs(t.pageX - startX) > moveThreshold || Math.abs(t.pageY - startY) > moveThreshold);

            if (didScroll && !didCancel) {
                triggerVirtualEvent("vmousecancel", event, flags);
            }

            triggerVirtualEvent("vmousemove", event, flags);
            startResetTimer();
        }

        function handleTouchEnd(event) {
            if (blockTouchTriggers) {
                return;
            }

            disableTouchBindings();

            var flags = getVirtualBindingFlags(event.target), ve, t;
            triggerVirtualEvent("vmouseup", event, flags);

            if (!didScroll) {
                ve = triggerVirtualEvent("vclick", event, flags);
                if (ve && ve.isDefaultPrevented()) {
                    // The target of the mouse events that follow the touchend
                    // event don't necessarily match the target used during the
                    // touch. This means we need to rely on coordinates for blocking
                    // any click that is generated.
                    t = getNativeEvent(event).changedTouches[0];
                    clickBlockList.push({
                        touchID: lastTouchID,
                        x: t.clientX,
                        y: t.clientY
                    });

                    // Prevent any mouse events that follow from triggering
                    // virtual event notifications.
                    blockMouseTriggers = true;
                }
            }
            triggerVirtualEvent("vmouseout", event, flags);
            didScroll = false;

            startResetTimer();
        }

        function hasVirtualBindings(ele) {
            var bindings = $.data(ele, dataPropertyName), k;

            if (bindings) {
                for (k in bindings) {
                    if (bindings[k]) {
                        return true;
                    }
                }
            }
            return false;
        }

        function dummyMouseHandler() {}

        function getSpecialEventObject(eventType) {
            var realType = eventType.substr(1);

            return {
                setup: function(/* data, namespace */
                ) {
                    // If this is the first virtual mouse binding for this element,
                    // add a bindings object to its data.

                    if (!hasVirtualBindings(this)) {
                        $.data(this, dataPropertyName, {});
                    }

                    // If setup is called, we know it is the first binding for this
                    // eventType, so initialize the count for the eventType to zero.
                    var bindings = $.data(this, dataPropertyName);
                    bindings[eventType] = true;

                    // If this is the first virtual mouse event for this type,
                    // register a global handler on the document.

                    activeDocHandlers[eventType] = (activeDocHandlers[eventType] || 0) + 1;

                    if (activeDocHandlers[eventType] === 1) {
                        $document.bind(realType, mouseEventCallback);
                    }

                    // Some browsers, like Opera Mini, won't dispatch mouse/click events
                    // for elements unless they actually have handlers registered on them.
                    // To get around this, we register dummy handlers on the elements.

                    $(this).bind(realType, dummyMouseHandler);

                    // For now, if event capture is not supported, we rely on mouse handlers.
                    if (eventCaptureSupported) {
                        // If this is the first virtual mouse binding for the document,
                        // register our touchstart handler on the document.

                        activeDocHandlers["touchstart"] = (activeDocHandlers["touchstart"] || 0) + 1;

                        if (activeDocHandlers["touchstart"] === 1) {
                            $document.bind("touchstart", handleTouchStart).bind("touchend", handleTouchEnd)
                            // On touch platforms, touching the screen and then dragging your finger
                            // causes the window content to scroll after some distance threshold is
                            // exceeded. On these platforms, a scroll prevents a click event from being
                            // dispatched, and on some platforms, even the touchend is suppressed. To
                            // mimic the suppression of the click event, we need to watch for a scroll
                            // event. Unfortunately, some platforms like iOS don't dispatch scroll
                            // events until *AFTER* the user lifts their finger (touchend). This means
                            // we need to watch both scroll and touchmove events to figure out whether
                            // or not a scroll happenens before the touchend event is fired.

                            .bind("touchmove", handleTouchMove).bind("scroll", handleScroll);
                        }
                    }
                },

                teardown: function(/* data, namespace */
                ) {
                    // If this is the last virtual binding for this eventType,
                    // remove its global handler from the document.

                    --activeDocHandlers[eventType];

                    if (!activeDocHandlers[eventType]) {
                        $document.unbind(realType, mouseEventCallback);
                    }

                    if (eventCaptureSupported) {
                        // If this is the last virtual mouse binding in existence,
                        // remove our document touchstart listener.

                        --activeDocHandlers["touchstart"];

                        if (!activeDocHandlers["touchstart"]) {
                            $document.unbind("touchstart", handleTouchStart).unbind("touchmove", handleTouchMove).unbind("touchend", handleTouchEnd).unbind("scroll", handleScroll);
                        }
                    }

                    var $this = $(this)
                      , bindings = $.data(this, dataPropertyName);

                    // teardown may be called when an element was
                    // removed from the DOM. If this is the case,
                    // jQuery core may have already stripped the element
                    // of any data bindings so we need to check it before
                    // using it.
                    if (bindings) {
                        bindings[eventType] = false;
                    }

                    // Unregister the dummy event handler.

                    $this.unbind(realType, dummyMouseHandler);

                    // If this is the last virtual mouse binding on the
                    // element, remove the binding data from the element.

                    if (!hasVirtualBindings(this)) {
                        $this.removeData(dataPropertyName);
                    }
                }
            };
        }

        // Expose our custom events to the jQuery bind/unbind mechanism.

        for (i = 0; i < virtualEventNames.length; i++) {
            $.event.special[virtualEventNames[i]] = getSpecialEventObject(virtualEventNames[i]);
        }

        // Add a capture click handler to block clicks.
        // Note that we require event capture support for this so if the device
        // doesn't support it, we punt for now and rely solely on mouse events.
        if (eventCaptureSupported) {
            document.addEventListener("click", function(e) {
                var cnt = clickBlockList.length, target = e.target, x, y, ele, i, o, touchID;

                if (cnt) {
                    x = e.clientX;
                    y = e.clientY;
                    threshold = $.vmouse.clickDistanceThreshold;

                    // The idea here is to run through the clickBlockList to see if
                    // the current click event is in the proximity of one of our
                    // vclick events that had preventDefault() called on it. If we find
                    // one, then we block the click.
                    //
                    // Why do we have to rely on proximity?
                    //
                    // Because the target of the touch event that triggered the vclick
                    // can be different from the target of the click event synthesized
                    // by the browser. The target of a mouse/click event that is synthesized
                    // from a touch event seems to be implementation specific. For example,
                    // some browsers will fire mouse/click events for a link that is near
                    // a touch event, even though the target of the touchstart/touchend event
                    // says the user touched outside the link. Also, it seems that with most
                    // browsers, the target of the mouse/click event is not calculated until the
                    // time it is dispatched, so if you replace an element that you touched
                    // with another element, the target of the mouse/click will be the new
                    // element underneath that point.
                    //
                    // Aside from proximity, we also check to see if the target and any
                    // of its ancestors were the ones that blocked a click. This is necessary
                    // because of the strange mouse/click target calculation done in the
                    // Android 2.1 browser, where if you click on an element, and there is a
                    // mouse/click handler on one of its ancestors, the target will be the
                    // innermost child of the touched element, even if that child is no where
                    // near the point of touch.

                    ele = target;

                    while (ele) {
                        for (i = 0; i < cnt; i++) {
                            o = clickBlockList[i];
                            touchID = 0;

                            if ((ele === target && Math.abs(o.x - x) < threshold && Math.abs(o.y - y) < threshold) || $.data(ele, touchTargetPropertyName) === o.touchID) {
                                // XXX: We may want to consider removing matches from the block list
                                //      instead of waiting for the reset timer to fire.
                                e.preventDefault();
                                e.stopPropagation();
                                return;
                            }
                        }
                        ele = ele.parentNode;
                    }
                }
            }, true);
        }
    }
    )(jQuery, window, document);

    (function($) {
        $.mobile = {};
    }(jQuery));

    (function($, undefined) {
        var support = {
            touch: "ontouchend"in document
        };

        $.mobile.support = $.mobile.support || {};
        $.extend($.support, support);
        $.extend($.mobile.support, support);
    }(jQuery));

    (function($, window, undefined) {
        var $document = $(document)
          , supportTouch = $.mobile.support.touch
          , scrollEvent = "touchmove scroll"
          , touchStartEvent = supportTouch ? "touchstart" : "mousedown"
          , touchStopEvent = supportTouch ? "touchend" : "mouseup"
          , touchMoveEvent = supportTouch ? "touchmove" : "mousemove";

        // setup new event shortcuts
        $.each(("touchstart touchmove touchend " + "tap taphold " + "swipe swipeleft swiperight " + "scrollstart scrollstop").split(" "), function(i, name) {

            $.fn[name] = function(fn) {
                return fn ? this.bind(name, fn) : this.trigger(name);
            }
            ;

            // jQuery < 1.8
            if ($.attrFn) {
                $.attrFn[name] = true;
            }
        });

        function triggerCustomEvent(obj, eventType, event, bubble) {
            var originalType = event.type;
            event.type = eventType;
            if (bubble) {
                $.event.trigger(event, undefined, obj);
            } else {
                $.event.dispatch.call(obj, event);
            }
            event.type = originalType;
        }

        // also handles scrollstop
        $.event.special.scrollstart = {

            enabled: true,
            setup: function() {

                var thisObject = this, $this = $(thisObject), scrolling, timer;

                function trigger(event, state) {
                    scrolling = state;
                    triggerCustomEvent(thisObject, scrolling ? "scrollstart" : "scrollstop", event);
                }

                // iPhone triggers scroll after a small delay; use touchmove instead
                $this.bind(scrollEvent, function(event) {

                    if (!$.event.special.scrollstart.enabled) {
                        return;
                    }

                    if (!scrolling) {
                        trigger(event, true);
                    }

                    clearTimeout(timer);
                    timer = setTimeout(function() {
                        trigger(event, false);
                    }, 50);
                });
            },
            teardown: function() {
                $(this).unbind(scrollEvent);
            }
        };

        // also handles taphold
        $.event.special.tap = {
            tapholdThreshold: 750,
            emitTapOnTaphold: true,
            setup: function() {
                var thisObject = this
                  , $this = $(thisObject)
                  , isTaphold = false;

                $this.bind("vmousedown", function(event) {
                    isTaphold = false;
                    if (event.which && event.which !== 1) {
                        return false;
                    }

                    var origTarget = event.target, timer;

                    function clearTapTimer() {
                        clearTimeout(timer);
                    }

                    function clearTapHandlers() {
                        clearTapTimer();

                        $this.unbind("vclick", clickHandler).unbind("vmouseup", clearTapTimer);
                        $document.unbind("vmousecancel", clearTapHandlers);
                    }

                    function clickHandler(event) {
                        clearTapHandlers();

                        // ONLY trigger a 'tap' event if the start target is
                        // the same as the stop target.
                        if (!isTaphold && origTarget === event.target) {
                            triggerCustomEvent(thisObject, "tap", event);
                        } else if (isTaphold) {
                            event.preventDefault();
                        }
                    }

                    $this.bind("vmouseup", clearTapTimer).bind("vclick", clickHandler);
                    $document.bind("vmousecancel", clearTapHandlers);

                    timer = setTimeout(function() {
                        if (!$.event.special.tap.emitTapOnTaphold) {
                            isTaphold = true;
                        }
                        triggerCustomEvent(thisObject, "taphold", $.Event("taphold", {
                            target: origTarget
                        }));
                    }, $.event.special.tap.tapholdThreshold);
                });
            },
            teardown: function() {
                $(this).unbind("vmousedown").unbind("vclick").unbind("vmouseup");
                $document.unbind("vmousecancel");
            }
        };

        // Also handles swipeleft, swiperight
        $.event.special.swipe = {

            // More than this horizontal displacement, and we will suppress scrolling.
            scrollSupressionThreshold: 30,

            // More time than this, and it isn't a swipe.
            durationThreshold: 1000,

            // Swipe horizontal displacement must be more than this.
            horizontalDistanceThreshold: 30,

            // Swipe vertical displacement must be less than this.
            verticalDistanceThreshold: 30,

            getLocation: function(event) {
                var winPageX = window.pageXOffset
                  , winPageY = window.pageYOffset
                  , x = event.clientX
                  , y = event.clientY;

                if (event.pageY === 0 && Math.floor(y) > Math.floor(event.pageY) || event.pageX === 0 && Math.floor(x) > Math.floor(event.pageX)) {

                    // iOS4 clientX/clientY have the value that should have been
                    // in pageX/pageY. While pageX/page/ have the value 0
                    x = x - winPageX;
                    y = y - winPageY;
                } else if (y < (event.pageY - winPageY) || x < (event.pageX - winPageX)) {

                    // Some Android browsers have totally bogus values for clientX/Y
                    // when scrolling/zooming a page. Detectable since clientX/clientY
                    // should never be smaller than pageX/pageY minus page scroll
                    x = event.pageX - winPageX;
                    y = event.pageY - winPageY;
                }

                return {
                    x: x,
                    y: y
                };
            },

            start: function(event) {
                var data = event.originalEvent.touches ? event.originalEvent.touches[0] : event
                  , location = $.event.special.swipe.getLocation(data);
                return {
                    time: (new Date()).getTime(),
                    coords: [location.x, location.y],
                    origin: $(event.target)
                };
            },

            stop: function(event) {
                var data = event.originalEvent.touches ? event.originalEvent.touches[0] : event
                  , location = $.event.special.swipe.getLocation(data);
                return {
                    time: (new Date()).getTime(),
                    coords: [location.x, location.y]
                };
            },

            handleSwipe: function(start, stop, thisObject, origTarget) {
                if (stop.time - start.time < $.event.special.swipe.durationThreshold && Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.swipe.horizontalDistanceThreshold && Math.abs(start.coords[1] - stop.coords[1]) < $.event.special.swipe.verticalDistanceThreshold) {
                    var direction = start.coords[0] > stop.coords[0] ? "swipeleft" : "swiperight";

                    triggerCustomEvent(thisObject, "swipe", $.Event("swipe", {
                        target: origTarget,
                        swipestart: start,
                        swipestop: stop
                    }), true);
                    triggerCustomEvent(thisObject, direction, $.Event(direction, {
                        target: origTarget,
                        swipestart: start,
                        swipestop: stop
                    }), true);
                    return true;
                }
                return false;

            },

            // This serves as a flag to ensure that at most one swipe event event is
            // in work at any given time
            eventInProgress: false,

            setup: function() {
                var events, thisObject = this, $this = $(thisObject), context = {};

                // Retrieve the events data for this element and add the swipe context
                events = $.data(this, "mobile-events");
                if (!events) {
                    events = {
                        length: 0
                    };
                    $.data(this, "mobile-events", events);
                }
                events.length++;
                events.swipe = context;

                context.start = function(event) {

                    // Bail if we're already working on a swipe event
                    if ($.event.special.swipe.eventInProgress) {
                        return;
                    }
                    $.event.special.swipe.eventInProgress = true;

                    var stop, start = $.event.special.swipe.start(event), origTarget = event.target, emitted = false;

                    context.move = function(event) {
                        if (!start || event.isDefaultPrevented()) {
                            return;
                        }

                        stop = $.event.special.swipe.stop(event);
                        if (!emitted) {
                            emitted = $.event.special.swipe.handleSwipe(start, stop, thisObject, origTarget);
                            if (emitted) {

                                // Reset the context to make way for the next swipe event
                                $.event.special.swipe.eventInProgress = false;
                            }
                        }
                        // prevent scrolling
                        if (Math.abs(start.coords[0] - stop.coords[0]) > $.event.special.swipe.scrollSupressionThreshold) {
                            event.preventDefault();
                        }
                    }
                    ;

                    context.stop = function() {
                        emitted = true;

                        // Reset the context to make way for the next swipe event
                        $.event.special.swipe.eventInProgress = false;
                        $document.off(touchMoveEvent, context.move);
                        context.move = null;
                    }
                    ;

                    $document.on(touchMoveEvent, context.move).one(touchStopEvent, context.stop);
                }
                ;
                $this.on(touchStartEvent, context.start);
            },

            teardown: function() {
                var events, context;

                events = $.data(this, "mobile-events");
                if (events) {
                    context = events.swipe;
                    delete events.swipe;
                    events.length--;
                    if (events.length === 0) {
                        $.removeData(this, "mobile-events");
                    }
                }

                if (context) {
                    if (context.start) {
                        $(this).off(touchStartEvent, context.start);
                    }
                    if (context.move) {
                        $document.off(touchMoveEvent, context.move);
                    }
                    if (context.stop) {
                        $document.off(touchStopEvent, context.stop);
                    }
                }
            }
        };
        $.each({
            scrollstop: "scrollstart",
            taphold: "tap",
            swipeleft: "swipe.left",
            swiperight: "swipe.right"
        }, function(event, sourceEvent) {

            $.event.special[event] = {
                setup: function() {
                    $(this).bind(sourceEvent, $.noop);
                },
                teardown: function() {
                    $(this).unbind(sourceEvent);
                }
            };
        });

    }
    )(jQuery, this);

}));

// Generated by CoffeeScript 1.9.2

/**
@license Sticky-kit v1.1.2 | WTFPL | Leaf Corcoran 2015 | http://leafo.net
 */

(function() {
    var $, win;

    $ = this.jQuery || window.jQuery;

    win = $(window);

    $.fn.stick_in_parent = function(opts) {
        var doc, elm, enable_bottoming, fn, i, inner_scrolling, len, manual_spacer, offset_top, parent_selector, recalc_every, sticky_class;
        if (opts == null) {
            opts = {};
        }
        sticky_class = opts.sticky_class,
        inner_scrolling = opts.inner_scrolling,
        recalc_every = opts.recalc_every,
        parent_selector = opts.parent,
        offset_top = opts.offset_top,
        manual_spacer = opts.spacer,
        enable_bottoming = opts.bottoming;
        if (offset_top == null) {
            offset_top = 0;
        }
        if (parent_selector == null) {
            parent_selector = void 0;
        }
        if (inner_scrolling == null) {
            inner_scrolling = true;
        }
        if (sticky_class == null) {
            sticky_class = "is_stuck";
        }
        doc = $(document);
        if (enable_bottoming == null) {
            enable_bottoming = true;
        }
        fn = function(elm, padding_bottom, parent_top, parent_height, top, height, el_float, detached) {
            var bottomed, detach, fixed, last_pos, last_scroll_height, offset, parent, recalc, recalc_and_tick, recalc_counter, spacer, tick;
            if (elm.data("sticky_kit")) {
                return;
            }
            elm.data("sticky_kit", true);
            last_scroll_height = doc.height();
            parent = elm.parent();
            if (parent_selector != null) {
                parent = parent.closest(parent_selector);
            }
            if (!parent.length) {
                throw "failed to find stick parent";
            }
            fixed = false;
            bottomed = false;
            spacer = manual_spacer != null ? manual_spacer && elm.closest(manual_spacer) : $("<div />");
            if (spacer) {
                spacer.css('position', elm.css('position'));
            }
            recalc = function() {
                var border_top, padding_top, restore;
                if (detached) {
                    return;
                }
                last_scroll_height = doc.height();
                border_top = parseInt(parent.css("border-top-width"), 10);
                padding_top = parseInt(parent.css("padding-top"), 10);
                padding_bottom = parseInt(parent.css("padding-bottom"), 10);
                parent_top = parent.offset().top + border_top + padding_top;
                parent_height = parent.height();
                if (fixed) {
                    fixed = false;
                    bottomed = false;
                    if (manual_spacer == null) {
                        elm.insertAfter(spacer);
                        spacer.detach();
                    }
                    elm.css({
                        position: "",
                        top: "",
                        width: "",
                        bottom: ""
                    }).removeClass(sticky_class);
                    restore = true;
                }
                top = elm.offset().top - (parseInt(elm.css("margin-top"), 10) || 0) - offset_top;
                height = elm.outerHeight(true);
                el_float = elm.css("float");
                if (spacer) {
                    spacer.css({
                        width: elm.outerWidth(true),
                        height: height,
                        display: elm.css("display"),
                        "vertical-align": elm.css("vertical-align"),
                        "float": el_float
                    });
                }
                if (restore) {
                    return tick();
                }
            }
            ;
            recalc();
            if (height === parent_height) {
                return;
            }
            last_pos = void 0;
            offset = offset_top;
            recalc_counter = recalc_every;
            tick = function() {
                var css, delta, recalced, scroll, will_bottom, win_height;
                if (detached) {
                    return;
                }
                recalced = false;
                if (recalc_counter != null) {
                    recalc_counter -= 1;
                    if (recalc_counter <= 0) {
                        recalc_counter = recalc_every;
                        recalc();
                        recalced = true;
                    }
                }
                if (!recalced && doc.height() !== last_scroll_height) {
                    recalc();
                    recalced = true;
                }
                scroll = win.scrollTop();
                if (last_pos != null) {
                    delta = scroll - last_pos;
                }
                last_pos = scroll;
                if (fixed) {
                    if (enable_bottoming) {
                        will_bottom = scroll + height + offset > parent_height + parent_top;
                        if (bottomed && !will_bottom) {
                            bottomed = false;
                            elm.css({
                                position: "fixed",
                                bottom: "",
                                top: offset
                            }).trigger("sticky_kit:unbottom");
                        }
                    }
                    if (scroll < top) {
                        fixed = false;
                        offset = offset_top;
                        if (manual_spacer == null) {
                            if (el_float === "left" || el_float === "right") {
                                elm.insertAfter(spacer);
                            }
                            spacer.detach();
                        }
                        css = {
                            position: "",
                            width: "",
                            top: ""
                        };
                        elm.css(css).removeClass(sticky_class).trigger("sticky_kit:unstick");
                    }
                    if (inner_scrolling) {
                        win_height = win.height();
                        if (height + offset_top > win_height) {
                            if (!bottomed) {
                                offset -= delta;
                                offset = Math.max(win_height - height, offset);
                                offset = Math.min(offset_top, offset);
                                if (fixed) {
                                    elm.css({
                                        top: offset + "px"
                                    });
                                }
                            }
                        }
                    }
                } else {
                    if (scroll > top) {
                        fixed = true;
                        css = {
                            position: "fixed",
                            top: offset
                        };
                        css.width = elm.css("box-sizing") === "border-box" ? elm.outerWidth() + "px" : elm.width() + "px";
                        elm.css(css).addClass(sticky_class);
                        if (manual_spacer == null) {
                            elm.after(spacer);
                            if (el_float === "left" || el_float === "right") {
                                spacer.append(elm);
                            }
                        }
                        elm.trigger("sticky_kit:stick");
                    }
                }
                if (fixed && enable_bottoming) {
                    if (will_bottom == null) {
                        will_bottom = scroll + height + offset > parent_height + parent_top;
                    }
                    if (!bottomed && will_bottom) {
                        bottomed = true;
                        if (parent.css("position") === "static") {
                            parent.css({
                                position: "relative"
                            });
                        }
                        return elm.css({
                            position: "absolute",
                            bottom: padding_bottom,
                            top: "auto"
                        }).trigger("sticky_kit:bottom");
                    }
                }
            }
            ;
            recalc_and_tick = function() {
                recalc();
                return tick();
            }
            ;
            detach = function() {
                detached = true;
                win.off("touchmove", tick);
                win.off("scroll", tick);
                win.off("resize", recalc_and_tick);
                $(document.body).off("sticky_kit:recalc", recalc_and_tick);
                elm.off("sticky_kit:detach", detach);
                elm.removeData("sticky_kit");
                elm.css({
                    position: "",
                    bottom: "",
                    top: "",
                    width: ""
                });
                parent.position("position", "");
                if (fixed) {
                    if (manual_spacer == null) {
                        if (el_float === "left" || el_float === "right") {
                            elm.insertAfter(spacer);
                        }
                        spacer.remove();
                    }
                    return elm.removeClass(sticky_class);
                }
            }
            ;
            win.on("touchmove", tick);
            win.on("scroll", tick);
            win.on("resize", recalc_and_tick);
            $(document.body).on("sticky_kit:recalc", recalc_and_tick);
            elm.on("sticky_kit:detach", detach);
            return setTimeout(tick, 0);
        }
        ;
        for (i = 0,
        len = this.length; i < len; i++) {
            elm = this[i];
            fn($(elm));
        }
        return this;
    }
    ;

}
).call(this);

jQuery('.accordion-title a').addClass('icon-right-open-big');

function accordionTitleEvents() {
    jQuery('.accordion-title').on('click', function() {
        var _this = jQuery(this);
        jQuery(_this).parent().siblings().find('.active').removeClass('active');
        jQuery(_this).siblings('.accordion-content').toggleClass('active');
        jQuery('.rotate-icon').removeClass('rotate-icon');

        if (jQuery(_this).parent().find('> .accordion-content:first').hasClass('active')) {
            jQuery(_this).children('a').addClass('rotate-icon');
        }
    });
}

accordionTitleEvents();
jQuery(document).on('amshopby-ajax-update update-accordion', accordionTitleEvents);

jQuery('.collapse-search').on('click', function() {
    jQuery('.search-visible').toggle();
});

jQuery('.form-language').on('click', function() {
    jQuery('.language-selector').toggle();
    jQuery('.language-selector-overlay').toggleClass('language-selector-overlay-active');
    jQuery('.fixed-top-container').removeClass('popup-on-top');
    jQuery('.spacer').hide();
});

jQuery('.icon-cancel, .language-selector-overlay').on('click', function() {
    jQuery('.language-selector').hide();
    jQuery('.language-selector-overlay').removeClass('language-selector-overlay-active');
    jQuery('.fixed-top-container').addClass('popup-on-top');
    jQuery('.spacer').show();
});

jQuery(window).scroll(function() {
    if (jQuery(this).scrollTop() > 1) {
        jQuery('.header').addClass("scroll-effect");
        jQuery('.spacer').addClass("spacer-scroll");
    } else {
        jQuery('.header').removeClass("scroll-effect");
    }
    var mobileSize = jQuery(window).width() < 1025
      , checkClass = jQuery('.header').hasClass('scroll-effect');

    if (mobileSize && checkClass) {
        jQuery('.logo-desktop').hide();
        jQuery('.logo-mobile').fadeIn(300);
    } else if (mobileSize && !checkClass) {
        jQuery('.logo-mobile').hide();
        jQuery('.logo-desktop').fadeIn(300);
    }
});

jQuery('.counter, .shopping-bag').hover(function() {
    jQuery('#minicart-dropdown').not('[data-enable=0]').stop().fadeIn('fast');
}, function() {
    jQuery('#minicart-dropdown').stop().fadeOut('fast');
});

var dropdownTriggers = jQuery('.dropdown-trigger');
var dropdownMenus = dropdownTriggers.find('.dropdown');
var dropdownMenuOpen = false;

dropdownTriggers.on({
    'mouseover': function() {
        toggleDropMenu(jQuery(this), true);
    },
    'mouseout': function() {
        toggleDropMenu(jQuery(this), false);
    },
    'touchstart': function(event) {
        if (event.target.nodeName === 'A') {
            event.target.click();
            // Hacky fix to prevent the need for double tap
        } else {
            var el = jQuery(this);
            var show = !el.hasClass('menu-active');
            toggleDropMenu(el, show);
        }
    }
});

jQuery(document).on('touchstart', 'body', function(event) {
    if (dropdownMenuOpen && !jQuery(event.target).closest('.dropdown-trigger').length)
        toggleDropMenu(false, false);
});

function toggleDropMenu(trigger, show) {
    dropdownTriggers.removeClass('menu-active');
    dropdownMenus.hide();
    if (trigger.length && show) {
        var drop = trigger.find('.dropdown');
        trigger.addClass('menu-active', show);
        drop.toggle(show);
    }
    dropdownMenuOpen = show;
}

jQuery('.filters-mobile-header').click(function() {
    jQuery(this).toggleClass('expanded');
    jQuery('.filters-container-mobile').slideToggle();
    jQuery(this).find('h5').toggleClass('icon-cancel icon-down-open-big')
});

jQuery('.remember-me-box .link-popup').click(function() {
    jQuery('.remember-me-popup, .overlay').show();
    jQuery('.fixed-top-container').removeClass('popup-on-top');
    jQuery('.spacer').hide();
});

jQuery('.remember-me-popup-close, .overlay').click(function() {
    jQuery('.remember-me-popup, .overlay').hide();
    jQuery('.fixed-top-container').addClass('popup-on-top');
    jQuery('.spacer').show();
});

function ajaxLoadPosts(settings) {

    var dataPost = jQuery('.ajax_posts').data('posts');
    var dataPostString = dataPost.toString();
    var dataUrl = settings.url + '/wp-admin/admin-ajax.php?action=get_posts_html_by_id&posts=' + dataPostString + '&lang=' + settings.lang;

    jQuery.ajax({
        url: dataUrl,
        type: 'post',
        success: function(result) {
            if (result != '') {
                jQuery('#box-product-options-related-posts .ajax_posts').html(result);
            } else {
                jQuery('#box-product-options-related-posts .ajax_posts').html('<h6>There is no post with this ID</h6>');
            }
        },
        error: function() {
            jQuery('.tab-title[data-alias="box-product-options-related-posts"]').remove();
            jQuery('.tabs-content #box-product-options-related-posts').remove();
        }
    })
}

"use strict";

var ajaxSubscribe = {
    defaultMessage: 'A problem has occured, please contact us.',
    endpointUrl: '/shop/gb_en/newsletter/subscriber/subscribe',

    initForm: function(formSelector) {
        if (window.ajaxSubscribeEndpoint && window.ajaxSubscribeEndpoint.length > 0) {
            this.endpointUrl = window.ajaxSubscribeEndpoint;
        }

        var $form = jQuery(formSelector);

        if ($form.length < 1)
            return;
        $form.on('submit', this.handleSubmit.bind(this));
    },

    handleSubmit: function(e) {
        var that = this;
        var $form = jQuery(e.target);

        $form.addClass('loading');

        jQuery.ajax({
            url: this.endpointUrl,
            type: 'POST',
            dataType: 'json',
            data: $form.serialize(),
            success: function(response) {
                $form.removeClass('loading');
                if (!response.error) {
                    that.displayMessage('success', response.message, $form);
                } else {
                    that.displayMessage('error', response.message, $form);
                }
            },
            error: function(error) {
                $form.removeClass('loading');
                that.displayMessage('error', null, $form);
                console.log('Ajax Subscribe Error: ', error.statusText);
            }
        });

        e.preventDefault();
    },

    displayMessage: function(type, serverMessage, $form) {
        var messageText = serverMessage || this.defaultMessage;

        if ($form.length > 0) {
            var exsitingMessages = $form.find('.mage-message');
            exsitingMessages.hide();

            var $message = jQuery('<div class="mage-message ' + (type === 'error' ? 'mage-error' : 'mage-info') + '">' + messageText + '</div>');

            $form.append($message);
        } else {
            alert(serverMessage);
        }
    }
};
(function($) {

    if (typeof jQuery !== 'undefined') {

        jQuery.fn.extend({
            ajaxAddToCart: function(options) {

                /*
			 DEFAULTS
			 */
                var settings = {
                    init: {
                        ajaxCartEnable: null,
                        ajaxCartType: null,
                        isInlineNotificationsEnabled: false,
                        ajaxUrl: 'ajaxcart/index/add'
                    },
                    elements: {
                        addToCartButton: '.btn-cart',
                        qty: 'input.qty',
                        target: this,
                        minicartTarget: 'minicart-dropdown',
                        notificationsBlock: '#messages_product_view'
                    },
                    documentReady: {
                        onClick: null,
                        onHover: null,
                        btnLoad: null
                    },
                    validation: {
                        init: null,
                        getProductConfiguration: null,
                        checkConfigurableAttributes: null,
                        stockCheck: null,
                        error: null,
                        success: null,
                        validateSimpleChildren: true,
                        validateInputs: true
                    },
                    ajax: {
                        init: null,
                        data: null,
                        request: null,
                        success: null,
                        error: null
                    },
                    display: {
                        loading: null,
                        miniCart: null,
                        miniCartAfter: null,
                        popup: null,
                        inline: null,
                        success: null,
                        error: null,
                        message: null,
                        messages: null,
                        buildInlineMessage: null,
                        resetButton: null,
                        consoleLog: null,
                        defaultAjaxMessage: 'There was an error while processing your request. Please try again later.',
                        errorNoAddToCartButtonMessage: 'Could not find add to cart button',
                        errorWhileAddingMessage: 'An error occurred when trying to add this product to your basket',
                        errorAllOptionsMessage: 'Please specify all required options',
                        errorValidQuantityMessage: 'Please select a valid quantity',
                        quantityNotAvailableMessage: 'The requested quantity is not available.',
                        addingToCartText: 'Adding&hellip;',
                        addedToCartText: 'Added',
                        ajaxCartCloseText: 'close',
                        successResetDelay: 4000,
                        minicartCloseDelay: 6000
                    },
                    console: {
                        active: false,
                        log: false
                    }
                };

                var productData = null;

                /*
			 DOM READY
			 */

                settings.documentReady.onClick = function(settings, e) {
                    e.preventDefault();
                    // Loading state
                    settings.display.loading(settings);
                    // Initialise validation
                    settings.validation.init(settings);
                }
                ;

                settings.documentReady.onHover = function(settings, e) {}
                ;

                settings.documentReady.onLoad = function(settings, e) {}
                ;

                /*
			 VALIDATION
			 */

                settings.validation.init = function(settings) {

                    settings.console.log(settings, 'settings.validation.init');

                    // Get the product configuration data
                    var productData = settings.validation.getProductConfiguration(settings);

                    if (productData) {

                        // Check there is sufficient stock
                        var available = true;
                        if (productData.productType === 'simple' || productData.productType === 'configurable' && settings.validation.validateSimpleChildren) {
                            available = settings.validation.stockCheck(settings, productData)
                        }

                        if (available) {
                            settings.console.log(settings, productData);
                            settings.validation.success(settings);
                        }
                    }
                }
                ;

                settings.validation.getProductConfiguration = function(settings) {
                    settings.console.log(settings, 'settings.validation.getProductConfiguration');

                    var data = false;

                    if (productData) {
                        data = productData;
                    } else {
                        data = JSON.parse(settings.elements.target.find('div[data-product]').attr('data-product'));
                        var requiredProps = ['productId', 'productType', 'Qty'];

                        // Check product data has required fields
                        requiredProps.forEach(function(item) {
                            if (!data.hasOwnProperty(item)) {
                                // If data is missing, call validation error
                                settings.validation.error(settings, 'Missing product data: ' + item);
                                settings.display.error(settings, settings.display.errorWhileAddingMessage);
                                data = false;
                            }
                        });
                    }

                    if (!data)
                        return false;

                    // If configurable product, validate configurable data
                    if (data.productType === 'configurable') {
                        data = settings.validation.checkConfigurableAttributes(settings, data);
                    } else if (data.productType === 'giftcard') {
                        data = settings.validation.checkGiftCardAttributes(settings, data);
                    }

                    return data;
                }
                ;

                settings.validation.checkGiftCardAttributes = function(settings, productData) {

                    settings.console.log(settings, 'settings.validation.checkGiftCardAttributes');

                    var isValid = true;

                    // Validate that user has selected attribute options
                    if (settings.validation.validateInputs) {
                        var inputs = $('.giftcard-form .required-entry');
                        inputs.each(function() {
                            var el = $(this);
                            Validation.validate(this);
                            var checkInputValid = ((el.prop('required') || el.hasClass('required') || el.hasClass('required-entry')) && !this.value) || el.hasClass('validation-failed');
                            if (checkInputValid) {
                                settings.display.error(settings, settings.display.errorAllOptionsMessage);
                                isValid = false;
                            }
                        });
                    }

                    if (!isValid)
                        return false;

                    return productData;
                }
                ;

                settings.validation.checkConfigurableAttributes = function(settings, productData) {

                    settings.console.log(settings, 'settings.validation.checkConfigurableAttributes');

                    if (!productData.configuration || !productData.products) {
                        settings.validation.error(settings, 'missing configurable data');
                        settings.display.error(settings, 'An error occurred when trying to add this product to your basket');
                        return false;
                    }

                    var isValid = true;

                    // Validate that user has selected attribute options
                    if (settings.validation.validateInputs) {
                        var selects = $('.super-attribute-select');
                        selects.each(function() {
                            var el = $(this);
                            Validation.validate(this);
                            if (el.prop('required') && !this.value) {
                                settings.display.error(settings, settings.display.errorAllOptionsMessage);
                                isValid = false;
                            }
                        });
                    }

                    if (!isValid)
                        return false;

                    // Get the last select, from which we can infer the chosen simple product
                    // TODO: There should be a logical way to do this without relying on HTML sort order
                    var select = $('.super-attribute-select').last();
                    var selectAttrId = select.attr('id').substring(9);
                    // e.g. Get "180" from "attribute180"
                    var selectAttrOption = select.val();

                    // Get the simple product object, which contains the qty
                    try {
                        var simpleProductId = productData.configuration.attributes[selectAttrId].options[selectAttrOption].products[0];
                    } catch (err) {
                        settings.validation.error(settings, err);
                        settings.display.error(settings, 'An error occurred when trying to add this product to your basket');
                        return false;
                    }

                    // Create new prop in the object with the selected product ID and qty
                    productData.selectedProduct = simpleProductId;
                    return productData;

                }
                ;

                settings.validation.stockCheck = function(settings, productData) {

                    settings.console.log(settings, 'settings.validation.stockCheck');

                    var qtyInput = settings.elements.target.find(settings.elements.qty);
                    var qtyInputVal = qtyInput.val();
                    var stock = productData.productType === 'configurable' ? productData.products[productData.selectedProduct].Qty : productData.qty;
                    var isValid = false;

                    switch (true) {
                    case (qtyInput.length < 1 && settings.validation.validateInputs):
                        settings.display.error(settings, settings.display.errorValidQuantityMessage);
                        break;
                    case (!$.isNumeric(qtyInputVal) && settings.validation.validateInputs):
                        settings.display.error(settings, settings.display.errorValidQuantityMessage);
                        break;
                    case ((typeof qtyInputVal == 'undefined' || qtyInputVal < 1) && settings.validation.validateInputs):
                        settings.display.error(settings, settings.display.errorValidQuantityMessage);
                        break;
                    case (qtyInputVal > stock):
                        settings.display.error(settings, settings.display.quantityNotAvailableMessage);
                        break;
                    default:
                        isValid = true;
                    }

                    return isValid;

                }
                ;

                settings.validation.error = function(settings, error) {
                    settings.console.log(settings, 'settings.validation.error');
                    settings.display.error(settings, error);
                }
                ;

                settings.validation.success = function(settings) {
                    settings.console.log(settings, 'settings.validation.success');
                    settings.ajax.init(settings);
                }
                ;

                /*
			 AJAX
			 */

                settings.ajax.init = function(settings) {
                    settings.console.log(settings, 'settings.ajax.init');

                    // Prepare the data
                    var data = settings.ajax.data(settings);
                    // Make ajax call
                    settings.ajax.request(settings, data);
                }
                ;

                settings.ajax.data = function(settings) {
                    settings.console.log(settings, 'settings.ajax.data');

                    //build request parameters
                    var data = $('#product_addtocart_form').serialize();
                    data += '&isAjax=1';

                    return data;
                }
                ;

                settings.ajax.request = function(settings, data) {
                    settings.console.log(settings, 'settings.ajax.request');

                    try {
                        $.ajax({
                            url: settings.init.ajaxUrl,
                            dataType: 'json',
                            type: 'post',
                            data: data,
                            success: function(data) {
                                settings.console.log(settings, 'ajax success method');
                                settings.console.log(settings, data.error);
                                if (data.error == false) {
                                    settings.ajax.success(settings, data);
                                } else if (data.error == true) {
                                    settings.ajax.error(settings, data.message);
                                }
                            },
                            error: function() {
                                settings.console.log(settings, 'ajax error method');
                                settings.display.error(settings, settings.display.defaultAjaxMessage);
                            }
                        });
                    } catch (e) {
                        settings.console.log(settings, 'ajax catch method');
                        settings.display.error(settings, settings.display.defaultAjaxMessage);
                    }
                    return this;
                }
                ;

                settings.ajax.success = function(settings, data) {

                    settings.console.log(settings, 'settings.ajax.success');

                    switch (settings.init.ajaxCartType) {
                    case '1':
                        //TYPE_MINICART
                        settings.display.miniCart(settings, data);
                        break;
                    case '2':
                        //TYPE_INLINE
                        settings.display.inline(settings, data);
                        break;
                    case '3':
                        //TYPE_POPUP
                        settings.display.popup(settings, data);
                        break;
                    default:
                        //TYPE_INLINE
                        settings.display.inline(settings, data);
                    }

                    if (settings.display.isInlineNotificationsEnabled)
                        settings.display.notifications(settings, data);

                    if (window.freeGiftProduct === true) {
                        window.location.href = (settings.init.cartUrl);
                    }

                    $('.messages').remove();
                }
                ;

                settings.ajax.error = function(settings, data) {

                    $('.messages').remove();

                    $('.product-view').prepend(data);

                    settings.console.log(settings, 'settings.ajax.error');

                    settings.display.error(settings, data);
                }
                ;

                /*
			 DISPLAY
			 */

                settings.display.loading = function(settings) {
                    settings.console.log(settings, 'settings.display.loading');

                    var button = settings.elements.target.find(settings.elements.addToCartButton);
                    // Hide existing text
                    button.children().hide();
                    // Add class, disable and prepend text
                    button.addClass('btn-cart-adding').prop('disabled', true).prepend('<span class="btn-cart-state">' + settings.display.addingToCartText + '</span>');
                }
                ;

                settings.display.resetButton = function(settings) {
                    settings.console.log(settings, 'settings.display.resetButton');

                    var button = settings.elements.target.find(settings.elements.addToCartButton);
                    button.removeClass('btn-cart-adding btn-cart-added').prop('disabled', false).children().show();
                    button.children('.btn-cart-state').remove();
                }
                ;

                settings.display.miniCart = function(settings, data) {

                    settings.console.log(settings, 'settings.display.miniCart');

                    $("#minicart-block").html(data.sidebar);

                    $(".info-top-bar .counter a").text(data.count);

                    settings.display.miniCartAfter(settings);

                    settings.display.success(settings);

                    // Display message
                    settings.display.message(settings, 'success', data.message);

                }
                ;

                settings.display.miniCartAfter = function(settings) {

                    settings.console.log(settings, 'settings.display.miniCartAfter');

                    // Open mini cart dropdown
                    var minicartDropdown = jQuery('#' + settings.elements.minicartTarget);
                    minicartDropdown.fadeIn();

                    // Close minicart after X seconds, if user is not hovering
                    window.setTimeout(function() {
                        if (!minicartDropdown.is(':hover')) {
                            minicartDropdown.fadeOut();
                        }
                    }, settings.display.minicartCloseDelay);

                }
                ;

                settings.display.popup = function(settings, data) {
                    settings.console.log(settings, 'settings.display.popup');

                    var overlay = $('<div class="ajaxcart-overlay"></div>');
                    var modal = $('<div class="ajaxcart-modal"></div>');
                    var modalContent = $('<div class="ajaxcart-modal-content">' + data.messages + '</div>');
                    var close = $('<button class="ajaxcart-close"><span class="ajaxcart-close-text">' + settings.display.ajaxCartCloseText + '</span>&#10006;</button>');

                    $('body').append(overlay);
                    overlay.append(modal);
                    modal.append(modalContent);
                    modal.append(close);

                    settings.display.success(settings);
                }
                ;

                settings.display.inline = function(settings, data) {

                    settings.console.log(settings, 'settings.display.inline');
                    settings.display.message(settings, 'success', data.message);
                    settings.display.success(settings);
                }
                ;

                settings.display.message = function(settings, type, message) {

                    // Valid types: "success", "notice", "error"
                    settings.console.log(settings, 'settings.display.message');

                    if (settings.init.isInlineNotificationsEnabled && (settings.init.ajaxCartType == 1 || settings.init.ajaxCartType == 2)) {
                        // MINI CART OR INLINE

                        if (message.indexOf('</div>') > -1) {
                            console.log('msg has HTML');
                            settings.display.notifications(settings, message);
                        } else {
                            console.log('msg doesnt have HTML');
                            console.log(message);
                            console.log(typeof message);
                            settings.display.buildInlineMessage(settings, type, message);
                        }

                    } else if (settings.init.ajaxCartType == 3) {
                        // POPUP

                        console.log('settings.display. popup');

                        settings.display.popup(settings, {
                            message: message
                        });

                    }

                }
                ;

                settings.display.notifications = function(settings, notification) {

                    settings.console.log(settings, 'settings.display.notification');

                    var notificationsBlock = $(settings.elements.notificationsBlock);

                    if (notificationsBlock.length > 0)
                        $(settings.elements.notificationsBlock).html(notification);

                }
                ;

                settings.display.buildInlineMessage = function(settings, type, message) {

                    settings.console.log(settings, 'settings.display.buildInlineMessage');

                    var messagesWrapper = $(settings.elements.notificationsBlock);
                    var messagesList = $('<div class="messages"></div>');
                    var messageItem = $('<div class="alert-box ' + type + '">' + message + '</div>');
                    var messageClose = $('<a href="#" class="close">×</a>');

                    messagesWrapper.html(messagesList);
                    messagesList.append(messageItem);
                    messageItem.append(messageClose);

                }
                ;

                settings.display.success = function(settings, data) {
                    settings.console.log(settings, 'settings.display.success');
                    // Show success state in button, then reset after X seconds
                    var button = $(settings.elements.addToCartButton);
                    button.removeClass('btn-cart-adding').addClass('btn-cart-added').find('.btn-cart-state').text(settings.display.addedToCartText);
                    window.setTimeout(function() {
                        settings.display.resetButton(settings);
                    }, settings.display.successResetDelay);
                }
                ;

                settings.display.error = function(settings, msg) {
                    settings.console.log(settings, 'settings.display.error');
                    settings.display.message(settings, 'error', msg);
                    settings.display.resetButton(settings);
                }
                ;

                settings.console.log = function(settings, message) {
                    if (settings.console.active) {
                        console.log(message);
                    }
                }
                ;

                // Merge defaults with any configured overrides
                for (var obj in settings) {
                    if (options && options.hasOwnProperty(obj)) {
                        settings[obj] = $.extend({}, settings[obj], options[obj]);
                    }
                }

                return this.each(function() {
                    settings.console.log(settings, 'document.ready');

                    settings.console.log(settings, settings.init);

                    // Check button exists
                    // if ($(settings.elements.addToCartButton).length < 1) {
                    // 	settings.validation.error(settings, settings.display.errorNoAddToCartButtonMessage);
                    // }

                    // Connect button to onClick setting
                    settings.elements.target.on('click', settings.elements.addToCartButton, function(e) {
                        settings.documentReady.onClick(settings, e);
                    });

                    // Connect button to onHover setting
                    settings.elements.target.on('hover', settings.elements.addToCartButton, function(e) {
                        settings.documentReady.onHover(settings, e);
                    });

                    // Connect button to onLoad setting
                    settings.elements.target.on('load', settings.elements.addToCartButton, function(e) {
                        settings.documentReady.onLoad(settings, e);
                    });

                    // Close popup
                    $(document).on('click', '.ajaxcart-close, .ajaxcart-overlay', function() {
                        $(this).closest('.ajaxcart-overlay').remove();
                    });

                    //Close message alert popup
                    $(document).on('click', '.messages .close', function() {
                        $(this).closest('.messages').remove();
                    })

                });

            }
        });
        // end jQuery.fn.extend

    }
    // end if typeof jQuery !== 'undefined'

}(jQuery));

function ospreyInitBasketQuantityUpdate() {

    jQuery(document).on('change focus paste keyup', '#shopping-cart-table .input-text', function(e) {
        var itemId = jQuery(this).data('cart-item-id');
        jQuery('.update-' + itemId).removeClass('hide');
    });

    jQuery(document).on('click', '#shopping-cart-table .btn-product-update', function(e) {
        e.preventDefault();
        jQuery('button[name="update_cart_action"].btn-update').click();
    });
}
function blogComments() {
    var commentList = jQuery('#comments .comment-list')
      , commentChild = commentList.find('.children')
      , allComments = jQuery('.comment.depth-1')
      , readMore = jQuery('span.read-all-comments')
      , commentForm = jQuery('#commentform');

    //Add attribute form for validation
    commentForm.attr('data-abide', 'data-abide');

    commentChild.addClass('small-12 medium-10 medium-offset-2 columns');

    //Create more/less buttons for comments on level 0
    // allComments.slice(0, 2).show();
    //
    // readMore.on('click', function(){
    //     var _this = jQuery(this);
    //
    //     if (_this.hasClass('more')) {
    //         allComments.show('slow');
    //         _this.removeClass('more').addClass('less').text('read less comments');
    //     } else {
    //         allComments.slice(2).hide('slow');
    //         _this.removeClass('less').addClass('more').text('read more comments');
    //     }
    //
    // });
    //
    // //Create more/less buttons for children comments
    // var childrenComments = jQuery('#comments .comment .children');
    //
    // childrenComments.each(function() {
    //     var _this = jQuery(this),
    //         commentChild = _this.find('li.comment.depth-2'),
    //         countComments = commentChild.length,
    //         allDiscussions = jQuery('<span class="button read-all-disc more">Read discussion</span>'),
    //         lastItem = _this.find('li.comment.depth-2:last-child');
    //
    //     commentChild.slice(0, 3).show();
    //
    //     if ((countComments) > 3){
    //         allDiscussions.insertAfter(lastItem);
    //     }
    //
    //     _this.find('.read-all-disc').on('click', function(){
    //         var elem = jQuery(this);
    //
    //         if (elem.hasClass('more')){
    //             elem.removeClass('more').addClass('less').text('Read less discussion');
    //             commentChild.show("slow");
    //         } else {
    //             commentChild.slice(3).hide('slow');
    //             elem.removeClass('less').addClass('more').text('Read discussion');
    //         }
    //
    //     });
    // });
}
function categoryPage() {

    jQuery(".filters-container-desktop").on('sticky_kit:bottom', function(e) {
        jQuery(this).parent().css('position', 'static');
    }).on('sticky_kit:unbottom', function(e) {
        jQuery(this).parent().css('position', 'relative');
    }).stick_in_parent({
        offset_top: 80
    });

    jQuery(".breadcrumbs-container").insertAfter(".hero").insertAfter(".filters-container");

    jQuery('.breadcrumbs li:last-child').addClass("current");

    jQuery('.filter-block-header').on('touchstart', function(e) {
        jQuery(e.target).trigger('click');
        e.preventDefault();
    });

    jQuery.removeCookie('cat-option-id', {
        path: '/'
    });
    jQuery.removeCookie('cat-product-id', {
        path: '/'
    });

}

function cloneFiltersState() {

    var selectedFiltersDesktop = jQuery('.filters-container-desktop .amshopby-currently');
    var selectedFiltersTablet = jQuery('.filters-container .amshopby-currently');

    if (selectedFiltersTablet.length) {
        selectedFiltersTablet.html(selectedFiltersDesktop.html());
    } else {
        jQuery('.amshopby-filters-left').after(selectedFiltersDesktop.clone().addClass('currently-tablet'));
    }

    if (jQuery(window).width() <= 1024) {
        amshopby_ajax_init();
    }

    jQuery('.filter-block-header').on('touchstart', function(e) {
        jQuery(e.target).trigger('click');
        e.preventDefault();
    });

}

var initCheckoutPage = {
    all: function() {
        this.clickEvents();
        this.paymentMethods();
    },

    clickEvents: function() {
        jQuery(".input-different-shipping input").on('click', function() {
            if (jQuery(this).is(':checked')) {
                jQuery('#shipping_address').fadeIn('fast');
            } else {
                jQuery('#shipping_address').fadeOut('fast');
            }
            reflowAbide();
        });

        jQuery("#id_create_account").on('click', function() {
            if (jQuery(this).is(':checked')) {
                jQuery('#onestepcheckout-li-password').fadeIn('fast');
            } else {
                jQuery('#onestepcheckout-li-password').fadeOut('fast');
            }

            reflowAbide();
            setupHandleFormSubmitEvent();
        });
    },

    paymentMethods: function() {
        var radioInput = jQuery('input:radio[name="payment[method]"]');
        var cashOnDelivery = jQuery('#container_payment_method_cashondelivery')
          , safePayDirectPro = jQuery('#container_payment_method_sagepaydirectpro')
          , safePayPal = jQuery('#container_payment_method_sagepaypaypal')
          , paymentMethod = jQuery(".payment-method");

        radioInput.change(function() {
            paymentMethod.hide();
            if (jQuery(this).val() == 'cashondelivery') {
                paymentMethod.removeClass('active');
                cashOnDelivery.addClass('active').show();
            } else if (jQuery(this).val() == 'sagepaydirectpro') {
                paymentMethod.removeClass('active');
                safePayDirectPro.addClass('active').show();
            } else if (jQuery(this).val() == 'sagepaypaypal') {
                paymentMethod.removeClass('active');
                safePayPal.addClass('active').show();
            }
        });
    }
}

jQuery(function() {
    initCheckoutPage.all();
});

jQuery(document).on('reInitCheckoutPage', function() {
    initCheckoutPage.paymentMethods();
});

var configOptionsStockValidation = {

    init: function() {

        this.getElements();

        if (this.validate()) {
            this.getData();
            this.getAttributeCodes();
            this.bindEvents();
        }

        if (Product.isSalable) {
            this.setOutOfStockStatus();
        }
    },

    getElements: function() {
        this.colorSelect = jQuery('#attribute92');
        this.colorUiButtons = jQuery('#configurable_swatch_color').find('.swatch-link');
        this.sizeUiButtons = jQuery('.size-select-option');
        this.sizeSelect = jQuery('#attribute205');
        this.dataElement = jQuery('[data-product]');
    },

    validate: function() {

        return (this.colorSelect.length && this.colorUiButtons.length && this.sizeUiButtons.length && this.sizeSelect.length && this.dataElement.length && Product.isSalable)

    },

    bindEvents: function() {

        this.colorUiButtons.click(function() {
            if (this.parentNode.classList.contains('not-available'))
                return;
            configOptionsStockValidation.handleColourChange(this);
        });

    },

    getData: function() {
        var element = this.dataElement;
        this.data = JSON.parse(element.attr('data-product'));
    },

    getAttributeCodes: function() {
        this.colourAttributeCode = this.colorSelect.attr('name').replace(/\D/g, '');
    },

    handleColourChange: function(element) {

        var colourAttributeValue = jQuery(element).attr('id').replace(/\D/g, '');

        this.checkStock(colourAttributeValue, function(colourAttributeValue) {
            configOptionsStockValidation.toggleOptions(colourAttributeValue);
        });

    },

    checkStock: function(colourAttributeValue, callback) {

        var availableSizes = [];

        if (this.data.configuration.attributes[this.colourAttributeCode].options[colourAttributeValue]) {

            var products = this.data.configuration.attributes[this.colourAttributeCode].options[colourAttributeValue].products;

            products.forEach(function(productId) {

                var product = configOptionsStockValidation.data.products[productId];
                if (product.Qty > 0)
                    availableSizes.push(product.Size);

            });

        }

        callback(availableSizes);

    },

    toggleOptions: function(availableSizes) {

        this.sizeUiButtons.each(function() {
            var element = jQuery(this);
            var button = element.children();
            var value = button.attr('data-val');
            var isEnabled = availableSizes.indexOf(value) > -1;
            if (isEnabled) {
                element.removeClass('disabled tooltippy').removeAttr('data-tooltippy')

            } else {
                console.log(storeView);
                if (storeView != 'eu_en') {
                    element.attr('data-tooltippy', outOfStockText).addClass('disabled tooltippy');
                }
                button.removeClass('size-select-option-button-selected');
                if (configOptionsStockValidation.sizeSelect[0].value == value)
                    configOptionsStockValidation.sizeSelect.val('');
            }
            //button.prop('disabled', !isEnabled); //commented out for OSPS-1072
        });

    },

    setOutOfStockStatus: function() {

        this.sizeUiButtons.each(function() {
            var element = jQuery(this);
            console.log(storeView);
            if (storeView != 'eu_en') {
                element.attr('data-tooltippy', outOfStockText).addClass('disabled tooltippy');
            }
        });

    }
};

function initConfigurableSwatches() {

    if (typeof configurableMediaImagesArray !== 'undefined' && configurableMediaImagesArray.length) {
        configurableMediaImagesArray.forEach(function(object, index) {
            ConfigurableMediaImages.init(object.imageType);
            for (var product in object.imageFallbacks) {
                ConfigurableMediaImages.setImageFallback(product, object.imageFallbacks[product]);
            }
            jQuery(document).trigger('configurable-media-images-init', ConfigurableMediaImages);
        });
    }

}

function giftCardAmounts() {

    var amountSelect = jQuery('#giftcard_amount');

    if (amountSelect.length) {

        var fullLabels = jQuery('#giftcard_amount option');

        var fullLabelEl = jQuery('#amount_label_select');

        var options = amountSelect.children();

        var list = jQuery('<ul class="amount-select"></ul>').insertAfter(amountSelect);

        options.each(function() {

            var el = jQuery(this);

            var listItem = jQuery('<li class="amount-select-option"></li>').appendTo(list);

            var label = fullLabels.hasOwnProperty(el.text()) ? fullLabels[el.text()] : el.val();

            var box = jQuery('<button class="amount-select-option-button secondary" type="button" data-full-label="' + label + '" data-val="' + el.val() + '">' + el.text() + '</button>').appendTo(listItem);

            box.click(function(e) {

                e.stopPropagation();
                e.preventDefault();

                var el = jQuery(this);
                jQuery('.amount-select-option-button').removeClass('amount-button-selected');
                el.addClass('amount-button-selected');
                amountSelect.val(el.attr('data-val'));
                fullLabelEl.text(el.attr('data-full-label'));

            });

        });

    }
}

function giftDatePicker() {

    const date = new Date();

    const dateInput = document.getElementById('giftcard_send_date');

    const picker = new Pikaday({
        field: dateInput,
        defaultDate: moment().toDate(),
        setDefaultDate: true,
        format: 'D MMM YYYY',
        position: 'bottom left',
        minDate: moment().toDate(),
        maxDate: new Date(date.getTime() + (182 * 24 * 60 * 60 * 1000)),
        onClose: function() {

            if ((Foundation.utils.is_small_only() || Foundation.utils.is_medium_only()) && dateInput) {

                const header = jQuery('#header-mobile');
                const offset = jQuery(dateInput).offset().top - (header.height() + 30);

                jQuery(window).animate({
                    scrollTop: offset
                });

            }

        }
    })
}

function instagramFeed() {
    var container = jQuery('.fs-entry-container');

    if (container.length != 0) {
        jQuery('.instagram-feed').prepend('<h3>#OspreyEurope: Join the Adventure</h3>');
    }
}
Object.filter = function(obj, predicate, singleton) {
    var result = {}, key;
    // ---------------^---- as noted by @CMS,
    //      always declare variables with the "var" keyword

    for (key in obj) {
        if (obj.hasOwnProperty(key) && predicate(obj[key])) {
            result[key] = obj[key];
        }
    }

    if (singleton) {
        var key = Object.keys(result)[0];
        result = result[key];
    }

    return result;
}
;
"use strict";

var newsletterPopup = {
    cookieName: 'osprey-newsletter-popup',
    element: '.newsletter-popup',
    overlay: '.newsletter-popup-overlay',
    cookieLifetimeDays: 90,
    desktopDisplaySeconds: 15,
    mobileDisplaySeconds: 10,
    mobileUpperLimit: '700px',

    init: function() {
        if (this.getNewsletterCookie() === true)
            return;

        this.$element = jQuery(this.element);
        this.$overlay = jQuery(this.overlay);
        this.$close = this.$element.find('.close');

        if (this.$element.length < 1)
            return;

        var timeSeconds = this.isMobile() ? this.mobileDisplaySeconds : this.desktopDisplaySeconds;
        setTimeout(this.showPopUp.bind(this), timeSeconds * 1000);

        this.$close.on('click', this.hidePopUp.bind(this));
        this.$overlay.on('click', this.hidePopUp.bind(this));
    },

    showPopUp: function() {
        this.$element.addClass('show');
        this.$overlay.addClass('show');
    },

    hidePopUp: function() {
        this.$element.removeClass('show');
        this.$overlay.removeClass('show');
        this.setNewsletterCookie();
    },

    setNewsletterCookie: function() {
        jQuery.cookie(this.cookieName, '1', {
            expires: this.cookieLifetimeDays,
            path: '/'
        });
    },

    getNewsletterCookie: function() {
        return parseInt(jQuery.cookie(this.cookieName)) === 1 ? true : false;
    },

    isMobile: function() {
        return window.matchMedia('(max-width: ' + this.mobileUpperLimit + ')').matches;
    }
};
function productMediaGallery() {

    var mainImageBlock = jQuery('#catalog-product-view-slider').not('.slick-initialized');

    mainImageBlock.on('init', function() {
        onProductConfigSwatchesInit();
    });

    // Main image slider
    mainImageBlock.slick({
        swipeToSlide: true,
        mobileFirst: true,
        dots: true,
        responsive: [{
            breakpoint: 640,
            settings: {
                dots: false
            }
        }, {
            breakpoint: 1225,
            settings: {
                dots: false,
                arrows: false
            }
        }]
    });

    mainImageBlock.on('init', function() {
        jQuery(document).trigger('main-gallery-init');
    });

    if (Foundation.utils.is_medium_only()) {
        jQuery(document).on('click', '.product-thumb-anchor', function() {
            var parent = jQuery(this).closest('.product-thumb');
            parent.addClass('product-thumb-active').siblings().removeClass('product-thumb-active');
            mainImageBlock.slick('slickGoTo', parent.index());
        });
    }

    jQuery('.swatch-link').on('click', function() {
        var slideShow = jQuery('#catalog-product-view-slider');
        var swatchColor = jQuery(this).attr('title');
        var slideImage = jQuery('.gallery-image[data-label="' + swatchColor + '"]');
        var slideIndex = slideImage.parent().attr('data-slick-index');
        if (typeof slideIndex != "undefined") {
            slideShow.slick('slickGoTo', parseInt(slideIndex));
        }
    });

    if (Foundation.utils.is_medium_up()) {
        mainImageBlock.on('beforeChange', function(event, slick, currentSlide, nextSlide) {
            var thumb = Foundation.utils.is_large_up() ? jQuery('.product-thumb[data-slick-index="' + nextSlide + '"]') : jQuery('.product-thumb').eq(nextSlide);
            thumb.addClass('product-thumb-active').siblings().removeClass('product-thumb-active');
        });
    }

    if (Foundation.utils.is_large_up()) {

        var thumbnailsBlock = jQuery('#catalog-product-view-slider-thumbs').not('.slick-initialized');

        // Fix bug with Slick rendering vertical sliders
        thumbnailsBlock.on('init', function(event, slick) {
            window.setTimeout(function() {
                thumbnailsBlock.slick('setPosition');
            }, 500)
        });

        //Thumbnails slider
        thumbnailsBlock.slick({
            slidesToShow: 5,
            focusOnSelect: true,
            vertical: true,
            asNavFor: '#catalog-product-view-slider',
            focusOnSelect: false
        });

        thumbnailsBlock.find('.slick-track').children().on('click.slick', function(event) {

            var targetElement = jQuery(event.target).is('.slick-slide') ? jQuery(event.target) : jQuery(event.target).parents('.slick-slide');

            var index = parseInt(targetElement.attr('data-slick-index'));

            if (!index)
                index = 0;

            // Change main slider to correct slide, as normal
            mainImageBlock.slick('slickGoTo', index);

            // change thumb index, without animating or using slick
            thumbnailsBlock.slick('getSlick').currentSlide = index;
            thumbnailsBlock.slick('setSlideClasses', index);

            // Set active class on correct item
            thumbnailsBlock.find('.slick-track').children().removeClass('slick-current');
            targetElement.addClass('slick-current');

        });
    }

    if (jQuery('.gallery-image').length && jQuery('.pswp').length) {

        jQuery(document).on('click', '.gallery-image', function() {
            gid = jQuery(this).data('gid');
            if (gid === undefined || gid === '') {
                jQuery(this).closest('.product-main-image').find('img').each(function(index, item) {
                    jQuery(item).data('gid', index);
                });
                gid = jQuery(this).data('gid');
            }
            showGallery(gid);
        });

        var showGallery = function(gid) {
            // Build a list of images for PhotoSwipe to use
            var items = jQuery(".slick-slide").not(".slick-cloned").find(".gallery-image").map(function() {
                return {
                    src: jQuery(this).data('src'),
                    w: jQuery(this).data('width'),
                    h: jQuery(this).data('height')
                };
            });

            var options = {
                index: parseInt(gid),
                bgOpacity: 0.8,
                timeToIdle: 10000,
                zoomEl: false,
                shareEl: false
            };

            jQuery(".pswp__product-name").html(jQuery(".gallery-image").data('label'));

            // Initializes and opens PhotoSwipe
            var pswp_gallery = new PhotoSwipe(jQuery('.pswp')[0],PhotoSwipeUI_Default,items,options);

            pswp_gallery.init();
        };
    }

    var selectedSwatch = jQuery('.configurable-swatch-list li.selected');
    if (selectedSwatch.length) {
        selectedSwatch.children().trigger('click');
    }

}

function onProductConfigSwatchesInit() {
    var swatches = jQuery('.swatch-link');
    if (swatches.length)
        Product.ConfigurableSwatches.prototype.setAvailableOptions();
    autoSelectSwatch();
}

function autoSelectSwatch() {

    var swatches = jQuery('.swatch-link');
    var swatch;

    if (!swatches.length || typeof spConfig === 'undefined')
        return;

    if (typeof jQuery.cookie('cat-product-id') !== 'undefined' && typeof jQuery.cookie('cat-option-id') !== 'undefined' && jQuery('input[name=product]').val() == jQuery.cookie('cat-product-id')) {

        swatch = swatches.filter('[id="swatch' + jQuery.cookie('cat-option-id') + '"]').first();

    } else {

        var initialImage = jQuery('.gallery-image.initial-image').filter(function(index, element) {
            return !element.parentElement.classList.contains('slick-cloned');
        });

        if (initialImage.length) {
            let attr = Object.filter(spConfig.config.attributes, function(attr) {
                return attr.code === 'color';
            }, true);
            let option = Object.filter(attr.options, function(option) {
                return option.label === initialImage.attr('data-label');
            }, true);
            swatch = option ? jQuery('#swatch' + option.id) : swatches.first();
        } else {
            swatch = swatches.first();
        }

    }

    if (swatch.length)
        swatch.children().trigger('click');

}

function productRegistrationInit() {

    var loginPopup = jQuery('#login-modal');

    if (loginPopup.length) {
        loginPopup.foundation('reveal', 'open');
    }

    jQuery('#productregistration-exist-link').click(function() {
        loginPopup.foundation('reveal', 'close');
    });

}

function reviewsToggle() {

    var reviewContainer = jQuery('.total-review-container');
    var reviewButton = jQuery('.more-reviews-button');
    var scrollPos = 0;

    if (reviewButton.length && reviewContainer.length) {

        reviewContainer.find('.review-row.more').setStagger(200);

        jQuery('.more-reviews-button').on('click', function() {

            if (reviewContainer.hasClass('open')) {
                // Close it
                reviewContainer.find('.review-row.more').removeClass('show');
                reviewContainer.removeClass('open');

                reviewButton.find('.more').show();
                reviewButton.find('.less').hide();

                // If user cannot see review after closing, scroll them back up
                window.setTimeout(function() {
                    var reviewEl = jQuery('.total-review-container:visible');
                    var currentScrollPos = jQuery(document).scrollTop();
                    if (currentScrollPos > (reviewEl.offset().top + reviewEl.height())) {
                        jQuery('body, html').animate({
                            scrollTop: scrollPos + 'px'
                        }, 500);
                    }
                }, 100);

            } else {
                // Open it
                scrollPos = jQuery(document).scrollTop();

                reviewContainer.find('.review-row.more').addClass('show');
                reviewContainer.addClass('open');

                reviewButton.find('.more').hide();
                reviewButton.find('.less').show();
            }
        });

    }

}

function sctr_update() {

    jQuery('form[name="email_list_form"], form[name="post_list_form"]').on('click', '.stcr-subs-select-all', function() {
        var checkbox = jQuery('form[name="email_list_form"] table input[type="checkbox"]');

        checkbox.each(function() {
            jQuery(this).addClass('checked');
        });

    });
    jQuery('form[name="email_list_form"],form[name="post_list_form"]').on('click', '.stcr-subs-select-none', function() {
        var checkbox = jQuery('form[name="email_list_form"] table input[type="checkbox"]');

        checkbox.each(function() {
            jQuery(this).removeClass('checked');
        });

    });

    jQuery('form[name="email_list_form"] .stcr-subscription-list input[type="checkbox"]').on('click', function() {

        if (jQuery(this).hasClass('checked')) {
            jQuery(this).removeAttr('checked').removeClass('checked');
        } else {
            jQuery(this).attr('checked', 'checked').addClass('checked');
        }

    });
}
function sizeAttributeSelect() {

    var sizeSelect = jQuery('#attribute205');

    if (sizeSelect.length) {

        var fullLabels = {
            "": "One Size",
            "XL": "Extra Large",
            "L": "Large",
            "M/L": "Medium/Large",
            "M": "Medium",
            "S/M": "Small/Medium",
            "S": "Small",
            "WL": "Women's Large",
            "WM": "Women's Medium",
            "WS/M": "Women's Small/Medium",
            "WS": "Women's Small",
            "WXS": "Women's Extra Small"
        };

        var fullLabelEl = jQuery('#select_size_label');

        var options = sizeSelect.children().not(':first-child');

        var list = jQuery('<ul class="size-select"></ul>').insertAfter(sizeSelect);

        options.each(function() {

            var el = jQuery(this);

            var listItem = jQuery('<li class="size-select-option"></li>').appendTo(list);

            var label = fullLabels.hasOwnProperty(el.text()) ? fullLabels[el.text()] : el.val();

            var textLengthClass = 'string-length-' + el.text().length;

            var box = jQuery('<button class="size-select-option-button secondary ' + textLengthClass + '" type="button" data-full-label="' + label + '" data-val="' + el.val() + '" onclick="sizeSetActionButton(this)">' + el.text() + '</button>').appendTo(listItem);

            box.click(function(e) {

                e.stopPropagation();
                e.preventDefault();

                var el = jQuery(this);
                jQuery('.size-select-option-button').removeClass('size-select-option-button-selected');
                el.addClass('size-select-option-button-selected');
                sizeSelect.val(el.attr('data-val'));
                fullLabelEl.text(el.attr('data-full-label'));

            });

        });

    }

}

var color_attribute_id = 92;
var size_attribute_id = 205;

function getProductId(options) {
    var productId = false;
    jQuery.each(productsAttributes, function(i, val) {
        if (JSON.stringify([options]) === JSON.stringify(val).replace("},{", ",")) {
            productId = i;
            return false;
        }
    });
    return productId;
}

function hideStockAlertButtonShowAddToCart() {
    jQuery(".add-to-cart").removeClass('hide-for-small-up');
    jQuery(".stock-alert-button").addClass('hide-for-small-up');
}

function hideAddToCartShowStockAlertButton(productId) {
    jQuery(".add-to-cart").addClass('hide-for-small-up');
    jQuery('#stock-alert-product-id-' + productId).removeClass('hide-for-small-up');
}

function sizeSetActionButton(obj) {
    var color = jQuery("#attribute" + color_attribute_id).val();
    var size = jQuery(obj).data('val');

    if (size === "undefined") {
        sizeSetActionButton(obj);
    } else {

        var values = {};
        values[color_attribute_id] = color.toString();
        values[size_attribute_id] = size.toString();

        var productId = getProductId(values);
        var stock = productsStock[productId];

        hideStockAlertButtonShowAddToCart();
        if (stock === "0") {
            if (storeView != 'eu_en') {
                hideAddToCartShowStockAlertButton(productId);
            }
        }
    }
}

function colorSetActionButton(obj) {

    var color = jQuery(obj).data('option-id');

    if (jQuery("#attribute" + size_attribute_id).length) {
        hideStockAlertButtonShowAddToCart();
        return;
    }

    var values = {};
    values[color_attribute_id] = color.toString();
    var productId = getProductId(values);
    var stock = productsStock[productId];

    hideStockAlertButtonShowAddToCart();
    if (stock === "0") {
        if (storeView != 'eu_en') {
            jQuery(".add-to-cart").addClass('hide-for-small-up');
            hideAddToCartShowStockAlertButton(productId);
        }
    }
}
function storeFinderInit() {

    var geocoder;
    var map;
    var latLng;
    var homeMarker;
    var storeMarkers = new Array();
    var infoWindow;
    var directionsDisplay;
    var directionsService;
    var initialLoad = false;
    var activeStore = 1;
    var storeList;
    var loc;

    function getIpCity() {
        $("searchloading").show();
        loc = storefinder.user_country;
        $('currentLoc').update(loc);
        codeAddress(loc, true);
    }

    function initStoreFinderMap() {
        geocoder = new google.maps.Geocoder();
        var myOptions = {
            zoom: 16,
            streetViewControl: false,
            mapTypeId: google.maps.MapTypeId.ROADMAP,
            center: new google.maps.LatLng(-34.397,150.644)
        }
        map = new google.maps.Map(document.getElementById("map"),myOptions);
        google.maps.event.trigger(map, "resize");
        infoWindow = new google.maps.InfoWindow();

        directionsDisplay = new google.maps.DirectionsRenderer();
        directionsService = new google.maps.DirectionsService();
        directionsDisplay.suppressMarkers = true;
        directionsDisplay.setMap(map);
        if (storefinder.auto_load_location) {
            getIpCity();
        } else {
            codeAddress(storefinder.initial_address, true);
        }
    }

    function focusMap(storeId) {
        map.panTo(storeMarkers[storeId].position);
        infoWindow.close();
        infoWindow.setContent(storeMarkers[storeId].info);
        infoWindow.open(map, storeMarkers[storeId]);
        if (jQuery('#map:visible').length) {
            $("store-" + activeStore).removeClassName("activeStore");
            $("store-" + (storeId + 1)).addClassName("activeStore");
            activeStore = storeId + 1;
        }
    }

    function calcRoute(storeId) {
        var request = {
            origin: homeMarker.position,
            destination: storeMarkers[storeId].position,
            travelMode: google.maps.TravelMode["DRIVING"]
        };
        directionsService.route(request, function(response, status) {
            if (status == google.maps.DirectionsStatus.OK) {
                directionsDisplay.setDirections(response);
            }
        });
    }

    function codeAddress(address, isinitialLoad) {
        /*Clear the previous marker if it is there */
        $("searchloading").show();
        if (homeMarker != undefined) {
            homeMarker.setMap(null);
        }

        if (address == undefined) {
            address = jQuery('#address').val() + ' ' + jQuery('.country-select:visible option:selected').val();
            updateAddress = true;
        } else {
            updateAddress = false;
        }

        if (isinitialLoad == true) {
            limit = storefinder.num_results;
            initialLoad = true;
        } else {
            limit = 40;
            initialLoad = false;
        }

        /*We only want to get the address location if really needed*/
        geocoder.geocode({
            "address": address
        }, function(results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
                latLng = results[0].geometry.location;
                var addressCity = results[0].formatted_address;

                var arrAddress = results[0].address_components;
                var trackAddress = "";
                for (var i in arrAddress) {
                    try {
                        if (arrAddress[i].types[0] == "sublocality" || arrAddress[i].types[0] == "locality") {
                            if (trackAddress != "") {
                                trackAddress += ", ";
                            }
                            trackAddress += arrAddress[i].long_name;
                        } else if (arrAddress[i].types[0] == "country") {
                            var true_country = arrAddress[i].long_name;
                            jQuery(".country-select:visible option[value='" + true_country + "']").attr('selected', 'selected').siblings().removeAttr('selected', 'selected');
                            jQuery('.current_loc').remove();
                            jQuery(".country-select:visible").prepend(jQuery('<option selected="selected" class="current_loc" value="' + true_country + '">' + true_country + '</option>'));
                        }
                    } catch (e) {}
                }
                ;
                if (storefinder.ga_tracking && trackAddress != "" && initialLoad == false) {
                    try {
                        _gaq.push(['_trackEvent', 'Store Finder', 'Search', trackAddress]);
                    } catch (e) {}
                }

                if (jQuery('#address').val() != '') {
                    limit = 40;
                } else {
                    limit = storefinder.num_results;
                }
                new Ajax.Request(storefinder.search_url,{
                    method: 'get',
                    parameters: {
                        'lat': latLng.lat(),
                        'lng': latLng.lng(),
                        'limit': limit
                    },
                    onSuccess: function(transport) {
                        var bounds = new google.maps.LatLngBounds();
                        itemCount = 0;
                        if (initialLoad == false) {
                            $('storeList').update('');
                        }
                        // map.setCenter(latLng);
                        bounds.extend(latLng);
                        if (updateAddress) {
                            homeMarker = new google.maps.Marker({
                                map: map,
                                position: latLng,
                                icon: storefinder.home_pin,
                                info: '<strong>Your address:</strong><br/>' + addressCity
                            });
                            google.maps.event.addListener(homeMarker, 'click', function() {
                                infoWindow.close();
                                infoWindow.setContent(this.info);
                                infoWindow.open(map, this);
                                $("store-" + activeStore).removeClassName("activeStore");
                            });
                        }
                        if (storeMarkers) {
                            for (var i = 0; i < storeMarkers.length; i++) {
                                storeMarkers[i].setMap(null);
                            }
                        }
                        storeMarkers.length = 0;
                        while (transport.responseXML.getElementsByTagName("marker")[itemCount] != undefined) {
                            mrk = transport.responseXML.getElementsByTagName("marker")[itemCount];

                            storeElmt = storefinder.store_elements.replace(/\[title\]/g, mrk.getAttribute("title")).replace(/\[distance\]/g, mrk.getAttribute("distance")).replace(/\[address\]/g, mrk.getAttribute("address")).replace(/\[maplogo\]/g, mrk.getAttribute("maplogo")).replace(/\[maplogotag\]/g, mrk.getAttribute("maplogotag")).replace(/\[largelogo\]/g, mrk.getAttribute("largelogo")).replace(/\[largelogotag\]/g, mrk.getAttribute("largelogotag")).replace(/\[email\]/g, mrk.getAttribute("email")).replace(/\[url\]/g, mrk.getAttribute("url")).replace(/\[notes\]/g, mrk.getAttribute("notes")).replace(/\[phone\]/g, mrk.getAttribute("phone")).replace(/\[postcode\]/g, mrk.getAttribute("postcode")).replace(/\[city\]/g, mrk.getAttribute("city")).replace(/\[units\]/g, mrk.getAttribute("units")).replace(/\[urllink\]/g, mrk.getAttribute("urllink")).replace(/\[emaillink\]/g, mrk.getAttribute("emaillink")).replace(/\[num\]/g, itemCount + 1).replace(/\[lat\]/g, mrk.getAttribute("latitude")).replace(/\[lng\]/g, mrk.getAttribute("longitude"));
                            storeElmt = "<div onclick='focusMap(" + itemCount + ")'>" + storeElmt + "</div>";
                            StoreInfo = storefinder.store_map_layout;
                            StoreInfo = StoreInfo.replace(/\[title\]/g, mrk.getAttribute("title")).replace(/\[distance\]/g, mrk.getAttribute("distance")).replace(/\[address\]/g, mrk.getAttribute("address")).replace(/\[maplogo\]/g, mrk.getAttribute("maplogo")).replace(/\[maplogotag\]/g, mrk.getAttribute("maplogotag")).replace(/\[largelogo\]/g, mrk.getAttribute("largelogo")).replace(/\[largelogotag\]/g, mrk.getAttribute("largelogotag")).replace(/\[email\]/g, mrk.getAttribute("email")).replace(/\[url\]/g, mrk.getAttribute("url")).replace(/\[notes\]/g, mrk.getAttribute("notes")).replace(/\[phone\]/g, mrk.getAttribute("phone")).replace(/\[postcode\]/g, mrk.getAttribute("postcode")).replace(/\[city\]/g, mrk.getAttribute("city")).replace(/\[units\]/g, mrk.getAttribute("units")).replace(/\[urllink\]/g, mrk.getAttribute("urllink")).replace(/\[emaillink\]/g, mrk.getAttribute("emaillink")).replace(/\[num\]/g, itemCount + 1).replace(/\[lat\]/g, mrk.getAttribute("latitude")).replace(/\[lng\]/g, mrk.getAttribute("longitude"));

                            if (storefinder.show_route && updateAddress) {
                                StoreInfo += "<span class='showRoute' onclick='calcRoute(" + itemCount + ")'>Show Route</span>";
                            }

                            $('storeList').insert(storeElmt, {
                                position: 'content'
                            });

                            latLng = new google.maps.LatLng(mrk.getAttribute("latitude"),mrk.getAttribute("longitude"))
                            mapIcon = mrk.getAttribute("icon");
                            storeMarkers[itemCount] = new google.maps.Marker({
                                map: map,
                                position: latLng,
                                title: mrk.getAttribute("title"),
                                icon: mapIcon,
                                info: StoreInfo
                            });

                            storeMarkers[itemCount].set("storeId", (itemCount + 1));

                            google.maps.event.addListener(storeMarkers[itemCount], 'click', function() {
                                infoWindow.close();
                                infoWindow.setContent(this.info);
                                infoWindow.open(map, this);
                                $("store-" + activeStore).removeClassName("activeStore");
                                $("store-" + this.storeId).addClassName("activeStore");
                                activeStore = this.storeId;
                                if (storefinder.scroll_to_store) {
                                    window.location.hash = 'store-' + this.storeId;
                                }
                            });
                            bounds.extend(latLng);
                            itemCount++;
                        }
                        center = bounds.getCenter();
                        map.fitBounds(bounds);

                        jQuery('.country').val(true_country);
                        console.log(true_country);
                        if (true_country != "United Kingdom")
                            $('storeList').scrollTop = 0;
                        $('maploading').hide();
                        $("searchloading").hide();
                    }
                });
            } else {
                alert(storefinder.error_text);
            }
            $('maploading').hide();
        });
    }

    jQuery('.country').change(function() {
        var $addressValue = jQuery(this).val();
        codeAddress($addressValue);
        jQuery("#search-location").text("Nearest stores to your search for " + $addressValue);
    });

    jQuery("input").change(function() {
        var $addressValue = jQuery("#address").val() + ' ' + jQuery('.country:visible').val();
        jQuery("#search-location").text("Nearest stores to your search for " + $addressValue);
        codeAddress($addressValue);
    });

    initStoreFinderMap();

}

var ospreyTabs = {

    init: function() {

        var tabTitleBlock = jQuery('.tab-title-block');

        tabTitleBlock.each(function() {

            var block = jQuery(this);

            // Create slider and append
            var slider = jQuery('<span class="tabs-sliding-border hide"></span>');
            slider.appendTo(block);
            ospreyTabs.setCoords(slider, block.find('.tab-title.active'));
            slider.removeClass('hide');

            var tabTitles = block.find('.tab-title');

            // On hover of tab title, set position of slider
            tabTitles.hover(function() {
                ospreyTabs.setCoords(slider, jQuery(this));
            }, function() {
                ospreyTabs.setCoords(slider, block.find('.tab-title.active'));
            });

        });

    },

    setCoords: function(slider, target) {

        slider.css({
            'left': target.position().left + 25,
            'width': target.width() - 50
        });

    },

    reInit: function() {
        jQuery('.tabs-sliding-border').remove();
        ospreyTabs.init();
    }

};

function productThreeSixty() {

    var container = jQuery(".three-sixty-view-container");

    if (container.length) {

        var $counter = 1;
        var left360held = false;
        var right360held = false;
        var $sprite = jQuery(".three-sixty-view");
        jQuery($sprite).css({
            left: "0px"
        });
        var isMobile = Foundation.utils.is_small_only();

        setInterval(rotateLoop, 63);

        function rotateLoop() {
            if (left360held && !right360held) {
                rotate360Clockwise();
            } else if (!left360held && right360held) {
                rotate360AntiClockwise();
            }
        }

        // Rotates the 360 view left (ANTI-CLOCKWISE)
        function rotate360AntiClockwise() {
            if ($counter == 1) {
                $counter = 24;
                if (isMobile) {
                    jQuery($sprite).css({
                        left: "-6844px"
                    });
                } else {
                    jQuery($sprite).css({
                        left: "-8556px"
                    });
                }

            } else {
                $counter = $counter - 1;
                //jQuery($sprite).css({backgroundPosition:  "+=290px 0"});
                if (isMobile) {
                    jQuery($sprite).css({
                        left: "+=297px"
                    });
                } else {
                    jQuery($sprite).css({
                        left: "+=372px"
                    });
                }

            }
        }

        // Rotates the 360 view right (CLOCKWISE)
        function rotate360Clockwise() {
            if ($counter == 24) {
                //jQuery($sprite).css({backgroundPosition:  "0 0"});
                jQuery($sprite).css({
                    left: "0px"
                });
                $counter = 1;
            } else {
                $counter = $counter + 1;
                //jQuery($sprite).css({backgroundPosition:  "-=290px 0"});
                if (isMobile) {
                    jQuery($sprite).css({
                        left: "-=297px"
                    });
                } else {
                    jQuery($sprite).css({
                        left: "-=372px"
                    });
                }

            }
        }

        // When the left Arrow is clicked
        jQuery(".left-nav-arrow").on("mousedown touchstart", function(e) {
            e.preventDefault();
            left360held = true;
            right360held = false;
        }).on("mouseup touchend", function(e) {
            e.preventDefault();
            left360held = false;
        }).on("click", function(e) {
            e.preventDefault();
        });

        // When the right Arrow is clicked
        jQuery(".right-nav-arrow").on("mousedown touchstart", function(e) {
            e.preventDefault();
            right360held = true;
            left360held = false;
        }).on("mouseup touchend", function(e) {
            e.preventDefault();
            right360held = false;
        }).on("click", function(e) {
            e.preventDefault();
        });

        // Keyboard events
        jQuery(document.documentElement).keydown(function(event) {
            // handle cursor keys
            if (event.keyCode == 37) {
                // Left key
                left360held = true;
                right360held = false;
            } else if (event.keyCode == 39) {
                // Right key
                right360held = true;
                left360held = false;
            }
        }).keyup(function(event) {
            // handle cursor keys
            if (event.keyCode == 37) {
                // Left key
                left360held = false;
            } else if (event.keyCode == 39) {
                // Right key
                right360held = false;
            }
        });

        var container360Held = false;
        var containerMouseX = 0;
        var movement = 0;
        var movementAdder = 0;
        var movementThreshold = 20;

        container.swipe({
            swipeLeft: function() {
                left360held = true;
                right360held = false;
            },
            swipeRight: function() {
                right360held = true;
                left360held = false;
            }
        }).on("touchstart", function(e) {
            left360held = false;
            right360held = false;
        }).mousedown(function(e) {
            container360Held = true;
            containerMouseX = e.pageX;
        }).mouseup(function(e) {
            container360Held = false;
            left360held = false;
            right360held = false;
        });

        jQuery("body").mousemove(function(e) {
            e.preventDefault();
            if (container360Held) {
                movement = e.pageX - containerMouseX;
                movementAdder += movement;

                if (movementAdder < -movementThreshold) {
                    // Going left
                    rotate360Clockwise();
                    movementAdder += movementThreshold;
                } else if (movementAdder > movementThreshold) {
                    // Going right
                    rotate360AntiClockwise();
                    movementAdder -= movementThreshold;
                }
                containerMouseX = e.pageX;
            }
        }).mouseup(function(e) {
            container360Held = false;
            left360held = false;
            right360held = false;
        });

    }

}

//Tooltips for secondlife category

function ospreyTooltips() {
    var tooltipOsprey = jQuery('.osprey-tooltip');

    tooltipOsprey.on('click', function() {
        tooltipOsprey.removeClass('open');
        jQuery(this).addClass('open');
    });

    jQuery(document).on('click', function(e) {
        if (!tooltipOsprey.is(e.target) && tooltipOsprey.has(e.target).length === 0) {
            tooltipOsprey.removeClass('open');
        }
    })
}
(function($) {
    $.fn.setStagger = function(delay, start_delay) {
        var init = this.start_delay || 0;
        this.each(function(i) {
            var stagger = (delay * i) + init;
            $(this).attr('style', 'transition-delay: ' + stagger + 'ms');
        });
    }
    ;

    var logicspot = {
        /* =====================================
		 *  All pages
		 * ===================================*/
        common: {
            init: function() {
                $(document).foundation({
                    offcanvas: {
                        open_method: 'overlap_single'
                    },
                    equalizer: {
                        // Specify if Equalizer should make elements equal height once they become stacked.
                        equalize_on_stack: true
                    },
                    abide: {
                        timeout: 2000,
                        patterns: {
                            min_length: /^(.){3,}$/,
                            strong_password: /^\S*(?=\S{6,})(?=\S*[a-z])(?=\S*[A-Z])(?=\S*[\d])\S*$/
                        }
                    }
                });

                // Turn off abide input focus scrolling
                $('form[data-abide]').find('input, textarea, select').on('focus', function(e) {
                    $('html, body').stop();
                });

                //Fix email placeholder 
                const inputEmail = $('.manage-comment-subscriptions input.subscribe-form-field');

                inputEmail.val('').attr("placeholder", "Email");

                inputEmail.on('focusout blur', function(e) {
                    inputEmail.value = 'Email';
                    if (this.value == this.defaultValue)
                        this.value = '';
                    if (this.value == 'email')
                        this.value = this.defaultValue;
                    e.preventDefault();
                    e.stopPropagation();
                });

                //Cookies popup 
                var cookiePopup = $('.cookies-popup');

                if (cookiePopup.length) {

                    var cookieClose = cookiePopup.find('.popup-container .close');
                    cookieClose.on('click', function() {
                        cookiePopup.remove();
                    })
                }

                $('.vc-slider').on('initialized.owl.carousel', function(event) {
                    var slider = jQuery(event.target);
                    if (!slider.is(':visible'))
                        return;
                    if (Foundation.utils.is_small_only()) {
                        slider.each(function() {
                            var el = jQuery(this);
                            var activeItem = el.find('.owl-item.active');
                            var image = activeItem.find('.image-slider');
                            setTimeout(function() {
                                // Sorry. Dots aren't ready on init, and emmit no event :(
                                var dots = el.find('.owl-dots');
                                dots.attr('style', 'top:' + (image.height() - 30) + 'px');
                            }, 150);
                        });
                    }
                });

                $('.vc-slider').owlCarousel({
                    items: 1,
                    nav: true,
                    loop: true,
                    autoplay: true,
                    autoplayHoverPause: true,
                    onResized: function(event) {
                        $(event.target).find('autofocus').adjustFocus();
                    }
                });

                $(".checkout-cart-index #frequently-bought-widget").owlCarousel({
                    items: 2,
                    nav: true,
                    responsive: {
                        640: {
                            items: 2
                        }
                    }
                });

                $(".onestepcheckout-index-index #frequently-bought-widget").owlCarousel({
                    items: 2,
                    nav: true,
                    responsive: {
                        640: {
                            items: 4
                        },
                        1025: {
                            items: 2
                        }
                    }
                });

                $('.gallery-photoswipe').each(function() {
                    function getItems() {
                        var items = [];
                        $(this).find('a').each(function() {
                            var $href = $(this).attr('href')
                              , $size = $(this).data('size').split('x')
                              , $width = $size[0]
                              , $height = $size[1];

                            var item = {
                                src: $href,
                                w: $width,
                                h: $height
                            };

                            items.push(item);
                        });
                        return items;
                    }

                    var items = getItems();
                });

                var $pswp = $('.pswp')[0];
                $(this).on('click', 'figure', function(event) {
                    event.preventDefault();

                    var $index = $('figure').index(this);
                    var options = {
                        index: $index,
                        bgOpacity: 0.7,
                        showHideOpacity: true
                    };

                    // Initialize PhotoSwipe
                    var lightBox = new PhotoSwipe($pswp,PhotoSwipeUI_Default,items,options);
                    lightBox.init();
                });

                // MWI script
                // Check if setLocation is set
                if (typeof setLocation !== 'function') {
                    function setLocation(url) {
                        window.location.href = url;
                    }
                }

                initOffCanvasLeftActions();
                ospreyTabs.init();

                $(window).on('resize', Foundation.utils.throttle(function(e) {
                    ospreyTabs.reInit();
                }, 300));

                /*
				 * Show more reviews
				 */

                reviewsToggle();

                /**
				 * StCR fixing checkboxes 
				 */

                sctr_update();

                /*
				 * Review form
				 */
                var form_height;
                if (Foundation.utils.is_medium_up()) {
                    form_height = $('.new-review-form .form-add').height();
                } else {
                    form_height = 600;
                }
                var form_container = $('.new-review-form');

                $('.new-review-button').on('click', function() {
                    form_container.toggleClass('open');
                    if (form_container.hasClass('open')) {
                        $('.new-review-form').height(form_height);
                        $('.new-review-button .show-review-form').hide();
                        $('.new-review-button .hide-review-from').show();
                    } else {
                        $('.new-review-form').height(0);
                        $('.new-review-button .show-review-form').show();
                        $('.new-review-button .hide-review-from').hide();
                    }
                });

                if (typeof $readMoreText != 'undefined' && typeof $readLessText != 'undefined') {
                    $('.product-description-text').readmore({
                        collapsedHeight: 86,
                        speed: 100,
                        moreLink: '<a class="product-manual-link" href="#">' + $readMoreText + '</a>',
                        lessLink: '<a class="product-manual-link" href="#">' + $readLessText + '</a>',
                    });
                }

                $('.vc-photoswipe').each(function() {
                    var $pic = $(this)
                      , getItems = function() {
                        var items = [];
                        $pic.find('a').each(function() {
                            var $href = $(this).attr('href')
                              , $size = $(this).data('size').split('x')
                              , $width = $size[0]
                              , $height = $size[1];

                            var item = {
                                src: $href,
                                w: $width,
                                h: $height
                            };

                            items.push(item);
                        });
                        return items;
                    };

                    var items = getItems();

                    var $pswp = $('.pswp')[0];
                    $pic.on('click', 'a', function(event) {
                        event.preventDefault();

                        var $index = $(this).data('index');
                        var options = {
                            index: $index,
                            bgOpacity: 0.7,
                            showHideOpacity: true
                        };

                        // Initialize PhotoSwipe
                        var lightBox = new PhotoSwipe($pswp,PhotoSwipeUI_Default,items,options);
                        lightBox.init();
                    });
                });

                /*if(Foundation.utils.is_medium_up()) {

					var modal = $('#subscribe-modal-container'),
						cookieName = modal.attr('data-cookie-name');

					if (!jQuery.cookie(cookieName)) {
					    modal.foundation('reveal', 'open');
					    jQuery.cookie( cookieName, true, { expires: 365, path: '/' });
					}
				}*/

                $("a[href^='#'].scroll-to").on('click', function(e) {
                    var hash = $(this).attr("href")
                      , element = $(hash);

                    if (element.length > 0) {

                        logicspot.scrollPastHeader(function(offset) {

                            $('html, body').animate({
                                scrollTop: element.offset().top - offset
                            }, 2000);

                        });

                    }

                    e.preventDefault();

                });

                blogComments();
                jQuery(document).foundation('abide', 'reflow');

                //Change breadcrumbs for SecondLife Account Page
                if (jQuery(".second-life-container")) {
                    jQuery(".breadcrumbs-container").insertAfter(".second-life-container");
                }

                if (typeof configurableMediaImagesInit === 'function') {
                    configurableMediaImagesInit();
                }

                jQuery('.swatch-select').on('click', function() {
                    jQuery.cookie('cat-product-id', jQuery(this).data("product-id"), {
                        expires: 365,
                        path: '/'
                    });
                    jQuery.cookie('cat-option-id', jQuery(this).data("option-id"), {
                        expires: 365,
                        path: '/'
                    });
                });

                newsletterPopup.init();
                ajaxSubscribe.initForm('.newsletter-popup form');

            },
            finalize: function() {
                imageBlazy();
                initRemoveProductLink();
                initResponsiveTables();
                initConfigurableSwatches();
            }
        },

        scrollPastHeader: function(cb) {

            var firstScroll = $(window).scrollTop() <= 10 ? 10 : 1, firstScrollSpeed = $(window).scrollTop() <= 10 ? 250 : 10, offset;

            $('html, body').animate({
                scrollTop: '+=' + firstScroll + 'px'
            }, firstScrollSpeed).promise().then(function() {
                if (Foundation.utils.is_medium_up()) {
                    offset = $('.fixed-top-container.show-for-medium-up').height();
                } else {
                    offset = $('.fixed-top-container#header-mobile').height();
                }

                cb.call(this, offset);
            });

        },

        /* =====================================
		 *  Product pages
		 * ===================================*/
        catalog_product_view: {
            init: function() {
            },
            finalize: function() {
                setTimeout(function() {
                    instagramFeed();
                }, 2000);

                giftCardAmounts();

                sizeAttributeSelect();

                configOptionsStockValidation.init();

                giftDatePicker();

                if (typeof ajaxAddToCart === 'object') {
                    console.log(ajaxAddToCart);
                    $(document).ajaxAddToCart(ajaxAddToCart);
                }

                if (Foundation.utils.is_small_only())
                    productMediaGallery();

                $('.product-reviews-link').on('click', function(e) {

                    logicspot.scrollPastHeader(function(offset) {

                        if (Foundation.utils.is_medium_up()) {
                            var productAdditional = $('.product-additional');

                            productAdditional.find('.tab-title, .content').removeClass('active');
                            productAdditional.find('.tab-title:first-child, .tabs-content #box-product-options-reviews').addClass('active');

                            ospreyTabs.reInit();

                            $('html, body').animate({
                                scrollTop: $(".product-tab-row.show-for-medium-up").offset().top - offset
                            }, 2000);

                        } else {

                            $('html, body').animate({
                                scrollTop: $("#product-info-accordion").offset().top - offset
                            }, 2000);
                            $('.product-info-accordion #customer-reviews').parent().addClass('active');
                        }

                    });

                    e.preventDefault();

                });

                $('.scroll-to-features').on('click', function(e) {

                    logicspot.scrollPastHeader(function(offset) {

                        if (Foundation.utils.is_medium_up()) {
                            var productAdditional = $('.product-additional');

                            productAdditional.find('.tab-title, .tabs-content .content').removeClass('active');
                            productAdditional.find('.tab-title[data-alias="box-product-options-features"]').addClass('active');
                            productAdditional.find('.tabs-content #box-product-options-features').addClass('active');

                            ospreyTabs.reInit();
                        }

                        $('html, body').animate({
                            scrollTop: $(".product-tab-row.show-for-medium-up").offset().top - offset
                        }, 2000);

                    });

                    e.preventDefault();
                });

                //Package Sizer Panel
                jQuery('.sizing-info-link').on('click', function(e) {
                    e.preventDefault();
                    jQuery("#pack-sizer-modal").fadeIn();
                    jQuery(".pack-sizer-panel").hide();
                    jQuery("#pack-sizer-panel-1").show();
                    jQuery(".app-store-footer").show();
                });
                jQuery("#panel-button-1").on('click', function(e) {
                    jQuery("#pack-sizer-panel-1").hide();
                    jQuery("#pack-sizer-panel-2").show();
                });

                jQuery("#panel-button-2").on('click', function(e) {
                    jQuery("#pack-sizer-panel-2").hide();
                    jQuery("#pack-sizer-panel-3").show();
                });

                jQuery("#panel-button-3").on('click', function(e) {
                    jQuery("#pack-sizer-panel-3").hide();
                    jQuery("#pack-sizer-panel-4").show();
                });

                jQuery("#panel-button-4").on('click', function(e) {
                    jQuery("#pack-sizer-panel-4").hide();
                    jQuery("#pack-sizer-panel-5").show();
                });

                jQuery(".pack-sizer-close, #pack-sizer-overlay").on('click', function(e) {
                    jQuery("#pack-sizer-overlay").fadeOut();
                    jQuery("#pack-sizer-modal").fadeOut();
                });

                productThreeSixty();
                if (typeof ajaxLoadPostSettings !== 'undefined') {
                    ajaxLoadPosts(ajaxLoadPostSettings);
                }
            }
        },
        /* =====================================
		 *  Category page
		 * ===================================*/
        catalog_category_view: {
            init: function() {
                if (typeof configurableMediaImagesInit === 'function') {
                    configurableMediaImagesInit();
                }

                ospreyTooltips();
            },
            finalize: function() {
                initLayeredNavOpener();
                categoryPage();
                // stickyFilters.init();

            }
        },
        catalogsearch_result_index: {
            init: function() {// here
            },
            finalize: function() {
                initLayeredNavOpener();

                initAjaxCart();
            }
        },
        page_template_template_full_width: {
            init: function() {},
            finalize: function() {}
        },
        checkout_cart_index: {
            init: function() {
            },
            finalize: function() {
                ospreyInitBasketQuantityUpdate();
                initCouponButtonSwitch();
            }
        },
        onestepcheckout_index_index: {
            init: function() {},
            finalize: function() {
                observeCustomerButton();
                checkoutCardValidator();
                checkoutSaveCardTrigger();
            }
        },
        reg_index_index: {
            init: function() {
                productRegistrationInit();
            }
        },
        folkstorefinder_index_index: {
            finalize: function() {
                storeFinderInit();
            }
        },
        page_template_blog_page: {
            init: function() {
                document.querySelectorAll('img.logo-desktop')[1].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/Osprey_Logo_White.png";
                document.querySelectorAll('img.logo-desktop')[0].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/Osprey_Logo_White.png";
                document.querySelectorAll('img.logo-mobile')[0].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/osprey-logo-white.png";
                document.querySelectorAll('img.logo-mobile')[1].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/osprey-logo-white.png";
            }
        },
        single: {
            init: function() {
                document.querySelectorAll('img.logo-desktop')[1].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/Osprey_Logo_White.png";
                document.querySelectorAll('img.logo-desktop')[0].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/Osprey_Logo_White.png";
                document.querySelectorAll('img.logo-mobile')[0].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/osprey-logo-white.png";
                document.querySelectorAll('img.logo-mobile')[1].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/osprey-logo-white.png";
            }
        },
        search: {
            init: function() {
                document.querySelectorAll('img.logo-desktop')[1].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/Osprey_Logo_White.png";
                document.querySelectorAll('img.logo-desktop')[0].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/Osprey_Logo_White.png";
                document.querySelectorAll('img.logo-mobile')[0].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/osprey-logo-white.png";
                document.querySelectorAll('img.logo-mobile')[1].src = "https://www.ospreyeurope.com/wp-content/uploads/2018/01/osprey-logo-white.png";
            }
        }
    };

    $('.upsell-tabs').on('toggled', function(event, tab) {
        $('.upsell-items .active .widget-products')[0].slick.refresh();
    });

    // The routing fires all common scripts, followed by the page specific scripts.
    // Add additional events for more control over timing e.g. a finalize event
    var UTIL = {
        fire: function(func, funcname, args) {
            var fire;
            var namespace = logicspot;
            funcname = (funcname === undefined) ? 'init' : funcname;
            fire = func !== '';
            fire = fire && namespace[func];
            fire = fire && typeof namespace[func][funcname] === 'function';

            if (fire) {
                namespace[func][funcname](args);
            }
        },
        remove_duplicates: function(arr) {
            var obj = {};
            var ret_arr = [];
            for (var i = 0; i < arr.length; i++) {
                obj[arr[i]] = true;
            }
            for (var key in obj) {
                ret_arr.push(key);
            }
            return ret_arr;
        },
        loadEvents: function() {
            // Fire common init JS
            UTIL.fire('common');

            var bodyClasses = UTIL.remove_duplicates(document.body.className.replace(/-/g, '_').split(/\s+/));

            // Fire page-specific init JS, and then finalize JS
            $.each(bodyClasses, function(i, classnm) {
                UTIL.fire(classnm);
                UTIL.fire(classnm, 'finalize');
            });

            $(".required_message, .giftcard_required_message").each(function() {
                var str = $(this).text();
                strArr = str.split("");
                for (var key = 0; key <= strArr.length - 1; key++) {
                    if (strArr[key] == '*') {
                        var newStr = "<span class='red_asterix'>" + strArr[key] + "</span>";
                        strArr[key] = newStr;
                    }
                }
                var newText = strArr.join("");
                $(this).html(newText);
            });

            // Fire common finalize JS
            UTIL.fire('common', 'finalize');
        }
    };

    // Load Events
    $(document).ready(UTIL.loadEvents);

}
)(jQuery);

/* FILE: imagesloaded.js */
/*!
 * imagesLoaded PACKAGED v3.1.4
 * JavaScript is all like "You images are done yet or what?"
 * MIT License
 */

(function() {
    function e() {}
    function t(e, t) {
        for (var n = e.length; n--; )
            if (e[n].listener === t)
                return n;
        return -1
    }
    function n(e) {
        return function() {
            return this[e].apply(this, arguments)
        }
    }
    var i = e.prototype
      , r = this
      , o = r.EventEmitter;
    i.getListeners = function(e) {
        var t, n, i = this._getEvents();
        if ("object" == typeof e) {
            t = {};
            for (n in i)
                i.hasOwnProperty(n) && e.test(n) && (t[n] = i[n])
        } else
            t = i[e] || (i[e] = []);
        return t
    }
    ,
    i.flattenListeners = function(e) {
        var t, n = [];
        for (t = 0; e.length > t; t += 1)
            n.push(e[t].listener);
        return n
    }
    ,
    i.getListenersAsObject = function(e) {
        var t, n = this.getListeners(e);
        return n instanceof Array && (t = {},
        t[e] = n),
        t || n
    }
    ,
    i.addListener = function(e, n) {
        var i, r = this.getListenersAsObject(e), o = "object" == typeof n;
        for (i in r)
            r.hasOwnProperty(i) && -1 === t(r[i], n) && r[i].push(o ? n : {
                listener: n,
                once: !1
            });
        return this
    }
    ,
    i.on = n("addListener"),
    i.addOnceListener = function(e, t) {
        return this.addListener(e, {
            listener: t,
            once: !0
        })
    }
    ,
    i.once = n("addOnceListener"),
    i.defineEvent = function(e) {
        return this.getListeners(e),
        this
    }
    ,
    i.defineEvents = function(e) {
        for (var t = 0; e.length > t; t += 1)
            this.defineEvent(e[t]);
        return this
    }
    ,
    i.removeListener = function(e, n) {
        var i, r, o = this.getListenersAsObject(e);
        for (r in o)
            o.hasOwnProperty(r) && (i = t(o[r], n),
            -1 !== i && o[r].splice(i, 1));
        return this
    }
    ,
    i.off = n("removeListener"),
    i.addListeners = function(e, t) {
        return this.manipulateListeners(!1, e, t)
    }
    ,
    i.removeListeners = function(e, t) {
        return this.manipulateListeners(!0, e, t)
    }
    ,
    i.manipulateListeners = function(e, t, n) {
        var i, r, o = e ? this.removeListener : this.addListener, s = e ? this.removeListeners : this.addListeners;
        if ("object" != typeof t || t instanceof RegExp)
            for (i = n.length; i--; )
                o.call(this, t, n[i]);
        else
            for (i in t)
                t.hasOwnProperty(i) && (r = t[i]) && ("function" == typeof r ? o.call(this, i, r) : s.call(this, i, r));
        return this
    }
    ,
    i.removeEvent = function(e) {
        var t, n = typeof e, i = this._getEvents();
        if ("string" === n)
            delete i[e];
        else if ("object" === n)
            for (t in i)
                i.hasOwnProperty(t) && e.test(t) && delete i[t];
        else
            delete this._events;
        return this
    }
    ,
    i.removeAllListeners = n("removeEvent"),
    i.emitEvent = function(e, t) {
        var n, i, r, o, s = this.getListenersAsObject(e);
        for (r in s)
            if (s.hasOwnProperty(r))
                for (i = s[r].length; i--; )
                    n = s[r][i],
                    n.once === !0 && this.removeListener(e, n.listener),
                    o = n.listener.apply(this, t || []),
                    o === this._getOnceReturnValue() && this.removeListener(e, n.listener);
        return this
    }
    ,
    i.trigger = n("emitEvent"),
    i.emit = function(e) {
        var t = Array.prototype.slice.call(arguments, 1);
        return this.emitEvent(e, t)
    }
    ,
    i.setOnceReturnValue = function(e) {
        return this._onceReturnValue = e,
        this
    }
    ,
    i._getOnceReturnValue = function() {
        return this.hasOwnProperty("_onceReturnValue") ? this._onceReturnValue : !0
    }
    ,
    i._getEvents = function() {
        return this._events || (this._events = {})
    }
    ,
    e.noConflict = function() {
        return r.EventEmitter = o,
        e
    }
    ,
    "function" == typeof define && define.amd ? define("eventEmitter/EventEmitter", [], function() {
        return e
    }) : "object" == typeof module && module.exports ? module.exports = e : this.EventEmitter = e
}
).call(this),
function(e) {
    function t(t) {
        var n = e.event;
        return n.target = n.target || n.srcElement || t,
        n
    }
    var n = document.documentElement
      , i = function() {};
    n.addEventListener ? i = function(e, t, n) {
        e.addEventListener(t, n, !1)
    }
    : n.attachEvent && (i = function(e, n, i) {
        e[n + i] = i.handleEvent ? function() {
            var n = t(e);
            i.handleEvent.call(i, n)
        }
        : function() {
            var n = t(e);
            i.call(e, n)
        }
        ,
        e.attachEvent("on" + n, e[n + i])
    }
    );
    var r = function() {};
    n.removeEventListener ? r = function(e, t, n) {
        e.removeEventListener(t, n, !1)
    }
    : n.detachEvent && (r = function(e, t, n) {
        e.detachEvent("on" + t, e[t + n]);
        try {
            delete e[t + n]
        } catch (i) {
            e[t + n] = void 0
        }
    }
    );
    var o = {
        bind: i,
        unbind: r
    };
    "function" == typeof define && define.amd ? define("eventie/eventie", o) : e.eventie = o
}(this),
function(e, t) {
    "function" == typeof define && define.amd ? define(["eventEmitter/EventEmitter", "eventie/eventie"], function(n, i) {
        return t(e, n, i)
    }) : "object" == typeof exports ? module.exports = t(e, require("eventEmitter"), require("eventie")) : e.imagesLoaded = t(e, e.EventEmitter, e.eventie)
}(this, function(e, t, n) {
    function i(e, t) {
        for (var n in t)
            e[n] = t[n];
        return e
    }
    function r(e) {
        return "[object Array]" === d.call(e)
    }
    function o(e) {
        var t = [];
        if (r(e))
            t = e;
        else if ("number" == typeof e.length)
            for (var n = 0, i = e.length; i > n; n++)
                t.push(e[n]);
        else
            t.push(e);
        return t
    }
    function s(e, t, n) {
        if (!(this instanceof s))
            return new s(e,t);
        "string" == typeof e && (e = document.querySelectorAll(e)),
        this.elements = o(e),
        this.options = i({}, this.options),
        "function" == typeof t ? n = t : i(this.options, t),
        n && this.on("always", n),
        this.getImages(),
        a && (this.jqDeferred = new a.Deferred);
        var r = this;
        setTimeout(function() {
            r.check()
        })
    }
    function c(e) {
        this.img = e
    }
    function f(e) {
        this.src = e,
        v[e] = this
    }
    var a = e.jQuery
      , u = e.console
      , h = u !== void 0
      , d = Object.prototype.toString;
    s.prototype = new t,
    s.prototype.options = {},
    s.prototype.getImages = function() {
        this.images = [];
        for (var e = 0, t = this.elements.length; t > e; e++) {
            var n = this.elements[e];
            "IMG" === n.nodeName && this.addImage(n);
            for (var i = n.querySelectorAll("img"), r = 0, o = i.length; o > r; r++) {
                var s = i[r];
                this.addImage(s)
            }
        }
    }
    ,
    s.prototype.addImage = function(e) {
        var t = new c(e);
        this.images.push(t)
    }
    ,
    s.prototype.check = function() {
        function e(e, r) {
            return t.options.debug && h && u.log("confirm", e, r),
            t.progress(e),
            n++,
            n === i && t.complete(),
            !0
        }
        var t = this
          , n = 0
          , i = this.images.length;
        if (this.hasAnyBroken = !1,
        !i)
            return this.complete(),
            void 0;
        for (var r = 0; i > r; r++) {
            var o = this.images[r];
            o.on("confirm", e),
            o.check()
        }
    }
    ,
    s.prototype.progress = function(e) {
        this.hasAnyBroken = this.hasAnyBroken || !e.isLoaded;
        var t = this;
        setTimeout(function() {
            t.emit("progress", t, e),
            t.jqDeferred && t.jqDeferred.notify && t.jqDeferred.notify(t, e)
        })
    }
    ,
    s.prototype.complete = function() {
        var e = this.hasAnyBroken ? "fail" : "done";
        this.isComplete = !0;
        var t = this;
        setTimeout(function() {
            if (t.emit(e, t),
            t.emit("always", t),
            t.jqDeferred) {
                var n = t.hasAnyBroken ? "reject" : "resolve";
                t.jqDeferred[n](t)
            }
        })
    }
    ,
    a && (a.fn.imagesLoaded = function(e, t) {
        var n = new s(this,e,t);
        return n.jqDeferred.promise(a(this))
    }
    ),
    c.prototype = new t,
    c.prototype.check = function() {
        var e = v[this.img.src] || new f(this.img.src);
        if (e.isConfirmed)
            return this.confirm(e.isLoaded, "cached was confirmed"),
            void 0;
        if (this.img.complete && void 0 !== this.img.naturalWidth)
            return this.confirm(0 !== this.img.naturalWidth, "naturalWidth"),
            void 0;
        var t = this;
        e.on("confirm", function(e, n) {
            return t.confirm(e.isLoaded, n),
            !0
        }),
        e.check()
    }
    ,
    c.prototype.confirm = function(e, t) {
        this.isLoaded = e,
        this.emit("confirm", this, t)
    }
    ;
    var v = {};
    return f.prototype = new t,
    f.prototype.check = function() {
        if (!this.isChecked) {
            var e = new Image;
            n.bind(e, "load", this),
            n.bind(e, "error", this),
            e.src = this.src,
            this.isChecked = !0
        }
    }
    ,
    f.prototype.handleEvent = function(e) {
        var t = "on" + e.type;
        this[t] && this[t](e)
    }
    ,
    f.prototype.onload = function(e) {
        this.confirm(!0, "onload"),
        this.unbindProxyEvents(e)
    }
    ,
    f.prototype.onerror = function(e) {
        this.confirm(!1, "onerror"),
        this.unbindProxyEvents(e)
    }
    ,
    f.prototype.confirm = function(e, t) {
        this.isConfirmed = !0,
        this.isLoaded = e,
        this.emit("confirm", this, t)
    }
    ,
    f.prototype.unbindProxyEvents = function(e) {
        n.unbind(e.target, "load", this),
        n.unbind(e.target, "error", this)
    }
    ,
    s
});

/* FILE: product-media.js */
/**
 * Magento
 *
 * NOTICE OF LICENSE
 *
 * This source file is subject to the Academic Free License (AFL 3.0)
 * that is bundled with this package in the file LICENSE_AFL.txt.
 * It is also available through the world-wide-web at this URL:
 * http://opensource.org/licenses/afl-3.0.php
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to license@magento.com so we can send you a copy immediately.
 *
 * DISCLAIMER
 *
 * Do not edit or add to this file if you wish to upgrade Magento to newer
 * versions in the future. If you wish to customize Magento for your
 * needs please refer to http://www.magento.com for more information.
 *
 * @category    design
 * @package     rwd_default
 * @copyright   Copyright (c) 2006-2016 X.commerce, Inc. and affiliates (http://www.magento.com)
 * @license     http://opensource.org/licenses/afl-3.0.php  Academic Free License (AFL 3.0)
 */

var ConfigurableMediaImages = {
    imageType: null,
    productImages: {},
    imageObjects: {},

    arrayIntersect: function(a, b) {
        var ai = 0
          , bi = 0;
        var result = new Array();

        while (ai < a.length && bi < b.length) {
            if (a[ai] < b[bi]) {
                ai++;
            } else if (a[ai] > b[bi]) {
                bi++;
            } else /* they're equal */
            {
                result.push(a[ai]);
                ai++;
                bi++;
            }
        }

        return result;
    },

    getCompatibleProductImages: function(productFallback, selectedLabels) {
        //find compatible products
        var compatibleProducts = [];
        var compatibleProductSets = [];
        selectedLabels.each(function(selectedLabel) {
            if (typeof (productFallback['option_labels']) != 'undefined') {
                if (!productFallback['option_labels'][selectedLabel]) {
                    return;
                }

                var optionProducts = productFallback['option_labels'][selectedLabel]['products'];
                compatibleProductSets.push(optionProducts);

                //optimistically push all products
                optionProducts.each(function(productId) {
                    compatibleProducts.push(productId);
                });
            }
        });

        //intersect compatible products
        compatibleProductSets.each(function(productSet) {
            compatibleProducts = ConfigurableMediaImages.arrayIntersect(compatibleProducts, productSet);
        });

        return compatibleProducts;
    },

    isValidImage: function(fallbackImageUrl) {
        if (!fallbackImageUrl) {
            return false;
        }

        return true;
    },

    getSwatchImage: function(productId, optionLabel, selectedLabels) {
        var fallback = ConfigurableMediaImages.productImages[productId];
        if (!fallback) {
            return null;
        }

        //first, try to get label-matching image on config product for this option's label
        if (typeof (fallback['option_labels']) != 'undefined') {
            var currentLabelImage = fallback['option_labels'][optionLabel];
            if (currentLabelImage && fallback['option_labels'][optionLabel]['configurable_product'][ConfigurableMediaImages.imageType]) {
                //found label image on configurable product
                return fallback['option_labels'][optionLabel]['configurable_product'][ConfigurableMediaImages.imageType];
            }
        }

        var compatibleProducts = ConfigurableMediaImages.getCompatibleProductImages(fallback, selectedLabels);

        if (compatibleProducts.length == 0) {
            //no compatible products
            return null;
            //bail
        }

        //second, get any product which is compatible with currently selected option(s)
        jQuery.each(fallback['option_labels'], function(key, value) {
            var image = value['configurable_product'][ConfigurableMediaImages.imageType];
            var products = value['products'];

            if (image) {
                //configurable product has image in the first place
                //if intersection between compatible products and this label's products, we found a match
                var isCompatibleProduct = ConfigurableMediaImages.arrayIntersect(products, compatibleProducts).length > 0;
                if (isCompatibleProduct) {
                    return image;
                }
            }
        });

        //third, get image off of child product which is compatible
        var childSwatchImage = null;
        var childProductImages = fallback[ConfigurableMediaImages.imageType];
        compatibleProducts.each(function(productId) {
            if (childProductImages[productId] && ConfigurableMediaImages.isValidImage(childProductImages[productId])) {
                childSwatchImage = childProductImages[productId];
                return false;
                //break "loop"
            }
        });
        if (childSwatchImage) {
            return childSwatchImage;
        }

        //fourth, get base image off parent product
        if (childProductImages[productId] && ConfigurableMediaImages.isValidImage(childProductImages[productId])) {
            return childProductImages[productId];
        }

        //no fallback image found
        return null;
    },

    getImageObject: function(productId, imageUrl) {
        var key = productId + '-' + imageUrl;
        if (!ConfigurableMediaImages.imageObjects[key]) {
            var image = jQuery('<img />');
            image.attr('src', imageUrl);
            ConfigurableMediaImages.imageObjects[key] = image;
        }
        return ConfigurableMediaImages.imageObjects[key];
    },

    updateImage: function(el) {
        var select = jQuery(el);
        var label = select.find('option:selected').attr('data-label');
        var productId = optionsPrice.productId;
        //get product ID from options price object

        //find all selected labels
        var selectedLabels = new Array();

        jQuery('.product-options .super-attribute-select').each(function() {
            var $option = jQuery(this);
            if ($option.val() != '') {
                selectedLabels.push($option.find('option:selected').attr('data-label'));
            }
        });

        var swatchImageUrl = ConfigurableMediaImages.getSwatchImage(productId, label, selectedLabels);
        if (!ConfigurableMediaImages.isValidImage(swatchImageUrl)) {
            return;
        }

        var swatchImage = ConfigurableMediaImages.getImageObject(productId, swatchImageUrl);

        ProductMediaManager.swapImage(swatchImage);
    },

    wireOptions: function() {
        jQuery('.product-options .super-attribute-select').change(function(e) {
            ConfigurableMediaImages.updateImage(this);
        });
    },

    swapListImage: function(productId, imageObject) {
        imageObject.removeClass('hide');
        imageObject.addClass('bottom-border');
        var originalImage = jQuery('#product-collection-image-' + productId);
        if (imageObject[0].complete) {
            //swap image immediately

            //remove old image
            originalImage.addClass('hide');
            jQuery('.product-collection-image-' + productId).remove();

            //add new image
            imageObject.insertAfter(originalImage);

        } else {
            //need to load image

            var wrapper = originalImage.parent();

            //add spinner
            wrapper.addClass('loading');

            //wait until image is loaded
            imagesLoaded(imageObject, function() {
                //remove spinner
                wrapper.removeClass('loading');

                //remove old image
                originalImage.addClass('hide');
                jQuery('.product-collection-image-' + productId).remove();

                //add new image
                imageObject.insertAfter(originalImage);
            });

        }
    },

    swapListImageByOption: function(productId, optionLabel) {
        var swatchImageUrl = ConfigurableMediaImages.getSwatchImage(productId, optionLabel, [optionLabel]);
        if (!swatchImageUrl) {
            return;
        }

        var newImage = ConfigurableMediaImages.getImageObject(productId, swatchImageUrl);
        newImage.addClass('product-collection-image-' + productId);

        ConfigurableMediaImages.swapListImage(productId, newImage);
    },

    setImageFallback: function(productId, imageFallback) {
        ConfigurableMediaImages.productImages[productId] = imageFallback;
    },

    init: function(imageType) {
        ConfigurableMediaImages.imageType = imageType;
        ConfigurableMediaImages.wireOptions();
    }
};

/* FILE: swatches-list.js */
/**
 * Magento
 *
 * NOTICE OF LICENSE
 *
 * This source file is subject to the Academic Free License (AFL 3.0)
 * that is bundled with this package in the file LICENSE_AFL.txt.
 * It is also available through the world-wide-web at this URL:
 * http://opensource.org/licenses/afl-3.0.php
 * If you did not receive a copy of the license and are unable to
 * obtain it through the world-wide-web, please send an email
 * to license@magento.com so we can send you a copy immediately.
 *
 * DISCLAIMER
 *
 * Do not edit or add to this file if you wish to upgrade Magento to newer
 * versions in the future. If you wish to customize Magento for your
 * needs please refer to http://www.magento.com for more information.
 *
 * @category    design
 * @package     rwd_default
 * @copyright   Copyright (c) 2006-2016 X.commerce, Inc. and affiliates (http://www.magento.com)
 * @license     http://opensource.org/licenses/afl-3.0.php  Academic Free License (AFL 3.0)
 */

var ConfigurableSwatchesList = {
    swatchesByProduct: {},

    init: function() {
        var that = this;
        jQuery('.configurable-swatch-list li').each(function() {
            that.initSwatch(this);
            var $swatch = jQuery(this);
            if ($swatch.hasClass('filter-match')) {
                that.handleSwatchSelect($swatch);
            }
        });
    },

    initSwatch: function(swatch) {
        var that = this;
        var $swatch = jQuery(swatch);
        var productId;
        jQuery($swatch).hover(function() {
            /**
             *
             * - Preview the stock status
             **/
            var swatchUl = $swatch.parent();
            swatchUl.find('.x').each(function() {
                jQuery(this).show();
                jQuery(this).closest('li').addClass('not-available');
            });
        });
        if (productId = $swatch.data('product-id')) {
            if (typeof (this.swatchesByProduct[productId]) == 'undefined') {
                this.swatchesByProduct[productId] = [];
            }
            this.swatchesByProduct[productId].push($swatch);

            $swatch.find('a').on('click', function(e) {
                e.preventDefault();
                that.handleSwatchSelect($swatch);
            });
        }
    },

    handleSwatchSelect: function($swatch) {
        var productId = $swatch.data('product-id');
        var label;
        if (label = $swatch.data('option-label')) {
            ConfigurableMediaImages.swapListImageByOption(productId, label);
        }

        jQuery.each(this.swatchesByProduct[productId], function(key, $productSwatch) {
            $productSwatch.removeClass('selected');
        });

        $swatch.addClass('selected');
    }
};

jQuery(document).on('configurable-media-images-init', function() {
    ConfigurableSwatchesList.init();
});
